================================================================================
ADD DIGITS - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer num, repeatedly add all its digits until the result has only 
one digit, and return it.

EXAMPLES:
---------
Example 1:
  Input: num = 38
  Output: 2
  Explanation: The process is
    38 --> 3 + 8 --> 11
    11 --> 1 + 1 --> 2 
    Since 2 has only one digit, return it.

Example 2:
  Input: num = 0
  Output: 0

CONSTRAINTS:
------------
- 0 <= num <= 2^31 - 1

Follow-up: Could you do it without any loop/recursion in O(1) runtime?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Repeatedly summing digits until single digit
2. Achieving O(1) time (follow-up)
3. Understanding digital root pattern
4. Avoiding loops/recursion (follow-up)

ALGORITHM STEPS:
----------------
Approach 1: Digital Root Formula (Optimal)
1. If num == 0, return 0
2. If num % 9 == 0, return 9
3. Otherwise, return num % 9

Approach 2: Loop
1. While num >= 10:
   a. Sum all digits
   b. Update num with sum
2. Return num

Approach 3: Recursion (From original)
1. If num < 10, return num
2. Otherwise, recursively call with sum of digits


DETAILED EXPLANATION:
---------------------

Digital Root Pattern:
---------------------
The result follows a pattern based on modulo 9:

num  | sum | result
-----|-----|-------
1    | 1   | 1
2    | 2   | 2
...  | ... | ...
9    | 9   | 9
10   | 1+0 | 1
11   | 1+1 | 2
18   | 1+8 | 9
19   | 1+9 | 10 → 1+0 | 1
27   | 2+7 | 9
38   | 3+8 | 11 → 1+1 | 2

Pattern: result = num % 9, except when num % 9 == 0 and num != 0

Why This Works (Mathematical Proof):
-------------------------------------
A number and the sum of its digits are congruent modulo 9.

Example: 38
  38 = 3×10 + 8
     = 3×(9+1) + 8
     = 3×9 + 3 + 8
     = 3×9 + 11
  
  38 ≡ 11 (mod 9)
  11 ≡ 2 (mod 9)
  
  Therefore: 38 ≡ 2 (mod 9)

Special Cases:
--------------
- num = 0: return 0
- num % 9 = 0 and num != 0: return 9
  (e.g., 9, 18, 27 all have digital root 9)

Formula:
--------
digital_root = 1 + ((num - 1) % 9)

Or equivalently:
if num == 0: return 0
if num % 9 == 0: return 9
else: return num % 9


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Digital Root Formula ✓ OPTIMAL
def addDigits_formula(num):
    if num == 0:
        return 0
    if num % 9 == 0:
        return 9
    return num % 9


# One-liner formula
def addDigits_oneliner(num):
    return 1 + (num - 1) % 9 if num else 0


# Approach 2: Loop
def addDigits_loop(num):
    while num >= 10:
        total = 0
        while num > 0:
            total += num % 10
            num = num // 10
        num = total
    return num


# Approach 3: Recursion (From original)
def addDigits_recursive(num):
    if num < 10:
        return num
    return addDigits_recursive(sum_digits(num))

def sum_digits(num):
    res = 0
    while num > 0:
        res += num % 10
        num = num // 10
    return res


# LeetCode Solution Class Format
class Solution:
    def addDigits(self, num: int) -> int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Digital Root Formula
---------------------------------
Time Complexity: O(1)
  - Constant time modulo operation
  - Total: O(1) ✓ MEETS FOLLOW-UP

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)

Approach 2: Loop
----------------
Time Complexity: O(log n)
  - Each iteration reduces number of digits
  - Worst case: O(log n)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)

Approach 3: Recursion
---------------------
Time Complexity: O(log n)
  - Similar to loop approach
  - Total: O(log n)

Space Complexity: O(log n)
  - Recursion stack depth
  - Total: O(log n)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Example from Problem
  Input: num = 38
  Output: 2
  ✓ 38 → 11 → 2

Test Case 2: Zero
  Input: num = 0
  Output: 0
  ✓ Zero stays zero

Test Case 3: Single Digit
  Input: num = 5
  Output: 5
  ✓ Already single digit

Test Case 4: Multiple of 9
  Input: num = 18
  Output: 9
  ✓ 18 → 9

Test Case 5: Large Number
  Input: num = 9999
  Output: 9
  ✓ 9+9+9+9 = 36 → 9

Test Case 6: Another Example
  Input: num = 123
  Output: 6
  ✓ 1+2+3 = 6


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Digital Root Formula ✓ RECOMMENDED
-----------------------------------------------
Use mathematical property: num % 9.

Pros:
  - O(1) time and space
  - Meets follow-up requirement
  - No loops or recursion
  - Elegant mathematical solution

Cons:
  - Requires understanding digital root
  - Less intuitive

Approach 2: Loop
----------------
Repeatedly sum digits until single digit.

Pros:
  - Intuitive and easy to understand
  - Clear logic

Cons:
  - O(log n) time
  - Uses loops (violates follow-up)

Approach 3: Recursion
---------------------
Recursive digit summing.

Pros:
  - Clean recursive solution
  - Easy to understand

Cons:
  - O(log n) time and space
  - Uses recursion (violates follow-up)


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Zero
   ❌ Returning 9 for num = 0
   ✓ Special case: return 0

2. Wrong Formula
   ❌ Always returning num % 9
   ✓ Handle num % 9 == 0 case

3. Not Understanding Pattern
   ❌ Using loops when O(1) exists
   ✓ Use digital root formula

4. Off-by-One in Formula
   ❌ Using wrong formula variant
   ✓ Use 1 + (num-1) % 9 or conditional

5. Infinite Loop
   ❌ Wrong loop condition
   ✓ Loop while num >= 10


================================================================================
KEY TAKEAWAYS
================================================================================

1. Digital root has mathematical formula: num % 9
2. Special cases: 0 returns 0, multiples of 9 return 9
3. Formula: 1 + (num - 1) % 9 handles all cases
4. Number ≡ sum of digits (mod 9)
5. O(1) solution exists without loops
6. This is a number theory problem


================================================================================
RELATED PROBLEMS
================================================================================

- Happy Number (Easy) - Similar digit manipulation
- Sum of Digits in Base K (Easy) - Digit summing
- Ugly Number (Easy) - Number properties
- Perfect Number (Easy) - Number classification
- Self Dividing Numbers (Easy) - Digit operations
- Factorial Trailing Zeroes (Medium) - Number theory


================================================================================
