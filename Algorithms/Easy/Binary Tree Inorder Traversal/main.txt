================================================================================
BINARY TREE INORDER TRAVERSAL - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the root of a binary tree, return the inorder traversal of its nodes' 
values.

EXAMPLES:
---------
Example 1:
  Input: root = [1,null,2,3]
  Output: [1,3,2]

Example 2:
  Input: root = []
  Output: []

Example 3:
  Input: root = [1]
  Output: [1]

CONSTRAINTS:
------------
- The number of nodes in the tree is in the range [0, 100]
- -100 <= Node.val <= 100

Follow-up: Recursive solution is trivial, could you do it iteratively?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Understanding inorder traversal (Left-Root-Right)
2. Implementing recursively and iteratively
3. Handling empty tree
4. Managing stack for iterative approach

ALGORITHM STEPS:
----------------
Approach 1: Recursive
1. Base case: if node is null, return
2. Recursively traverse left subtree
3. Visit current node (add to result)
4. Recursively traverse right subtree

Approach 2: Iterative (Stack)
1. Use stack to simulate recursion
2. Go left as far as possible, pushing nodes
3. Pop node, add to result
4. Move to right child


DETAILED EXPLANATION:
---------------------

Inorder Traversal Order:
------------------------
Left → Root → Right

Example Tree:
      1
       \
        2
       /
      3

Inorder: Left(null) → 1 → Right(2)
  For node 2: Left(3) → 2 → Right(null)
    For node 3: Left(null) → 3 → Right(null)

Result: [1, 3, 2]

Recursive Approach:
-------------------
Natural and intuitive for tree problems.

```
inorder(node):
  if node is null: return
  inorder(node.left)    # Visit left
  result.append(node.val)  # Visit root
  inorder(node.right)   # Visit right
```

Iterative Approach:
-------------------
Use stack to track nodes.

Example: Tree [1,null,2,3]
      1
       \
        2
       /
      3

Step 1: current=1, stack=[]
  - Go left: no left child
  - Add 1 to stack: [1]
  - Pop 1, add to result: [1]
  - Move to right: current=2

Step 2: current=2, stack=[]
  - Go left: has left child (3)
  - Add 2 to stack: [2]
  - Move to left: current=3

Step 3: current=3, stack=[2]
  - Go left: no left child
  - Add 3 to stack: [2,3]
  - Pop 3, add to result: [1,3]
  - Move to right: current=null

Step 4: current=null, stack=[2]
  - Pop 2, add to result: [1,3,2]
  - Move to right: current=null

Done! Result: [1,3,2]


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Recursive ✓ SIMPLE
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            result.append(node.val)
            inorder(node.right)
        
        inorder(root)
        return result


# Approach 2: Iterative (Stack) ✓ MEETS FOLLOW-UP
def inorderTraversal_iterative(root):
    result = []
    stack = []
    current = root
    
    while current or stack:
        # Go to leftmost node
        while current:
            stack.append(current)
            current = current.left
        
        # Process node
        current = stack.pop()
        result.append(current.val)
        
        # Move to right subtree
        current = current.right
    
    return result


# Approach 3: Morris Traversal (O(1) space)
def inorderTraversal_morris(root):
    result = []
    current = root
    
    while current:
        if not current.left:
            # No left child, visit current
            result.append(current.val)
            current = current.right
        else:
            # Find predecessor
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if not predecessor.right:
                # Create thread
                predecessor.right = current
                current = current.left
            else:
                # Remove thread
                predecessor.right = None
                result.append(current.val)
                current = current.right
    
    return result


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Recursive
----------------------
Time Complexity: O(n)
  - Visit each node once
  - Total: O(n)

Space Complexity: O(h)
  - h = height of tree
  - Recursion stack
  - Worst case: O(n) for skewed tree
  - Best case: O(log n) for balanced tree

Approach 2: Iterative
---------------------
Time Complexity: O(n)
  - Visit each node once
  - Total: O(n)

Space Complexity: O(h)
  - Stack stores at most h nodes
  - Worst case: O(n)
  - Best case: O(log n)

Approach 3: Morris Traversal
-----------------------------
Time Complexity: O(n)
  - Each edge traversed at most twice
  - Total: O(n)

Space Complexity: O(1)
  - No stack or recursion
  - Total: O(1) ✓ OPTIMAL SPACE


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Right-skewed Tree
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ✓ Correct inorder

Test Case 2: Empty Tree
  Input: root = []
  Output: []
  ✓ Empty result

Test Case 3: Single Node
  Input: root = [1]
  Output: [1]
  ✓ Single element

Test Case 4: Balanced Tree
  Input: root = [2,1,3]
  Output: [1,2,3]
  ✓ Sorted order for BST


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Recursive ✓ SIMPLEST
---------------------------------
Natural recursive solution.

Pros:
  - Very simple and clean
  - Easy to understand
  - Concise code

Cons:
  - Uses recursion stack
  - Not iterative (violates follow-up)

Approach 2: Iterative ✓ RECOMMENDED
------------------------------------
Use stack to simulate recursion.

Pros:
  - Meets follow-up requirement
  - No recursion
  - O(n) time, O(h) space

Cons:
  - More complex than recursive
  - Requires understanding stack

Approach 3: Morris Traversal
-----------------------------
Thread tree for O(1) space.

Pros:
  - O(1) space complexity
  - No stack or recursion
  - Optimal space

Cons:
  - Most complex
  - Modifies tree (temporarily)
  - Harder to understand


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Wrong Traversal Order
   ❌ Visiting root before left
   ✓ Inorder: Left → Root → Right

2. Not Handling Empty Tree
   ❌ Not checking if root is null
   ✓ Return empty list for null root

3. Stack Management
   ❌ Wrong stack operations in iterative
   ✓ Push while going left, pop to visit

4. Forgetting Right Subtree
   ❌ Not moving to right after visiting node
   ✓ Always check right subtree

5. Infinite Loop
   ❌ Wrong loop condition in iterative
   ✓ while current or stack


================================================================================
KEY TAKEAWAYS
================================================================================

1. Inorder: Left → Root → Right
2. Recursive solution is most natural
3. Iterative uses stack to simulate recursion
4. Morris traversal achieves O(1) space
5. For BST, inorder gives sorted order
6. Time complexity always O(n)


================================================================================
RELATED PROBLEMS
================================================================================

- Binary Tree Preorder Traversal (Easy) - Root-Left-Right
- Binary Tree Postorder Traversal (Easy) - Left-Right-Root
- Binary Tree Level Order Traversal (Medium) - BFS
- Validate Binary Search Tree (Medium) - Uses inorder
- Kth Smallest Element in a BST (Medium) - Inorder application
- Recover Binary Search Tree (Medium) - Inorder property


================================================================================
