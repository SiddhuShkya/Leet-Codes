================================================================================
CLIMBING STAIRS - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can 
you climb to the top?

EXAMPLES:
---------
Example 1:
  Input: n = 2
  Output: 2
  Explanation: There are two ways to climb to the top.
    1. 1 step + 1 step
    2. 2 steps

Example 2:
  Input: n = 3
  Output: 3
  Explanation: There are three ways to climb to the top.
    1. 1 step + 1 step + 1 step
    2. 1 step + 2 steps
    3. 2 steps + 1 step

CONSTRAINTS:
------------
- 1 <= n <= 45


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Recognizing this as a Fibonacci sequence problem
2. Avoiding exponential time complexity of recursion
3. Optimizing space from O(n) to O(1)
4. Handling base cases correctly

ALGORITHM STEPS:
----------------
Approach 1: Dynamic Programming (Bottom-Up)
1. Create dp array of size n+1
2. Initialize base cases: dp[0] = 1, dp[1] = 1
3. For each step i from 2 to n:
   - dp[i] = dp[i-1] + dp[i-2]
4. Return dp[n]

Approach 2: Space-Optimized DP
1. Use only two variables instead of array
2. Keep track of previous two values
3. Update them as we iterate


DETAILED EXPLANATION:
---------------------

Why This is Fibonacci:
----------------------
To reach step n, you can either:
  - Come from step (n-1) and take 1 step
  - Come from step (n-2) and take 2 steps

Therefore: ways(n) = ways(n-1) + ways(n-2)

This is exactly the Fibonacci sequence!

Example Walkthrough for n = 5:
-------------------------------
Step 0: 1 way (starting position)
Step 1: 1 way (one 1-step)
Step 2: 2 ways (1+1 or 2)
Step 3: 3 ways (ways to reach step 1 + ways to reach step 2 = 1 + 2 = 3)
Step 4: 5 ways (ways to reach step 2 + ways to reach step 3 = 2 + 3 = 5)
Step 5: 8 ways (ways to reach step 3 + ways to reach step 4 = 3 + 5 = 8)

Sequence: 1, 1, 2, 3, 5, 8, 13, 21, ...

Why DP Instead of Recursion:
-----------------------------
Naive recursion: ways(n) = ways(n-1) + ways(n-2)
  - Time: O(2^n) - exponential!
  - Many overlapping subproblems

DP stores results to avoid recomputation:
  - Time: O(n) - linear
  - Each subproblem solved once


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Dynamic Programming with Array
def climbStairs(n):
    if n <= 1:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[-1]


# Approach 2: Space-Optimized DP (O(1) space)
def climbStairs_optimized(n):
    if n <= 1:
        return 1
    
    prev2 = 1  # dp[0]
    prev1 = 1  # dp[1]
    
    for i in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1


# Approach 3: Recursive with Memoization
def climbStairs_memo(n, memo={}):
    if n <= 1:
        return 1
    if n in memo:
        return memo[n]
    
    memo[n] = climbStairs_memo(n-1, memo) + climbStairs_memo(n-2, memo)
    return memo[n]


# LeetCode Solution Class Format
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return 1
        
        dp = [0] * (n + 1)
        dp[0] = dp[1] = 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[-1]


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: DP with Array
--------------------------
Time Complexity: O(n)
  - Single loop from 2 to n
  - Each iteration is O(1)
  - Total: O(n)

Space Complexity: O(n)
  - DP array of size n+1
  - Total: O(n)

Approach 2: Space-Optimized DP
-------------------------------
Time Complexity: O(n)
  - Same as approach 1
  - Single loop through n steps

Space Complexity: O(1)
  - Only using 2-3 variables
  - No array needed
  - Total: O(1) ✓ OPTIMAL

Approach 3: Naive Recursion (Not Recommended)
----------------------------------------------
Time Complexity: O(2^n)
  - Each call branches into 2 calls
  - Exponential growth
  - Very slow for large n

Space Complexity: O(n)
  - Recursion stack depth
  - Not practical for n > 30


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Base Case - Single Step
  Input: n = 1
  Output: 1
  ✓ Only one way (one 1-step)

Test Case 2: Two Steps
  Input: n = 2
  Output: 2
  ✓ Two ways (1+1 or 2)

Test Case 3: Three Steps
  Input: n = 3
  Output: 3
  ✓ Three ways (1+1+1, 1+2, 2+1)

Test Case 4: Larger Example
  Input: n = 5
  Output: 8
  ✓ Fibonacci sequence: 1,1,2,3,5,8

Test Case 5: Maximum Constraint
  Input: n = 45
  Output: 1836311903
  ✓ Handles large n efficiently


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: DP with Array
--------------------------
Store all intermediate results in array.

Pros:
  - Clear and easy to understand
  - Can access any previous result
  - Good for learning DP

Cons:
  - Uses O(n) space
  - Not space-optimal

Approach 2: Space-Optimized DP ✓ RECOMMENDED
---------------------------------------------
Only keep track of last two values.

Pros:
  - O(1) space complexity
  - Same O(n) time as array approach
  - Optimal solution

Cons:
  - Slightly less intuitive
  - Can't access arbitrary previous results

Approach 3: Matrix Exponentiation (Advanced)
---------------------------------------------
Use matrix multiplication to compute Fibonacci in O(log n).

Pros:
  - O(log n) time complexity
  - Interesting mathematical approach

Cons:
  - Complex implementation
  - Overkill for this problem
  - Not necessary given constraints


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using Naive Recursion
   ❌ Exponential time O(2^n)
   ✓ Use DP or memoization

2. Wrong Base Cases
   ❌ dp[0] = 0 or not handling n=1
   ✓ dp[0] = dp[1] = 1

3. Off-by-One Errors
   ❌ Loop range or array indexing mistakes
   ✓ Carefully handle indices

4. Not Optimizing Space
   ❌ Using full array when only need last 2 values
   ✓ Use space-optimized version for O(1) space

5. Integer Overflow (in other languages)
   ❌ Not considering overflow for large n
   ✓ Python handles big integers automatically


================================================================================
KEY TAKEAWAYS
================================================================================

1. This is a classic Fibonacci sequence problem in disguise
2. DP transforms O(2^n) recursion into O(n) solution
3. Space can be optimized from O(n) to O(1)
4. Pattern: ways(n) = ways(n-1) + ways(n-2)
5. Always consider space optimization after solving with DP
6. Memoization is alternative to bottom-up DP


================================================================================
RELATED PROBLEMS
================================================================================

- Min Cost Climbing Stairs (Easy) - Similar DP with cost
- Fibonacci Number (Easy) - Direct Fibonacci implementation
- House Robber (Medium) - Similar DP pattern
- Decode Ways (Medium) - Similar recurrence relation
- Unique Paths (Medium) - 2D version of this problem
- N-th Tribonacci Number (Easy) - Extension to 3 previous values


================================================================================
