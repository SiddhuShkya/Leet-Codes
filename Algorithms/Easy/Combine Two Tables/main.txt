================================================================================
1. HEADER
================================================================================
Problem:     Combine Two Tables
Difficulty:  Easy
Topics:      Database, SQL, Joins
Link:        https://leetcode.com/problems/combine-two-tables/

================================================================================
2. PROBLEM STATEMENT
================================================================================
Table: Person
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| personId    | int     |
| firstName   | varchar |
| lastName    | varchar |
+-------------+---------+
personId is the primary key (column with unique values) for this table.
This table contains information about the ID of some persons and their first 
and last names.

Table: Address
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| addressId   | int     |
| personId    | int     |
| city        | varchar |
| state       | varchar |
+-------------+---------+
addressId is the primary key (column with unique values) for this table.
Each row of this table contains information about the city and state of one 
person with ID = personId.

Write a solution to report the first name, last name, city, and state of each 
person in the Person table. If the address of a personId is not present in the 
Address table, report null instead.

Return the result table in any order.

Example 1:
Input: 
Person table:
+----------+-----------+----------+
| personId | firstName | lastName |
+----------+-----------+----------+
| 1        | Wang      | Allen    |
| 2        | Alice     | Bob      |
+----------+-----------+----------+
Address table:
+-----------+----------+---------------+------------+
| addressId | personId | city          | state      |
+-----------+----------+---------------+------------+
| 1         | 2        | New York City | New York   |
| 2         | 3        | Leetcode      | California |
+-----------+----------+---------------+------------+
Output: 
+-----------+----------+---------------+----------+
| firstName | lastName | city          | state    |
+-----------+----------+---------------+----------+
| Allen     | Wang     | Null          | Null     |
| Bob       | Alice    | New York City | New York |
+-----------+----------+---------------+----------+
Explanation: 
There is no address in the address table for the personId = 1 so we return 
null in their city and state.
addressId = 1 contains information about the address of personId = 2.

================================================================================
3. SOLUTION APPROACHES
================================================================================
Approach 1: Left Join (Optimal)
--------------------------------------------------------------------------------
The problem requires us to list all people from the Person table, regardless of 
whether they have an address in the Address table. This is the definition of a 
LEFT JOIN.

SQL Query:
SELECT 
    p.firstName, 
    p.lastName, 
    a.city, 
    a.state
FROM 
    Person p
LEFT JOIN 
    Address a 
ON 
    p.personId = a.personId;

Complexity Analysis:
- Time Complexity: O(N + M), where N is the number of rows in Person table and 
  M is the number of rows in Address table. The database needs to scan both 
  tables. If indexed, the join can be more efficient.
- Space Complexity: O(1) auxiliary space (excluding the result set).

Approach 2: Right Join (Alternative)
--------------------------------------------------------------------------------
We could technically use a RIGHT JOIN if we swap the tables, but it is less 
intuitive when the primary requirement is "for each person in Person table".

SQL Query:
SELECT 
    p.firstName, 
    p.lastName, 
    a.city, 
    a.state
FROM 
    Address a
RIGHT JOIN 
    Person p 
ON 
    p.personId = a.personId;

Complexity Analysis:
- Same as Approach 1.

================================================================================
4. DETAILED WALKTHROUGH
================================================================================
Let's trace the execution of the LEFT JOIN approach with the example data.

Data:
Person:
Row 1: {personId: 1, firstName: "Wang", lastName: "Allen"}
Row 2: {personId: 2, firstName: "Alice", lastName: "Bob"}

Address:
Row 1: {addressId: 1, personId: 2, city: "New York City", state: "New York"}
Row 2: {addressId: 2, personId: 3, city: "Leetcode", state: "California"}

Execution Steps:

1. FROM Person p:
   The query starts with the Person table as the left table.
   It processes rows from Person one by one.

2. Processing Person Row 1 (personId: 1):
   - Look for matching rows in Address table where Address.personId = 1.
   - Scan Address table:
     - Row 1: personId is 2. No match.
     - Row 2: personId is 3. No match.
   - Since it's a LEFT JOIN and no match is found, the columns from Address 
     (city, state) are set to NULL.
   - Result Row: "Wang", "Allen", NULL, NULL

3. Processing Person Row 2 (personId: 2):
   - Look for matching rows in Address table where Address.personId = 2.
   - Scan Address table:
     - Row 1: personId is 2. Match found!
   - Combine data from Person Row 2 and Address Row 1.
   - Result Row: "Alice", "Bob", "New York City", "New York"

4. Final Result Set:
   | firstName | lastName | city          | state    |
   |-----------|----------|---------------|----------|
   | Wang      | Allen    | NULL          | NULL     |
   | Alice     | Bob      | New York City | New York |

Note: The Address row with personId=3 is ignored because the requirement is 
driven by the Person table.

================================================================================
5. KEY INSIGHTS
================================================================================
1. Understanding Join Types:
   - INNER JOIN: Returns rows when there is a match in BOTH tables. If used 
     here, people without addresses would be excluded.
   - LEFT JOIN: Returns all rows from the left table, and the matched rows 
     from the right table. If no match, NULLs are returned for right table 
     columns. This is exactly what is needed.
   - RIGHT JOIN: Returns all rows from the right table, and the matched rows 
     from the left table.

2. Primary Keys:
   - The problem states personId is the PK of Person. This ensures each person 
     appears once in the Person table.
   - Address table also has personId, but it's a foreign key reference (though 
     not explicitly defined as FK constraint in problem description, it acts 
     as one).

3. NULL Handling:
   - SQL automatically handles the "report null instead" requirement when using 
     LEFT JOIN. No extra COALESCE or IFNULL logic is needed for this specific 
     requirement.

================================================================================
6. EDGE CASES
================================================================================
1. Empty Person Table:
   - Input: Person=[], Address=[...]
   - Output: []
   - Reason: Left table is empty, so result is empty.

2. Empty Address Table:
   - Input: Person=[{1, "A", "B"}], Address=[]
   - Output: [{"A", "B", NULL, NULL}]
   - Reason: No matches found for any person, all city/state will be NULL.

3. Person with Multiple Addresses:
   - Input: Person=[{1, "A", "B"}], Address=[{1, 1, "City1", "St1"}, {2, 1, "City2", "St2"}]
   - Output: [{"A", "B", "City1", "St1"}, {"A", "B", "City2", "St2"}]
   - Reason: LEFT JOIN replicates the left row for every match in the right table.
   - Note: The problem description implies 1:1 or 1:0 relationship usually, but 
     technically 1:N is possible if not constrained.

4. Address exists but Person does not:
   - Input: Person=[{1, "A", "B"}], Address=[{99, 99, "City", "State"}]
   - Output: [{"A", "B", NULL, NULL}]
   - Reason: The address for personId 99 is ignored.

5. All Persons have Addresses:
   - Input: Standard 1:1 match for all.
   - Output: No NULLs in result.

================================================================================
7. OPTIMIZATION NOTES
================================================================================
1. Indexing:
   - Ensure `personId` is indexed in both tables.
   - `Person.personId` is a Primary Key, so it's clustered indexed by default 
     in most DBs (MySQL InnoDB).
   - `Address.personId` should have an index to speed up the lookup during the 
     JOIN operation. Without an index, the DB engine might perform a full table 
     scan on Address for every Person row (Nested Loop Join) or use a Hash Join.

2. Projection:
   - Only select the required columns (`firstName`, `lastName`, `city`, `state`) 
     to minimize data transfer and memory usage.

3. Database Engine:
   - For massive datasets, the choice of join algorithm (Nested Loop, Hash Join, 
     Merge Join) matters, but this is usually handled by the Query Optimizer.

================================================================================
8. RELATED PROBLEMS
================================================================================
1. Employees Earning More Than Their Managers (Easy)
   - Involves self-joins or joins to compare values.

2. Duplicate Emails (Easy)
   - Involves grouping and filtering.

3. Customers Who Never Order (Easy)
   - Involves finding records in one table not present in another (LEFT JOIN ... 
     WHERE NULL or NOT IN).

4. Delete Duplicate Emails (Easy)
   - Involves self-joins and deletion logic.

5. Second Highest Salary (Medium)
   - Involves subqueries and limit/offset logic.