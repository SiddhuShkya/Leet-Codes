================================================================================
CONVERT BINARY NUMBER IN A LINKED LIST TO INTEGER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given head which is a reference node to a singly-linked list. The value of each 
node in the linked list is either 0 or 1. The linked list holds the binary 
representation of a number.

Return the decimal value of the number in the linked list.

The most significant bit is at the head of the linked list.

EXAMPLES:
---------
Example 1:
  Input: head = [1,0,1]
  Output: 5
  Explanation: (101) in base 2 = (1 * 2^2) + (0 * 2^1) + (1 * 2^0) = 5

Example 2:
  Input: head = [0]
  Output: 0

CONSTRAINTS:
------------
- The Linked List is not empty.
- Number of nodes will not exceed 30.
- Each node's value is either 0 or 1.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Converting binary to decimal
2. Handling linked list traversal
3. Avoiding string conversion (for efficiency)
4. Handling large numbers (though constraint says <= 30 bits, fits in integer)

ALGORITHM STEPS:
----------------
Approach 1: String Conversion (Naive)
1. Traverse list, append values to a string.
2. Convert binary string to integer using `int(s, 2)` or manual loop.

Approach 2: Bit Manipulation (Streaming) ✓ OPTIMAL
1. Initialize `result = 0`.
2. Traverse the linked list.
3. For each node:
   - Shift `result` left by 1 (multiply by 2).
   - Add current node's value (0 or 1).
   - `result = (result << 1) | node.val` OR `result = result * 2 + node.val`
4. Return `result`.


DETAILED EXPLANATION:
---------------------

Bit Manipulation Logic:
-----------------------
Binary: 1 -> 0 -> 1

1. Start: result = 0
2. Node 1:
   - result = result * 2 + 1
   - result = 0 * 2 + 1 = 1
   - (Binary: 1)

3. Node 0:
   - result = result * 2 + 0
   - result = 1 * 2 + 0 = 2
   - (Binary: 10)

4. Node 1:
   - result = result * 2 + 1
   - result = 2 * 2 + 1 = 5
   - (Binary: 101)

Result: 5

Why this works?
---------------
Each step to the left in binary increases the value by a power of 2.
Traversing from MSB (Most Significant Bit) to LSB (Least Significant Bit) 
is equivalent to shifting the current value left and adding the new bit.
This is Horner's method for polynomial evaluation.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Bit Manipulation (Optimal) ✓ RECOMMENDED
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        res = 0
        while head:
            # Shift left and add current bit
            res = (res << 1) | head.val
            # Or: res = res * 2 + head.val
            head = head.next
        return res


# Approach 2: String Conversion (Less Efficient)
class SolutionString:
    def getDecimalValue(self, head: ListNode) -> int:
        binary_str = ""
        while head:
            binary_str += str(head.val)
            head = head.next
        return int(binary_str, 2)


# Approach 3: Stack (Reverse Order)
# Not recommended as it requires O(N) space
class SolutionStack:
    def getDecimalValue(self, head: ListNode) -> int:
        stack = []
        while head:
            stack.append(head.val)
            head = head.next
        
        res = 0
        power = 0
        while stack:
            bit = stack.pop()
            if bit == 1:
                res += 2 ** power
            power += 1
        return res


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Bit Manipulation
----------------------------
Time Complexity: O(n)
  - Traverse list once.
  - Bitwise operations are O(1).

Space Complexity: O(1)
  - Only integer variable used.

Approach 2: String Conversion
-----------------------------
Time Complexity: O(n)
  - String building takes O(n).
  - Conversion takes O(n).

Space Complexity: O(n)
  - Store binary string.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: [1,0,1]
  Output: 5
  ✓ 4 + 0 + 1 = 5

Test Case 2: Zero
  Input: [0]
  Output: 0
  ✓ 0

Test Case 3: All Ones
  Input: [1,1,1]
  Output: 7
  ✓ 4 + 2 + 1 = 7

Test Case 4: Leading Zeros
  Input: [0,0,1]
  Output: 1
  ✓ 0 + 0 + 1 = 1

Test Case 5: Large Number
  Input: [1,0,0,0,0,0,0,0,0,0,0] (1 followed by 10 zeros)
  Output: 1024
  ✓ 2^10 = 1024


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Bit Manipulation ✓ RECOMMENDED
------------------------------------------
Pros:
  - O(1) space.
  - Very fast.
  - Single pass.

Cons:
  - None.

Approach 2: String/Stack
------------------------
Pros:
  - Intuitive if thinking LSB first.

Cons:
  - O(n) space.
  - Slower.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Reversing the List
   ❌ Reversing to process LSB first
   ✓ Not needed, can process MSB first using shift/multiply

2. String Concatenation
   ❌ Using string building in loop
   ✓ Use integer arithmetic for O(1) space

3. Power Calculation
   ❌ Using pow() or ** inside loop
   ✓ Use bit shift (<< 1) or multiply by 2


================================================================================
KEY TAKEAWAYS
================================================================================

1. Binary to Decimal from MSB: `val = val * 2 + bit`.
2. Bitwise `<< 1` is equivalent to `* 2`.
3. Bitwise `| bit` is equivalent to `+ bit` (when bit is 0 or 1).
4. Time O(n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Reverse Bits (Easy)
- Number of 1 Bits (Easy)
- Add Binary (Easy)
- Middle of the Linked List (Easy)


================================================================================
