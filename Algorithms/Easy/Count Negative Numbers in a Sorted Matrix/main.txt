================================================================================
COUNT NEGATIVE NUMBERS IN A SORTED MATRIX - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given a m x n matrix grid which is sorted in non-increasing order both row-wise 
and column-wise, return the number of negative numbers in grid.

EXAMPLES:
---------
Example 1:
  Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
  Output: 8
  Explanation: There are 8 negatives number in the matrix.

Example 2:
  Input: grid = [[3,2],[1,0]]
  Output: 0

CONSTRAINTS:
------------
- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 100
- -100 <= grid[i][j] <= 100

Follow up: Could you find an O(n + m) solution?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Utilizing the sorted property (non-increasing)
2. Optimizing better than O(m*n)
3. Handling edge cases (all positive/negative)

ALGORITHM STEPS:
----------------
Approach 1: Brute Force (O(m*n))
1. Iterate through every cell.
2. If negative, increment count.

Approach 2: Binary Search per Row (O(m log n))
1. For each row, binary search for the first negative number.
2. All numbers after it are also negative.

Approach 3: Staircase / Saddleback Search (O(m + n)) ✓ OPTIMAL
1. Start from bottom-left corner (row = m-1, col = 0) OR top-right.
   Let's use Bottom-Left (m-1, 0).
   Wait, grid is non-increasing (4, 3, 2, -1).
   So values decrease as we go right and down.
   
   Let's start Top-Right (0, n-1)?
   - If grid[0][n-1] < 0: entire column n-1 is negative? No, column is also non-increasing.
     If top is negative, everything below is smaller (more negative).
     So yes, if grid[r][c] < 0, then grid[r+1...][c] are all < 0.
   
   Correct Logic (Staircase from Bottom-Left):
   Start at row = m-1, col = 0.
   - If grid[row][col] < 0:
     - This number is negative.
     - Since row is sorted non-increasing (decreasing), everything to the RIGHT is also negative.
     - Count += (n - col).
     - Move UP (row--) to check previous row.
   - If grid[row][col] >= 0:
     - This number is positive.
     - Since column is sorted non-increasing, everything ABOVE is also positive.
     - We need to find negative, so move RIGHT (col++) to find smaller numbers.

DETAILED EXPLANATION:
---------------------

Grid:
[ 4,  3,  2, -1]
[ 3,  2,  1, -1]
[ 1,  1, -1, -2]
[-1, -1, -2, -3]

Start Bottom-Left (3, 0): val = -1
- -1 < 0.
- All to right are negative (indices 0,1,2,3 -> 4 items).
- Count += 4. Total = 4.
- Move Up to (2, 0).

Pos (2, 0): val = 1
- 1 >= 0.
- Move Right to (2, 1).

Pos (2, 1): val = 1
- 1 >= 0.
- Move Right to (2, 2).

Pos (2, 2): val = -1
- -1 < 0.
- All to right are negative (indices 2,3 -> 2 items).
- Count += 2. Total = 6.
- Move Up to (1, 2).

Pos (1, 2): val = 1
- 1 >= 0.
- Move Right to (1, 3).

Pos (1, 3): val = -1
- -1 < 0.
- All to right are negative (index 3 -> 1 item).
- Count += 1. Total = 7.
- Move Up to (0, 3).

Pos (0, 3): val = -1
- -1 < 0.
- All to right are negative (index 3 -> 1 item).
- Count += 1. Total = 8.
- Move Up to (-1, 3). Stop.

Result: 8.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Brute Force (Simple)
class SolutionBrute:
    def countNegatives(self, grid: List[List[int]]) -> int:
        count = 0
        for row in grid:
            for val in row:
                if val < 0:
                    count += 1
        return count


# Approach 2: Staircase (Optimal) ✓ RECOMMENDED
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        row, col = m - 1, 0
        count = 0
        
        while row >= 0 and col < n:
            if grid[row][col] < 0:
                # Found a negative in this row
                # All elements to the right are also negative (decreasing order)
                count += (n - col)
                # Since this row starts being negative here, check row above
                # (Row above might have negatives starting later)
                row -= 1
            else:
                # Positive, need smaller numbers, go right
                col += 1
                
        return count


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Brute Force
-----------------------
Time Complexity: O(m*n)
  - Visit every cell.

Approach 2: Staircase
---------------------
Time Complexity: O(m + n)
  - We start at bottom-left and move only Up or Right.
  - Max m moves up, max n moves right.
  - Total steps <= m + n.

Space Complexity: O(1)
  - Only pointers used.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
  Output: 8
  ✓ Correct

Test Case 2: All Positive
  Input: [[3,2],[1,0]]
  Output: 0
  ✓ Correct

Test Case 3: All Negative
  Input: [[-1,-2],[-2,-3]]
  Output: 4
  ✓ Correct

Test Case 4: Single Element
  Input: [[-1]]
  Output: 1
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Binary Search per Row
---------------------------------
Pros:
  - Faster than brute force if m << n.
  - O(m log n).

Cons:
  - Slower than O(m+n) generally.

Approach 2: Staircase ✓ RECOMMENDED
-----------------------------------
Pros:
  - Optimal O(m+n).
  - Elegant.

Cons:
  - Logic requires careful tracing of sorted direction.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Wrong Direction
   ❌ Assuming increasing order
   ✓ Problem says NON-INCREASING (decreasing)

2. Index Out of Bounds
   ❌ Not checking row >= 0 and col < n
   ✓ While loop condition

3. Counting Logic
   ❌ Count += 1
   ✓ Count += (n - col) (count all remaining in row)


================================================================================
KEY TAKEAWAYS
================================================================================

1. Sorted Matrix properties allow O(m+n) search.
2. Start from a corner where moving one way eliminates a row/col.
3. Bottom-Left or Top-Right are usually the starting points for staircase search.
4. Time O(m+n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Search a 2D Matrix (Medium)
- Search a 2D Matrix II (Medium)
- Kth Smallest Element in a Sorted Matrix (Medium)


================================================================================
