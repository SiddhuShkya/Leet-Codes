================================================================================
HAPPY NUMBER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:
- Starting with any positive integer, replace the number by the sum of the 
  squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it 
  loops endlessly in a cycle which does not include 1.
- Those numbers for which this process ends in 1 are happy.

Return true if n is a happy number, and false if not.

EXAMPLES:
---------
Example 1:
  Input: n = 19
  Output: true
  Explanation:
    1² + 9² = 82
    8² + 2² = 68
    6² + 8² = 100
    1² + 0² + 0² = 1

Example 2:
  Input: n = 2
  Output: false

CONSTRAINTS:
------------
- 1 <= n <= 2^31 - 1


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Detecting infinite loops (cycles)
2. Calculating sum of squares of digits
3. Knowing when to stop
4. Avoiding infinite iteration

ALGORITHM STEPS:
----------------
Approach 1: Hash Set to Detect Cycles
1. Create set to store seen numbers
2. While n != 1:
   a. Calculate sum of squares of digits
   b. If sum is 1, return true
   c. If sum was seen before, return false (cycle detected)
   d. Add sum to seen set
   e. Update n = sum
3. Return true if loop exits (n == 1)

Approach 2: Floyd's Cycle Detection (Two Pointers)
1. Use slow and fast pointers
2. Slow moves one step, fast moves two steps
3. If they meet and it's not 1, there's a cycle
4. If we reach 1, it's happy


DETAILED EXPLANATION:
---------------------

Why Cycles Occur:
-----------------
Not all numbers lead to 1. Some enter infinite cycles.

Example: n = 2
  2² = 4
  4² = 16
  1² + 6² = 37
  3² + 7² = 58
  5² + 8² = 89
  8² + 9² = 145
  1² + 4² + 5² = 42
  4² + 2² = 20
  2² + 0² = 4  ← Back to 4! Cycle detected

Sum of Squares Calculation:
----------------------------
For n = 19:
  - Extract digits: 1, 9
  - Square each: 1² = 1, 9² = 81
  - Sum: 1 + 81 = 82

For n = 82:
  - Extract digits: 8, 2
  - Square each: 8² = 64, 2² = 4
  - Sum: 64 + 4 = 68

Hash Set Approach Walkthrough (n = 19):
----------------------------------------
seen = {}
n = 19

Iteration 1:
  sum = 1² + 9² = 82
  82 not in seen, add to seen
  n = 82

Iteration 2:
  sum = 8² + 2² = 68
  68 not in seen, add to seen
  n = 68

Iteration 3:
  sum = 6² + 8² = 100
  100 not in seen, add to seen
  n = 100

Iteration 4:
  sum = 1² + 0² + 0² = 1
  sum == 1, return true!


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Hash Set ✓ RECOMMENDED
class Solution(object):
    def isHappy(self, n):
        seen_numbers = set()
        
        while n != 1:
            # Calculate sum of squares of digits
            total = 0
            while n > 0:
                digit = n % 10
                total += digit ** 2
                n = n // 10
            
            # Check if we've seen this sum before (cycle)
            if total in seen_numbers:
                return False
            
            seen_numbers.add(total)
            n = total
        
        return True


# Helper function for sum of squares
def get_sum_of_squares(n):
    total = 0
    while n > 0:
        digit = n % 10
        total += digit ** 2
        n = n // 10
    return total


# Cleaner version using helper
def isHappy_v2(n):
    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_sum_of_squares(n)
    return n == 1


# Approach 2: Floyd's Cycle Detection
def isHappy_floyd(n):
    def get_next(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit ** 2
            num = num // 10
        return total
    
    slow = n
    fast = get_next(n)
    
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    
    return fast == 1


# Using string conversion (alternative)
def isHappy_string(n):
    seen = set()
    while n != 1:
        n = sum(int(digit) ** 2 for digit in str(n))
        if n in seen:
            return False
        seen.add(n)
    return True


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Hash Set
---------------------
Time Complexity: O(log n)
  - Each iteration reduces number significantly
  - Number of digits in n: O(log n)
  - Sum of squares operation: O(log n)
  - Cycle detection happens quickly
  - Total: O(log n)

Space Complexity: O(log n)
  - Set stores seen numbers
  - Maximum numbers in cycle is bounded
  - Total: O(log n)

Approach 2: Floyd's Cycle Detection
------------------------------------
Time Complexity: O(log n)
  - Same as hash set approach
  - Total: O(log n)

Space Complexity: O(1)
  - Only using two pointers
  - No set needed
  - Total: O(1) ✓ MORE OPTIMAL


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Happy Number
  Input: n = 19
  Output: true
  ✓ Reaches 1 through: 19→82→68→100→1

Test Case 2: Not Happy
  Input: n = 2
  Output: false
  ✓ Enters cycle, never reaches 1

Test Case 3: Already 1
  Input: n = 1
  Output: true
  ✓ Already happy

Test Case 4: Single Digit Happy
  Input: n = 7
  Output: true
  ✓ 7→49→97→130→10→1

Test Case 5: Large Number
  Input: n = 100
  Output: true
  ✓ 100→1→1


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Hash Set ✓ RECOMMENDED FOR CLARITY
-----------------------------------------------
Track seen numbers to detect cycles.

Pros:
  - Easy to understand
  - Clear cycle detection
  - O(log n) time and space

Cons:
  - Uses O(log n) extra space

Approach 2: Floyd's Cycle Detection
------------------------------------
Use slow/fast pointers like linked list cycle.

Pros:
  - O(1) space complexity
  - No extra data structure
  - Elegant solution

Cons:
  - Less intuitive
  - Harder to understand
  - Same time complexity as hash set

Approach 3: Hardcoded Cycle Detection
--------------------------------------
There are only a few known cycles for unhappy numbers.

Pros:
  - Can optimize by checking known cycles

Cons:
  - Not general solution
  - Requires memorization
  - Not recommended for interviews


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Infinite Loop Without Cycle Detection
   ❌ Not tracking seen numbers
   ✓ Use set or Floyd's algorithm

2. Incorrect Sum Calculation
   ❌ Not squaring digits properly
   ✓ Use digit² not digit

3. Not Handling Single Digit
   ❌ Special casing n = 1
   ✓ Algorithm handles it naturally

4. Integer Overflow
   ❌ In other languages, sum might overflow
   ✓ Python handles big integers automatically

5. Wrong Loop Condition
   ❌ while n > 0 (would never terminate)
   ✓ while n != 1 and not in cycle


================================================================================
KEY TAKEAWAYS
================================================================================

1. Cycle detection is key to solving this problem
2. Hash set provides simple cycle detection
3. Floyd's algorithm offers O(1) space solution
4. Sum of squares reduces number size quickly
5. Not all numbers are happy - some cycle forever
6. Problem demonstrates cycle detection techniques


================================================================================
RELATED PROBLEMS
================================================================================

- Linked List Cycle (Easy) - Floyd's cycle detection
- Linked List Cycle II (Medium) - Finding cycle start
- Add Digits (Easy) - Similar digit manipulation
- Ugly Number (Easy) - Number property checking
- Perfect Squares (Medium) - Sum of squares
- Sum of Square Numbers (Medium) - Square sum problems


================================================================================
