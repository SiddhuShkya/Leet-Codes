================================================================================
MOVE ZEROES - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums, move all 0's to the end of it while maintaining 
the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

EXAMPLES:
---------
Example 1:
  Input: nums = [0,1,0,3,12]
  Output: [1,3,12,0,0]

Example 2:
  Input: nums = [0]
  Output: [0]

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^4
- -2^31 <= nums[i] <= 2^31 - 1

Follow-up: Could you minimize the total number of operations done?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Moving elements in-place (no extra array)
2. Maintaining relative order of non-zero elements
3. Minimizing number of operations
4. Handling all zeros or no zeros

ALGORITHM STEPS:
----------------
Approach 1: Two Pointers (Optimal)
1. Use pointer `left` to track position for next non-zero
2. Iterate through array with pointer `right`
3. When nums[right] is non-zero:
   - Swap nums[left] with nums[right]
   - Increment left
4. All zeros naturally move to end

Approach 2: Shift and Fill
1. Count non-zero elements and shift them to front
2. Fill remaining positions with zeros

Approach 3: Bubble Sort Style (From original - not optimal)
1. Count zeros
2. Bubble each zero to the end
3. Repeat for all zeros


DETAILED EXPLANATION:
---------------------

Two Pointers Approach:
----------------------
The key insight is to use two pointers:
- `left`: position where next non-zero should go
- `right`: current element being examined

When we find a non-zero, we swap it with position `left`.
This maintains order because we only move non-zeros forward.

Example Walkthrough: nums = [0,1,0,3,12]
-----------------------------------------
Initial: left=0, right=0
  nums = [0,1,0,3,12]

right=0: nums[0]=0 (zero, skip)
  left=0, right=1

right=1: nums[1]=1 (non-zero!)
  Swap nums[0] and nums[1]
  nums = [1,0,0,3,12]
  left=1, right=2

right=2: nums[2]=0 (zero, skip)
  left=1, right=3

right=3: nums[3]=3 (non-zero!)
  Swap nums[1] and nums[3]
  nums = [1,3,0,0,12]
  left=2, right=4

right=4: nums[4]=12 (non-zero!)
  Swap nums[2] and nums[4]
  nums = [1,3,12,0,0]
  left=3, right=5

Done! Result: [1,3,12,0,0]

Why It Works:
-------------
- All non-zeros are moved to front in order
- Zeros are automatically pushed to back
- Each element moved at most once
- In-place with O(1) extra space


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Two Pointers ✓ OPTIMAL
class Solution(object):
    def moveZeroes(self, nums):
        left = 0  # Position for next non-zero
        
        # Move all non-zeros to front
        for right in range(len(nums)):
            if nums[right] != 0:
                # Swap non-zero with position left
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
        
        return nums


# Alternative: Without swapping when left == right
def moveZeroes_optimized(nums):
    left = 0
    for right in range(len(nums)):
        if nums[right] != 0:
            if left != right:  # Only swap if different positions
                nums[left], nums[right] = nums[right], nums[left]
            left += 1


# Approach 2: Shift and Fill
def moveZeroes_shift(nums):
    # Shift all non-zeros to front
    left = 0
    for right in range(len(nums)):
        if nums[right] != 0:
            nums[left] = nums[right]
            left += 1
    
    # Fill remaining with zeros
    for i in range(left, len(nums)):
        nums[i] = 0


# Approach 3: Bubble Sort Style (From original - not optimal)
def moveZeroes_bubble(nums):
    count = 0
    # Count zeros
    for num in nums:
        if num == 0:
            count += 1
    
    # Bubble each zero to end
    i = 0
    while i < count:
        for j in range(1, len(nums) - i):
            if nums[j - 1] == 0:
                # Swap
                temp = nums[j - 1]
                nums[j - 1] = nums[j]
                nums[j] = temp
        i += 1
    
    return nums


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Two Pointers
-------------------------
Time Complexity: O(n)
  - Single pass through array
  - Each element examined once
  - Swap is O(1)
  - Total: O(n)

Space Complexity: O(1)
  - Only using two pointer variables
  - In-place modification
  - Total: O(1) ✓ OPTIMAL

Approach 2: Shift and Fill
---------------------------
Time Complexity: O(n)
  - First loop: O(n)
  - Second loop: O(n)
  - Total: O(n)

Space Complexity: O(1)
  - In-place modification
  - Total: O(1)

Approach 3: Bubble Sort Style
------------------------------
Time Complexity: O(n²)
  - Outer loop: O(k) where k = number of zeros
  - Inner loop: O(n)
  - Total: O(k × n) = O(n²) worst case

Space Complexity: O(1)
  - In-place modification
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Mixed Zeros
  Input: nums = [0,1,0,3,12]
  Output: [1,3,12,0,0]
  ✓ Zeros moved to end, order preserved

Test Case 2: Single Zero
  Input: nums = [0]
  Output: [0]
  ✓ Single element unchanged

Test Case 3: No Zeros
  Input: nums = [1,2,3]
  Output: [1,2,3]
  ✓ No changes needed

Test Case 4: All Zeros
  Input: nums = [0,0,0]
  Output: [0,0,0]
  ✓ All zeros remain

Test Case 5: Zeros at End
  Input: nums = [1,2,0,0]
  Output: [1,2,0,0]
  ✓ Already in correct position

Test Case 6: Zeros at Start
  Input: nums = [0,0,1,2]
  Output: [1,2,0,0]
  ✓ Moved from start to end


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Two Pointers ✓ RECOMMENDED
---------------------------------------
Use two pointers to swap non-zeros forward.

Pros:
  - O(n) time, O(1) space
  - Minimal operations
  - Clean and elegant
  - Single pass

Cons:
  - Requires understanding of two pointers

Approach 2: Shift and Fill
---------------------------
Shift non-zeros, then fill zeros.

Pros:
  - Easy to understand
  - O(n) time, O(1) space
  - Two clear steps

Cons:
  - Two passes through array
  - More writes than approach 1

Approach 3: Bubble Sort Style
------------------------------
Bubble each zero to end.

Pros:
  - Intuitive for beginners

Cons:
  - O(n²) time complexity
  - Very inefficient
  - Not acceptable for interviews


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Creating New Array
   ❌ Using extra array for result
   ✓ Modify in-place

2. Not Maintaining Order
   ❌ Sorting or rearranging non-zeros
   ✓ Preserve relative order

3. Inefficient Bubble Approach
   ❌ O(n²) nested loops
   ✓ Use O(n) two-pointer approach

4. Unnecessary Swaps
   ❌ Swapping when left == right
   ✓ Check if positions differ

5. Forgetting Edge Cases
   ❌ Not testing all zeros or no zeros
   ✓ Handle all edge cases


================================================================================
KEY TAKEAWAYS
================================================================================

1. Two pointers provide optimal O(n) solution
2. Swapping non-zeros forward naturally moves zeros back
3. In-place modification requires careful pointer management
4. Relative order must be preserved
5. Single pass is possible with right approach
6. Avoid O(n²) bubble sort style solutions


================================================================================
RELATED PROBLEMS
================================================================================

- Remove Element (Easy) - Similar in-place removal
- Remove Duplicates from Sorted Array (Easy) - Two pointer technique
- Sort Colors (Medium) - In-place sorting with constraints
- Move Zeroes II (variations) - Extended versions
- Partition Array (Medium) - Similar partitioning
- Dutch National Flag (Medium) - Three-way partitioning


================================================================================
