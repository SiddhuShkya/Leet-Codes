================================================================================
PALINDROME LINKED LIST - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the head of a singly linked list, return true if it is a palindrome or 
false otherwise.

EXAMPLES:
---------
Example 1:
  Input: head = [1,2,2,1]
  Output: true

Example 2:
  Input: head = [1,2]
  Output: false

CONSTRAINTS:
------------
- The number of nodes in the list is in the range [1, 10^5]
- 0 <= Node.val <= 9

Follow-up: Could you do it in O(n) time and O(1) space?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Checking palindrome in linked list
2. Achieving O(1) space (follow-up)
3. Cannot access elements by index
4. Reversing or comparing efficiently

ALGORITHM STEPS:
----------------
Approach 1: Convert to Array
1. Traverse list and store values in array
2. Check if array is palindrome using two pointers

Approach 2: Reverse Second Half (Optimal)
1. Find middle using slow/fast pointers
2. Reverse second half of list
3. Compare first half with reversed second half
4. (Optional) Restore list

Approach 3: String Conversion (From original)
1. Build string from list values
2. Compare string with its reverse


DETAILED EXPLANATION:
---------------------

Array Approach:
---------------
Simple but uses O(n) space.

Example: [1,2,2,1]
  - Convert to array: [1,2,2,1]
  - Check: arr[0]==arr[3], arr[1]==arr[2]
  - Result: true

Reverse Second Half Approach:
------------------------------
Optimal O(1) space solution.

Example: [1,2,2,1]

Step 1: Find middle
  - Use slow/fast pointers
  - slow moves 1 step, fast moves 2 steps
  - When fast reaches end, slow is at middle
  
  1 → 2 → 2 → 1
      ↑
    slow (after middle)

Step 2: Reverse second half
  - Reverse from slow to end
  - 1 → 2    2 ← 1
  
Step 3: Compare
  - Compare first half with reversed second half
  - 1==1 ✓, 2==2 ✓
  - Result: true

Walkthrough: [1,2,3,2,1]
--------------------------
Find middle:
  slow at 3 (middle)

Reverse second half:
  1 → 2 → 3    2 ← 1
  
Compare:
  1==1 ✓, 2==2 ✓
  (3 is middle, can be ignored for odd length)
  Result: true


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Convert to Array
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        vals = []
        while head:
            vals.append(head.val)
            head = head.next
        
        return vals == vals[::-1]


# From original code (String conversion)
def isPalindrome_string(head):
    res = ""
    while head:
        res += str(head.val)
        head = head.next
    if res == res[::-1]:
        return True
    return False


# Approach 2: Reverse Second Half ✓ OPTIMAL
def isPalindrome_optimal(head):
    if not head or not head.next:
        return True
    
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    prev = None
    while slow:
        next_node = slow.next
        slow.next = prev
        prev = slow
        slow = next_node
    
    # Compare first and second half
    left, right = head, prev
    while right:  # right is shorter or equal
        if left.val != right.val:
            return False
        left = left.next
        right = right.next
    
    return True


# With list restoration
def isPalindrome_restore(head):
    if not head or not head.next:
        return True
    
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    prev = None
    curr = slow
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    
    # Compare
    left, right = head, prev
    is_palindrome = True
    while right:
        if left.val != right.val:
            is_palindrome = False
        left = left.next
        right = right.next
    
    # Restore list (reverse second half again)
    prev = None
    curr = prev  # prev is head of reversed second half
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    
    return is_palindrome


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Convert to Array
-----------------------------
Time Complexity: O(n)
  - Traverse list once: O(n)
  - Compare array: O(n)
  - Total: O(n)

Space Complexity: O(n)
  - Array stores all values
  - Total: O(n)

Approach 2: Reverse Second Half
--------------------------------
Time Complexity: O(n)
  - Find middle: O(n/2)
  - Reverse second half: O(n/2)
  - Compare: O(n/2)
  - Total: O(n)

Space Complexity: O(1)
  - Only using pointers
  - Total: O(1) ✓ MEETS FOLLOW-UP


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Even Length Palindrome
  Input: head = [1,2,2,1]
  Output: true
  ✓ Symmetric

Test Case 2: Not Palindrome
  Input: head = [1,2]
  Output: false
  ✓ Different values

Test Case 3: Odd Length Palindrome
  Input: head = [1,2,1]
  Output: true
  ✓ Middle element doesn't affect

Test Case 4: Single Node
  Input: head = [1]
  Output: true
  ✓ Single node is palindrome

Test Case 5: All Same
  Input: head = [1,1,1,1]
  Output: true
  ✓ All identical values


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Convert to Array
-----------------------------
Store values and compare.

Pros:
  - Simple and intuitive
  - Easy to implement
  - O(n) time

Cons:
  - O(n) space - violates follow-up
  - Not optimal

Approach 2: Reverse Second Half ✓ RECOMMENDED
----------------------------------------------
Find middle, reverse, compare.

Pros:
  - O(n) time, O(1) space
  - Meets follow-up requirement
  - Optimal solution

Cons:
  - More complex
  - Modifies list (can be restored)

Approach 3: String Conversion
------------------------------
Build string and compare.

Pros:
  - Very simple

Cons:
  - O(n) space
  - String operations overhead
  - Not optimal


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Finding Middle Correctly
   ❌ Wrong slow/fast pointer logic
   ✓ fast moves 2x, slow moves 1x

2. Not Reversing Properly
   ❌ Losing reference to nodes
   ✓ Use prev, curr, next pointers

3. Wrong Comparison Length
   ❌ Comparing wrong number of nodes
   ✓ Compare until shorter half ends

4. Not Handling Odd Length
   ❌ Including middle in both halves
   ✓ Middle doesn't need comparison

5. Modifying Original List
   ❌ Not restoring if required
   ✓ Reverse again to restore


================================================================================
KEY TAKEAWAYS
================================================================================

1. Slow/fast pointers find middle in one pass
2. Reversing second half enables O(1) space
3. Compare first half with reversed second half
4. Odd length: middle node can be ignored
5. Can restore list after checking
6. Time O(n), Space O(1) is optimal


================================================================================
RELATED PROBLEMS
================================================================================

- Reverse Linked List (Easy) - List reversal
- Linked List Cycle (Easy) - Slow/fast pointers
- Valid Palindrome (Easy) - String palindrome
- Palindrome Number (Easy) - Number palindrome
- Reorder List (Medium) - Similar middle finding
- Remove Nth Node From End (Medium) - Two pointer technique


================================================================================
