================================================================================
PALINDROME NUMBER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer x, return true if x is a palindrome, and false otherwise.

An integer is a palindrome when it reads the same backward as forward.

EXAMPLES:
---------
Example 1:
  Input: x = 121
  Output: true
  Explanation: 121 reads as 121 from left to right and from right to left.

Example 2:
  Input: x = -121
  Output: false
  Explanation: From left to right, it reads -121. From right to left, it 
  becomes 121-. Therefore it is not a palindrome.

Example 3:
  Input: x = 10
  Output: false
  Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

CONSTRAINTS:
------------
- -2^31 <= x <= 2^31 - 1


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Handling negative numbers (always false)
2. Handling numbers ending in 0 (false except for 0 itself)
3. Choosing between string conversion vs mathematical approach
4. Avoiding integer overflow

ALGORITHM STEPS:
----------------
Approach 1: String Conversion (Simpler)
1. Convert number to string
2. Reverse the string
3. Compare original string with reversed string
4. Return true if equal, false otherwise

Approach 2: Mathematical (No Extra Space)
1. Return false if x < 0 or (x % 10 == 0 and x != 0)
2. Reverse half of the number
3. Compare first half with reversed second half


DETAILED EXPLANATION:
---------------------

Why Negative Numbers Are Never Palindromes:
--------------------------------------------
Negative numbers have a '-' sign at the beginning. When reversed, the '-' 
would be at the end (e.g., -121 becomes 121-), which is not a valid number.
Therefore, all negative numbers return false.

Why Numbers Ending in 0 Are Not Palindromes (except 0):
--------------------------------------------------------
If a number ends in 0, its reverse would start with 0. The only number that
starts with 0 is 0 itself. So any number ending in 0 (except 0) is not a 
palindrome.

String Conversion Approach:
---------------------------
Example with x = 121:
  - Convert to string: "121"
  - Reverse string: "121"
  - Compare: "121" == "121" → true

Example with x = 123:
  - Convert to string: "123"
  - Reverse string: "321"
  - Compare: "123" != "321" → false

Mathematical Approach (Reverse Half):
--------------------------------------
Instead of reversing the entire number, we can reverse only half and compare.

Example with x = 1221:
  - Start: x = 1221, reversed = 0
  - Iteration 1: reversed = 0*10 + 1221%10 = 1, x = 122
  - Iteration 2: reversed = 1*10 + 122%10 = 12, x = 12
  - Stop when x <= reversed
  - Compare: x (12) == reversed (12) → true

Example with x = 12321:
  - Reverse until: x = 12, reversed = 123
  - For odd length, middle digit doesn't matter
  - Compare: x (12) == reversed/10 (12) → true


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: String Conversion - Simple and Readable
def isPalindrome(x):
    strX = str(x)
    if str(x) == strX[::-1]:
        return True
    else:
        return False

# More concise version
def isPalindrome_v2(x):
    return str(x) == str(x)[::-1]


# Approach 2: Mathematical - No Extra Space
def isPalindrome_math(x):
    # Negative numbers and numbers ending in 0 (except 0) are not palindromes
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    
    reversed_half = 0
    while x > reversed_half:
        reversed_half = reversed_half * 10 + x % 10
        x //= 10
    
    # For even length: x == reversed_half
    # For odd length: x == reversed_half // 10 (ignore middle digit)
    return x == reversed_half or x == reversed_half // 10


# LeetCode Solution Class Format
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # String approach
        return str(x) == str(x)[::-1]


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: String Conversion
------------------------------
Time Complexity: O(n)
  - Converting to string: O(n) where n is number of digits
  - Reversing string: O(n)
  - Comparison: O(n)
  - Total: O(n)

Space Complexity: O(n)
  - String storage: O(n) for original string
  - Reversed string: O(n)
  - Total: O(n)

Approach 2: Mathematical
-------------------------
Time Complexity: O(log₁₀(x))
  - We process half the digits
  - Number of digits = log₁₀(x)
  - Total: O(log₁₀(x))

Space Complexity: O(1)
  - Only using a few variables
  - No additional data structures


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Positive Palindrome
  Input: x = 121
  Output: true
  ✓ Reads same forwards and backwards

Test Case 2: Negative Number
  Input: x = -121
  Output: false
  ✓ Negative numbers are never palindromes

Test Case 3: Number Ending in 0
  Input: x = 10
  Output: false
  ✓ Numbers ending in 0 (except 0) are not palindromes

Test Case 4: Single Digit
  Input: x = 7
  Output: true
  ✓ All single digits are palindromes

Test Case 5: Even Length Palindrome
  Input: x = 1221
  Output: true
  ✓ Even length palindrome

Test Case 6: Odd Length Palindrome
  Input: x = 12321
  Output: true
  ✓ Odd length palindrome

Test Case 7: Zero
  Input: x = 0
  Output: true
  ✓ Zero is a palindrome


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: String Conversion ✓ RECOMMENDED FOR SIMPLICITY
-----------------------------------------------------------
Convert to string and compare with reverse.

Pros:
  - Very simple and readable
  - Easy to understand and implement
  - Less prone to bugs

Cons:
  - Uses O(n) extra space
  - String operations have overhead
  - Not following "without converting to string" constraint if given

Approach 2: Mathematical (Reverse Entire Number)
-------------------------------------------------
Reverse the entire number and compare with original.

Pros:
  - No string conversion
  - Straightforward logic

Cons:
  - Risk of integer overflow when reversing
  - Uses O(log n) space for reversed number
  - More complex than string approach

Approach 3: Mathematical (Reverse Half) ✓ OPTIMAL
--------------------------------------------------
Reverse only half the number and compare.

Pros:
  - O(1) space complexity
  - No overflow risk (only reversing half)
  - Optimal time and space

Cons:
  - More complex logic
  - Need to handle odd/even length differently


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Forgetting Negative Numbers
   ❌ Not checking if x < 0
   ✓ Return false immediately for negative numbers

2. Not Handling Numbers Ending in 0
   ❌ Treating 10, 100, etc. as potential palindromes
   ✓ Return false for x % 10 == 0 (except x == 0)

3. Integer Overflow in Mathematical Approach
   ❌ Reversing entire number without overflow check
   ✓ Only reverse half the number

4. Incorrect String Comparison
   ❌ Comparing str(x) with x[::-1] (type mismatch)
   ✓ Compare str(x) with str(x)[::-1]

5. Not Handling Single Digit
   ❌ Special casing single digits unnecessarily
   ✓ Algorithm naturally handles them correctly


================================================================================
KEY TAKEAWAYS
================================================================================

1. String conversion is simpler but uses O(n) space
2. Mathematical approach achieves O(1) space but is more complex
3. Negative numbers are never palindromes
4. Numbers ending in 0 (except 0) are never palindromes
5. Reversing only half the number avoids overflow issues
6. For odd-length numbers, middle digit can be ignored


================================================================================
RELATED PROBLEMS
================================================================================

- Reverse Integer (Medium) - Related reversal logic
- Palindrome Linked List (Easy) - Palindrome concept on linked lists
- Valid Palindrome (Easy) - String palindrome with alphanumeric only
- Palindrome Pairs (Hard) - Finding palindrome pairs in array
- Longest Palindromic Substring (Medium) - Finding palindromic substrings


================================================================================
