================================================================================
PASCAL'S TRIANGLE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer numRows, return the first numRows of Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it.

EXAMPLES:
---------
Example 1:
  Input: numRows = 5
  Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Example 2:
  Input: numRows = 1
  Output: [[1]]

CONSTRAINTS:
------------
- 1 <= numRows <= 30


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Building triangle row by row
2. Calculating values from previous row
3. Handling edge values (always 1)
4. Managing 2D array construction

ALGORITHM STEPS:
----------------
1. Initialize result array
2. For each row i from 0 to numRows-1:
   a. Create new row array
   b. For each position j in row:
      - If j == 0 or j == i: append 1
      - Otherwise: sum previous row's j-1 and j positions
   c. Add row to result
3. Return result


DETAILED EXPLANATION:
---------------------

Pascal's Triangle Pattern:
--------------------------
Row 0:           1
Row 1:         1   1
Row 2:       1   2   1
Row 3:     1   3   3   1
Row 4:   1   4   6   4   1

Rules:
1. First and last elements of each row are 1
2. Middle elements = sum of two elements above

Example: Building Row 4
-----------------------
Previous row (row 3): [1, 3, 3, 1]

Position 0: 1 (edge)
Position 1: prev[0] + prev[1] = 1 + 3 = 4
Position 2: prev[1] + prev[2] = 3 + 3 = 6
Position 3: prev[2] + prev[3] = 3 + 1 = 4
Position 4: 1 (edge)

Result: [1, 4, 6, 4, 1]

Walkthrough for numRows = 5:
-----------------------------
Row 0: [1]
  - Only one element, always 1

Row 1: [1, 1]
  - Position 0: 1 (edge)
  - Position 1: 1 (edge)

Row 2: [1, 2, 1]
  - Position 0: 1 (edge)
  - Position 1: prev[0] + prev[1] = 1 + 1 = 2
  - Position 2: 1 (edge)

Row 3: [1, 3, 3, 1]
  - Position 0: 1 (edge)
  - Position 1: prev[0] + prev[1] = 1 + 2 = 3
  - Position 2: prev[1] + prev[2] = 2 + 1 = 3
  - Position 3: 1 (edge)

Row 4: [1, 4, 6, 4, 1]
  - As shown above


================================================================================
CODE IMPLEMENTATION
================================================================================

# Standard Approach
class Solution(object):
    def generate(self, numRows):
        res = []
        
        for i in range(numRows):
            sub = []
            for j in range(i + 1):
                if j == 0 or j == i:
                    sub.append(1)
                else:
                    prev_row = res[i - 1]
                    num = prev_row[j - 1] + prev_row[j]
                    sub.append(num)
            res.append(sub)
        
        return res


# Alternative: Using list initialization
def generate_v2(numRows):
    result = []
    
    for i in range(numRows):
        # Initialize row with 1's
        row = [1] * (i + 1)
        
        # Fill middle values
        for j in range(1, i):
            row[j] = result[i - 1][j - 1] + result[i - 1][j]
        
        result.append(row)
    
    return result


# More Pythonic
def generate_pythonic(numRows):
    triangle = [[1]]
    
    for i in range(1, numRows):
        row = [1]
        for j in range(1, i):
            row.append(triangle[i-1][j-1] + triangle[i-1][j])
        row.append(1)
        triangle.append(row)
    
    return triangle if numRows > 0 else []


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(numRows²)
  - Outer loop: numRows iterations
  - Inner loop: i iterations (0 to numRows-1)
  - Total elements: 1 + 2 + 3 + ... + numRows = numRows(numRows+1)/2
  - Total: O(numRows²)

Space Complexity: O(numRows²)
  - Result array stores all elements
  - Total elements: numRows(numRows+1)/2
  - Total: O(numRows²)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Five Rows
  Input: numRows = 5
  Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
  ✓ Correct Pascal's triangle

Test Case 2: Single Row
  Input: numRows = 1
  Output: [[1]]
  ✓ Base case

Test Case 3: Two Rows
  Input: numRows = 2
  Output: [[1],[1,1]]
  ✓ Simple case

Test Case 4: Three Rows
  Input: numRows = 3
  Output: [[1],[1,1],[1,2,1]]
  ✓ Shows pattern emerging


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Build Row by Row ✓ RECOMMENDED
-------------------------------------------
Construct each row using previous row.

Pros:
  - Straightforward and intuitive
  - Easy to understand
  - Optimal complexity

Cons:
  - Requires storing all previous rows

Approach 2: Using Combinatorics
--------------------------------
Use combination formula: C(n, k) = n! / (k! * (n-k)!)

Pros:
  - Mathematical elegance
  - Can generate any row independently

Cons:
  - More complex
  - Potential overflow with factorials
  - Not necessary for this problem


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Wrong Index Bounds
   ❌ Using wrong loop ranges
   ✓ Row i has i+1 elements (0 to i)

2. Not Handling Edge Cases
   ❌ Not setting first/last to 1
   ✓ Check j == 0 or j == i

3. Wrong Previous Row Access
   ❌ Accessing res[i] instead of res[i-1]
   ✓ Previous row is at index i-1

4. Index Out of Bounds
   ❌ Not checking array bounds
   ✓ Ensure prev_row has elements at j-1 and j

5. Not Initializing Result
   ❌ Forgetting to create result array
   ✓ Initialize res = []


================================================================================
KEY TAKEAWAYS
================================================================================

1. Each row has i+1 elements (row i)
2. Edge elements are always 1
3. Middle elements = sum of two above
4. Build iteratively using previous row
5. Time and space: O(numRows²)
6. Classic dynamic programming pattern


================================================================================
RELATED PROBLEMS
================================================================================

- Pascal's Triangle II (Easy) - Get specific row
- Triangle (Medium) - Minimum path sum
- Unique Paths (Medium) - Similar DP pattern
- Combination Sum (Medium) - Combinatorics
- Generate Parentheses (Medium) - Pattern generation
- Subsets (Medium) - Generating combinations


================================================================================
