================================================================================
POWER OF TWO - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2^x.

EXAMPLES:
---------
Example 1:
  Input: n = 1
  Output: true
  Explanation: 2^0 = 1

Example 2:
  Input: n = 16
  Output: true
  Explanation: 2^4 = 16

Example 3:
  Input: n = 3
  Output: false

CONSTRAINTS:
------------
- -2^31 <= n <= 2^31 - 1

Follow-up: Could you solve it without loops/recursion?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Checking if number is power of 2
2. Handling negative numbers and zero
3. Solving without loops (follow-up)
4. Using bit manipulation efficiently

ALGORITHM STEPS:
----------------
Approach 1: Bit Manipulation (Optimal)
1. Check if n > 0
2. Check if n & (n-1) == 0
3. Return result

Approach 2: Loop Division
1. If n <= 0, return false
2. While n > 1:
   - If n is odd, return false
   - Divide n by 2
3. Return true

Approach 3: Count Bits
1. Check if n > 0
2. Count number of 1-bits
3. Return true if exactly one 1-bit


DETAILED EXPLANATION:
---------------------

Bit Manipulation Approach:
--------------------------
Key insight: Powers of 2 have exactly one bit set in binary.

Examples:
  1  = 0001 (2^0)
  2  = 0010 (2^1)
  4  = 0100 (2^2)
  8  = 1000 (2^3)
  16 = 10000 (2^4)

Property: n & (n-1) removes the rightmost 1-bit.

For powers of 2 (only one 1-bit):
  n & (n-1) == 0

Example: n = 8
  8 in binary: 1000
  7 in binary: 0111
  8 & 7 = 1000 & 0111 = 0000 = 0 ✓

Example: n = 6 (not power of 2)
  6 in binary: 0110
  5 in binary: 0101
  6 & 5 = 0110 & 0101 = 0100 = 4 ≠ 0 ✗

Why n & (n-1) Works:
--------------------
Subtracting 1 from n flips all bits after the rightmost 1-bit.

n    = ...1000...
n-1  = ...0111...
n&(n-1) = ...0000...

If n has only one 1-bit (power of 2), result is 0.
If n has multiple 1-bits, result is non-zero.

Edge Cases:
-----------
- n <= 0: Not a power of 2
- n = 1: 2^0 = 1, is a power of 2


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Bit Manipulation ✓ OPTIMAL
def isPowerOfTwo(n):
    if n <= 0:
        return False
    return (n & (n - 1)) == 0


# One-liner
def isPowerOfTwo_oneliner(n):
    return n > 0 and (n & (n - 1)) == 0


# Approach 2: Loop Division
def isPowerOfTwo_loop(n):
    if n <= 0:
        return False
    
    while n > 1:
        if n % 2 != 0:  # Odd number, not power of 2
            return False
        n = n // 2
    
    return True


# Approach 3: Count Bits
def isPowerOfTwo_count(n):
    if n <= 0:
        return False
    # Count number of 1-bits
    return bin(n).count('1') == 1


# Using logarithm (not recommended)
import math

def isPowerOfTwo_log(n):
    if n <= 0:
        return False
    return math.log2(n) % 1 == 0


# LeetCode Solution Class Format
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Bit Manipulation
-----------------------------
Time Complexity: O(1)
  - Single bitwise operation
  - Total: O(1)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1) ✓ OPTIMAL

Approach 2: Loop Division
--------------------------
Time Complexity: O(log n)
  - Divide by 2 each iteration
  - log₂(n) iterations
  - Total: O(log n)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)

Approach 3: Count Bits
-----------------------
Time Complexity: O(log n)
  - bin() converts to binary string: O(log n)
  - count() scans string: O(log n)
  - Total: O(log n)

Space Complexity: O(log n)
  - Binary string storage
  - Total: O(log n)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Power of 2
  Input: n = 16
  Output: true
  ✓ 2^4 = 16

Test Case 2: Not Power of 2
  Input: n = 3
  Output: false
  ✓ No x where 2^x = 3

Test Case 3: One
  Input: n = 1
  Output: true
  ✓ 2^0 = 1

Test Case 4: Zero
  Input: n = 0
  Output: false
  ✓ 0 is not a power of 2

Test Case 5: Negative
  Input: n = -16
  Output: false
  ✓ Negative numbers not powers of 2

Test Case 6: Large Power of 2
  Input: n = 1024
  Output: true
  ✓ 2^10 = 1024


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Bit Manipulation ✓ RECOMMENDED
-------------------------------------------
Check if n & (n-1) == 0.

Pros:
  - O(1) time and space
  - No loops or recursion
  - Elegant and efficient
  - Meets follow-up requirement

Cons:
  - Requires understanding bit manipulation

Approach 2: Loop Division
--------------------------
Repeatedly divide by 2.

Pros:
  - Intuitive and easy to understand
  - No bit manipulation needed

Cons:
  - O(log n) time
  - Uses loops (violates follow-up)

Approach 3: Count Bits
-----------------------
Count 1-bits in binary representation.

Pros:
  - Clear logic
  - No loops in code

Cons:
  - O(log n) time and space
  - Less efficient than bit manipulation


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Zero and Negatives
   ❌ Not checking n <= 0
   ✓ Return false for n <= 0

2. Wrong Bit Operation
   ❌ Using n & n-1 instead of (n & (n-1)) == 0
   ✓ Check if result equals 0

3. Using Floating Point
   ❌ Using log2() with floating point comparison
   ✓ Use bit manipulation for exact results

4. Not Handling n = 1
   ❌ Thinking 1 is not a power of 2
   ✓ 2^0 = 1 is a power of 2

5. Overflow in Loop
   ❌ Not handling large numbers properly
   ✓ Bit manipulation avoids overflow


================================================================================
KEY TAKEAWAYS
================================================================================

1. Powers of 2 have exactly one bit set in binary
2. n & (n-1) removes rightmost 1-bit
3. For power of 2: n & (n-1) == 0
4. Bit manipulation is O(1) solution
5. Must check n > 0 first
6. This is a classic bit manipulation problem


================================================================================
RELATED PROBLEMS
================================================================================

- Power of Three (Easy) - Similar for base 3
- Power of Four (Easy) - Similar for base 4
- Number of 1 Bits (Easy) - Counting set bits
- Single Number (Easy) - Bit manipulation
- Missing Number (Easy) - XOR technique
- Reverse Bits (Easy) - Bit operations


================================================================================
