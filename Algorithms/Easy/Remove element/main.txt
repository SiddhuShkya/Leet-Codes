================================================================================
REMOVE ELEMENT - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums and an integer val, remove all occurrences of val 
in nums in-place. The order of the elements may be changed. Then return the 
number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get 
accepted, you need to do the following things:
- Change the array nums such that the first k elements of nums contain the 
  elements which are not equal to val.
- The remaining elements of nums are not important as well as the size of nums.
- Return k.

EXAMPLES:
---------
Example 1:
  Input: nums = [3,2,2,3], val = 3
  Output: 2, nums = [2,2,_,_]
  Explanation: Your function should return k = 2, with the first two elements 
  of nums being 2. It does not matter what you leave beyond the returned k.

Example 2:
  Input: nums = [0,1,2,2,3,0,4,2], val = 2
  Output: 5, nums = [0,1,4,0,3,_,_,_]
  Explanation: Your function should return k = 5, with the first five elements 
  of nums containing 0, 0, 1, 3, and 4.

CONSTRAINTS:
------------
- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Removing elements in-place (no extra array)
2. Order doesn't need to be preserved
3. Only first k elements matter
4. Minimizing number of operations

ALGORITHM STEPS:
----------------
Approach 1: Two Pointers (Optimal)
1. Use pointer `i` to track position for next non-val element
2. Iterate through array with pointer `j`
3. When nums[j] != val:
   - Copy nums[j] to nums[i]
   - Increment i
4. Return i (count of non-val elements)

Approach 2: Two Pointers with Swap
1. Use left and right pointers
2. When nums[left] == val, swap with nums[right]
3. Decrement right
4. Otherwise increment left


DETAILED EXPLANATION:
---------------------

Two Pointers Approach:
----------------------
Similar to "Move Zeroes" but we're removing specific value.

Key insight:
- `i` tracks where to place next non-val element
- `j` scans through array
- Copy non-val elements to front
- Don't care about elements after position i

Example Walkthrough: nums = [3,2,2,3], val = 3
-----------------------------------------------
Initial: i=0, j=0
  nums = [3,2,2,3]

j=0: nums[0]=3 (equals val, skip)
  i=0, j=1

j=1: nums[1]=2 (not val!)
  nums[i] = nums[1] = 2
  nums = [2,2,2,3]
  i=1, j=2

j=2: nums[2]=2 (not val!)
  nums[i] = nums[2] = 2
  nums = [2,2,2,3]
  i=2, j=3

j=3: nums[3]=3 (equals val, skip)
  i=2, j=4

Done! Return i=2
Result: First 2 elements are [2,2]

Why Order Doesn't Matter:
--------------------------
Problem only cares about first k elements containing non-val values.
We can rearrange as needed, making solution simpler.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Two Pointers ✓ OPTIMAL
def removeElement(nums, val):
    i = 0  # Position for next non-val element
    
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    
    return i


# Alternative: More explicit
def removeElement_v2(nums, val):
    left = 0
    for right in range(len(nums)):
        if nums[right] != val:
            nums[left] = nums[right]
            left += 1
    return left


# Approach 2: Two Pointers with Swap (When val is rare)
def removeElement_swap(nums, val):
    left = 0
    right = len(nums) - 1
    
    while left <= right:
        if nums[left] == val:
            # Swap with element from right
            nums[left] = nums[right]
            right -= 1
        else:
            left += 1
    
    return left


# Using list comprehension (creates new list - not in-place)
def removeElement_comprehension(nums, val):
    result = [x for x in nums if x != val]
    nums[:len(result)] = result
    return len(result)


# LeetCode Solution Class Format
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        for j in range(len(nums)):
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1
        return i


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Two Pointers
-------------------------
Time Complexity: O(n)
  - Single pass through array
  - Each element examined once
  - Total: O(n)

Space Complexity: O(1)
  - Only using two pointer variables
  - In-place modification
  - Total: O(1) ✓ OPTIMAL

Approach 2: Two Pointers with Swap
-----------------------------------
Time Complexity: O(n)
  - Worst case: all elements != val
  - Best case: all elements == val
  - Average: O(n)

Space Complexity: O(1)
  - Only using two pointers
  - In-place modification
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Multiple Occurrences
  Input: nums = [3,2,2,3], val = 3
  Output: k = 2, nums = [2,2,_,_]
  ✓ Both 3's removed

Test Case 2: Many Occurrences
  Input: nums = [0,1,2,2,3,0,4,2], val = 2
  Output: k = 5, nums = [0,1,4,0,3,_,_,_]
  ✓ All 2's removed

Test Case 3: No Occurrences
  Input: nums = [1,2,3], val = 4
  Output: k = 3, nums = [1,2,3]
  ✓ No changes needed

Test Case 4: All Same Value
  Input: nums = [2,2,2], val = 2
  Output: k = 0, nums = [_,_,_]
  ✓ All elements removed

Test Case 5: Empty Array
  Input: nums = [], val = 1
  Output: k = 0
  ✓ Empty array handled

Test Case 6: Single Element Match
  Input: nums = [1], val = 1
  Output: k = 0
  ✓ Single element removed


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Two Pointers (Copy) ✓ RECOMMENDED
----------------------------------------------
Copy non-val elements to front.

Pros:
  - O(n) time, O(1) space
  - Simple and clean
  - Works for all cases
  - Minimal operations when val is common

Cons:
  - Always scans entire array

Approach 2: Two Pointers (Swap)
--------------------------------
Swap val elements with end elements.

Pros:
  - O(n) time, O(1) space
  - Fewer operations when val is rare
  - Can terminate early

Cons:
  - Slightly more complex
  - More swaps when val is common


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Creating New Array
   ❌ Using extra array for result
   ✓ Modify in-place

2. Trying to Preserve Order Unnecessarily
   ❌ Complex logic to maintain original order
   ✓ Order doesn't matter, simplify

3. Removing While Iterating
   ❌ Using remove() in loop (O(n²))
   ✓ Use two-pointer approach

4. Not Returning Correct Count
   ❌ Returning len(nums) instead of k
   ✓ Return count of non-val elements

5. Caring About Elements After k
   ❌ Trying to clean up elements after position k
   ✓ Only first k elements matter


================================================================================
KEY TAKEAWAYS
================================================================================

1. Two pointers provide optimal O(n) in-place solution
2. Order preservation not required simplifies problem
3. Only first k elements need correct values
4. Similar pattern to "Move Zeroes" problem
5. In-place modification requires careful pointer management
6. Different strategies optimal for different val frequencies


================================================================================
RELATED PROBLEMS
================================================================================

- Remove Duplicates from Sorted Array (Easy) - Similar two-pointer
- Move Zeroes (Easy) - Similar in-place movement
- Remove Linked List Elements (Easy) - Linked list version
- Remove All Occurrences of a Substring (Medium) - String version
- Delete Node in a Linked List (Medium) - Node removal
- Remove Duplicates from Sorted Array II (Medium) - Allow duplicates


================================================================================
