================================================================================
ROMAN TO INTEGER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

For example, 2 is written as II in Roman numeral, just two ones added together.
12 is written as XII, which is simply X + II. The number 27 is written as XXVII,
which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. 
However, the numeral for four is not IIII. Instead, the number four is written 
as IV. Because the one is before the five we subtract it making four. The same 
principle applies to the number nine, which is written as IX.

There are six instances where subtraction is used:
- I can be placed before V (5) and X (10) to make 4 and 9
- X can be placed before L (50) and C (100) to make 40 and 90
- C can be placed before D (500) and M (1000) to make 400 and 900

Given a roman numeral, convert it to an integer.

EXAMPLES:
---------
Example 1:
  Input: s = "III"
  Output: 3
  Explanation: III = 3

Example 2:
  Input: s = "LVIII"
  Output: 58
  Explanation: L = 50, V = 5, III = 3

Example 3:
  Input: s = "MCMXCIV"
  Output: 1994
  Explanation: M = 1000, CM = 900, XC = 90, IV = 4

CONSTRAINTS:
------------
- 1 <= s.length <= 15
- s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')
- It is guaranteed that s is a valid roman numeral in the range [1, 3999]


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Handling subtraction cases (IV, IX, XL, XC, CD, CM)
2. Processing string left to right efficiently
3. Deciding when to add vs subtract values
4. Avoiding complex conditional logic

ALGORITHM STEPS:
----------------
Approach 1: Check Two Characters at a Time
1. Create hash map with all symbols (including subtraction pairs)
2. Iterate through string
3. Check if next 2 characters form a subtraction pair
4. If yes, add that value and skip 2 characters
5. If no, add single character value and skip 1 character

Approach 2: Compare Adjacent Characters
1. Create hash map with basic symbols only
2. Iterate through string
3. If current value < next value, subtract current
4. Otherwise, add current value


DETAILED EXPLANATION:
---------------------

Understanding Subtraction Rule:
--------------------------------
When a smaller value appears BEFORE a larger value, we subtract it.
Examples:
  - IV: I (1) before V (5) → 5 - 1 = 4
  - IX: I (1) before X (10) → 10 - 1 = 9
  - XL: X (10) before L (50) → 50 - 10 = 40
  - XC: X (10) before C (100) → 100 - 10 = 90
  - CD: C (100) before D (500) → 500 - 100 = 400
  - CM: C (100) before M (1000) → 1000 - 100 = 900

Approach 1 Example with s = "MCMXCIV":
---------------------------------------
Hash map includes: {'M': 1000, 'CM': 900, 'XC': 90, 'IV': 4, ...}

Iteration 1: Check "MC" → not in map, take "M" = 1000, result = 1000
Iteration 2: Check "CM" → in map! Take "CM" = 900, result = 1900
Iteration 3: Check "XC" → in map! Take "XC" = 90, result = 1990
Iteration 4: Check "IV" → in map! Take "IV" = 4, result = 1994

Approach 2 Example with s = "MCMXCIV":
---------------------------------------
M: 1000 (no next or next is smaller) → add 1000
C: 100 < M (1000) → subtract 100 → total = 900
M: 1000 (next is smaller) → add 1000 → total = 1900
X: 10 < C (100) → subtract 10 → total = 1890
C: 100 (next is smaller) → add 100 → total = 1990
I: 1 < V (5) → subtract 1 → total = 1989
V: 5 (no next) → add 5 → total = 1994


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Hash Map with Subtraction Pairs
def romanToInt(s):
    symValues = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
        'IV': 4,
        'IX': 9,
        'XL': 40,
        'XC': 90,
        'CD': 400,
        'CM': 900
    }
    res = 0
    while s != '':
        if s[:2] in symValues:
            res += symValues[s[:2]]
            s = s[2:]
        else:
            res += symValues[s[:1]]
            s = s[1:]
    return res


# Approach 2: Compare Adjacent Characters
def romanToInt_v2(s):
    values = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    
    total = 0
    for i in range(len(s)):
        # If current value < next value, subtract it
        if i < len(s) - 1 and values[s[i]] < values[s[i + 1]]:
            total -= values[s[i]]
        else:
            total += values[s[i]]
    
    return total


# LeetCode Solution Class Format
class Solution:
    def romanToInt(self, s: str) -> int:
        values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 
                  'C': 100, 'D': 500, 'M': 1000}
        
        total = 0
        for i in range(len(s)):
            if i < len(s) - 1 and values[s[i]] < values[s[i + 1]]:
                total -= values[s[i]]
            else:
                total += values[s[i]]
        
        return total


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Hash Map with Pairs
--------------------------------
Time Complexity: O(n)
  - Iterate through string once
  - Each iteration processes 1 or 2 characters
  - Hash map lookup is O(1)
  - Total: O(n)

Space Complexity: O(1)
  - Hash map has fixed size (13 entries)
  - No additional data structures
  - Total: O(1)

Approach 2: Compare Adjacent
-----------------------------
Time Complexity: O(n)
  - Single pass through string
  - Each character processed once
  - Total: O(n)

Space Complexity: O(1)
  - Hash map has fixed size (7 entries)
  - Only using a few variables
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Simple Addition
  Input: s = "III"
  Output: 3
  ✓ All same symbols, just add

Test Case 2: Mixed Symbols
  Input: s = "LVIII"
  Output: 58
  ✓ L(50) + V(5) + III(3) = 58

Test Case 3: With Subtraction
  Input: s = "MCMXCIV"
  Output: 1994
  ✓ M(1000) + CM(900) + XC(90) + IV(4) = 1994

Test Case 4: All Subtraction Cases
  Input: s = "CDXLIV"
  Output: 444
  ✓ CD(400) + XL(40) + IV(4) = 444

Test Case 5: Largest Value
  Input: s = "MMMCMXCIX"
  Output: 3999
  ✓ Maximum valid Roman numeral


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Hash Map with Pairs
--------------------------------
Include subtraction pairs in hash map.

Pros:
  - Explicit handling of special cases
  - Clear mapping of all possibilities
  - Easy to understand

Cons:
  - Larger hash map (13 entries vs 7)
  - String slicing operations
  - Slightly more memory

Approach 2: Compare Adjacent ✓ RECOMMENDED
-------------------------------------------
Compare current with next character.

Pros:
  - Smaller hash map (7 entries)
  - Cleaner code
  - More elegant solution
  - Handles all cases with one rule

Cons:
  - Requires understanding of subtraction rule
  - Need to check array bounds


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Subtraction Cases
   ❌ Only adding values without checking order
   ✓ Check if smaller value comes before larger

2. Index Out of Bounds
   ❌ Not checking i < len(s) - 1 before accessing s[i+1]
   ✓ Always check bounds when looking ahead

3. Wrong Subtraction Logic
   ❌ Subtracting when current >= next
   ✓ Subtract only when current < next

4. Hardcoding All Cases
   ❌ Using many if-else for each subtraction pair
   ✓ Use general rule: subtract if current < next

5. Not Using Hash Map
   ❌ Using many if-else for symbol values
   ✓ Use hash map for clean lookup


================================================================================
KEY TAKEAWAYS
================================================================================

1. Subtraction rule: smaller before larger means subtract
2. Hash map provides O(1) lookup for symbol values
3. Comparing adjacent characters is more elegant than checking pairs
4. Only 6 subtraction cases exist (IV, IX, XL, XC, CD, CM)
5. Single pass through string is sufficient
6. Problem has bounded input (max 15 characters, max 3999)


================================================================================
RELATED PROBLEMS
================================================================================

- Integer to Roman (Medium) - Reverse problem
- Excel Sheet Column Number (Easy) - Similar conversion problem
- Excel Sheet Column Title (Easy) - Number to letter conversion
- Number of Steps to Reduce a Number to Zero (Easy) - Number manipulation


================================================================================
