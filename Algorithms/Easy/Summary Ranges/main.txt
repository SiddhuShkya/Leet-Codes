================================================================================
SUMMARY RANGES - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
You are given a sorted unique integer array nums.

A range [a,b] is the set of all integers from a to b (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the 
array exactly. That is, each element of nums is covered by exactly one of the 
ranges, and there is no integer x such that x is in one of the ranges but not 
in nums.

Each range [a,b] in the list should be output as:
- "a->b" if a != b
- "a" if a == b

EXAMPLES:
---------
Example 1:
  Input: nums = [0,1,2,4,5,7]
  Output: ["0->2","4->5","7"]
  Explanation: The ranges are:
  [0,2] --> "0->2"
  [4,5] --> "4->5"
  [7,7] --> "7"

Example 2:
  Input: nums = [0,2,3,4,6,8,9]
  Output: ["0","2->4","6","8->9"]
  Explanation: The ranges are:
  [0,0] --> "0"
  [2,4] --> "2->4"
  [6,6] --> "6"
  [8,9] --> "8->9"

CONSTRAINTS:
------------
- 0 <= nums.length <= 20
- -2^31 <= nums[i] <= 2^31 - 1
- All the values of nums are unique.
- nums is sorted in ascending order.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Identifying consecutive sequences
2. Handling single-number ranges
3. Formatting output strings
4. Handling empty array

ALGORITHM STEPS:
----------------
Approach 1: Linear Scan (O(n)) ✓ OPTIMAL
1. Initialize pointer `i` at 0.
2. While `i` < length:
   - Set `start` = nums[i].
   - While `i+1` < length AND nums[i+1] == nums[i] + 1:
     - Increment `i` (extend range).
   - Set `end` = nums[i].
   - If `start` == `end`:
     - Add "start" to result.
   - Else:
     - Add "start->end" to result.
   - Increment `i` (move to next potential range).


DETAILED EXPLANATION:
---------------------

Logic Trace: [0,1,2,4,5,7]
--------------------------
1. i=0, start=0
   - nums[1] (1) == 0 + 1? Yes. i=1.
   - nums[2] (2) == 1 + 1? Yes. i=2.
   - nums[3] (4) == 2 + 1? No. Stop.
   - end = nums[2] = 2.
   - start (0) != end (2) -> Add "0->2".
   - i increments to 3.

2. i=3, start=4
   - nums[4] (5) == 4 + 1? Yes. i=4.
   - nums[5] (7) == 5 + 1? No. Stop.
   - end = nums[4] = 5.
   - start (4) != end (5) -> Add "4->5".
   - i increments to 5.

3. i=5, start=7
   - i+1 (6) is not < len (6). Stop.
   - end = nums[5] = 7.
   - start (7) == end (7) -> Add "7".
   - i increments to 6.

4. i=6 not < len. Stop.

Result: ["0->2", "4->5", "7"]


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Linear Scan ✓ RECOMMENDED
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        result = []
        i = 0
        
        while i < len(nums):
            start = nums[i]
            
            # Continue while next element is consecutive
            while i + 1 < len(nums) and nums[i + 1] == nums[i] + 1:
                i += 1
            
            end = nums[i]
            
            if start == end:
                result.append(str(start))
            else:
                result.append(f"{start}->{end}")
            
            i += 1
            
        return result


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n)
  - We visit each element exactly once (either as start or during while loop).
  - Total: O(n).

Space Complexity: O(1) (excluding result list)
  - Only variables used.
  - Result list takes O(n) space in worst case (all disjoint).


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Mixed Ranges
  Input: [0,1,2,4,5,7]
  Output: ["0->2","4->5","7"]
  ✓ Correct grouping

Test Case 2: All Disjoint
  Input: [0,2,4,6]
  Output: ["0","2","4","6"]
  ✓ Correct single items

Test Case 3: All Consecutive
  Input: [1,2,3,4]
  Output: ["1->4"]
  ✓ Single range

Test Case 4: Empty
  Input: []
  Output: []
  ✓ Handles empty

Test Case 5: Single Element
  Input: [1]
  Output: ["1"]
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Linear Scan ✓ RECOMMENDED
-------------------------------------
Pros:
  - Simple, optimal O(n).
  - Easy to read.

Cons:
  - None.

Approach 2: Two Pointers (Start/End)
------------------------------------
Same logic, just explicit start/end pointers.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Index Out of Bounds
   ❌ checking nums[i+1] without i+1 < len
   ✓ Always check bounds first

2. String Formatting
   ❌ "start->end" literal
   ✓ Use f-string or concatenation

3. Updating Index
   ❌ Forgetting to increment i after inner loop
   ✓ Outer loop increments, or manual increment

4. Empty Input
   ❌ Not handling []
   ✓ Loop condition handles it naturally


================================================================================
KEY TAKEAWAYS
================================================================================

1. Sorted unique array simplifies problem to finding gaps > 1.
2. Inner while loop skips consecutive elements efficiently.
3. O(n) time complexity is optimal.
4. Careful with string formatting and edge cases.


================================================================================
RELATED PROBLEMS
================================================================================

- Missing Ranges (Easy) - Find missing ranges instead of present ones
- Data Stream as Disjoint Intervals (Hard) - Dynamic version
- Teemo Attacking (Easy) - Merging time intervals
- Merge Intervals (Medium) - General interval merging


================================================================================
