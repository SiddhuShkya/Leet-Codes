================================================================================
THE K WEAKEST ROWS IN A MATRIX - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
You are given an m x n binary matrix mat of 1's (representing soldiers) and 
0's (representing civilians). The soldiers are positioned in front of the 
civilians. That is, all the 1's will appear to the left of all the 0's in each 
row.

A row i is weaker than a row j if one of the following is true:
- The number of soldiers in row i is less than the number of soldiers in row j.
- Both rows have the same number of soldiers and i < j.

Return the indices of the k weakest rows in the matrix ordered from weakest to 
strongest.

EXAMPLES:
---------
Example 1:
  Input: mat = 
  [[1,1,0,0,0],
   [1,1,1,1,0],
   [1,0,0,0,0],
   [1,1,0,0,0],
   [1,1,1,1,1]], 
  k = 3
  Output: [2,0,3]
  Explanation: 
  Row 0: 2 soldiers
  Row 1: 4 soldiers
  Row 2: 1 soldier
  Row 3: 2 soldiers
  Row 4: 5 soldiers
  Sorted: Row 2 (1), Row 0 (2), Row 3 (2), Row 1 (4), Row 4 (5).
  Top 3: 2, 0, 3.

Example 2:
  Input: mat = 
  [[1,0,0,0],
   [1,1,1,1],
   [1,0,0,0],
   [1,0,0,0]], 
  k = 2
  Output: [0,2]

CONSTRAINTS:
------------
- m == mat.length
- n == mat[i].length
- 2 <= n, m <= 100
- 1 <= k <= m
- matrix[i][j] is either 0 or 1.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Counting soldiers efficiently
2. Sorting based on two criteria (count, index)
3. Selecting top k

ALGORITHM STEPS:
----------------
Approach 1: Count and Sort (O(m * n + m log m))
1. For each row, count soldiers (sum of 1s).
2. Store pairs `(count, index)`.
3. Sort pairs:
   - Primary key: count (ascending).
   - Secondary key: index (ascending).
4. Extract first k indices.

Approach 2: Binary Search Count + Heap (O(m log n + m log k)) ✓ OPTIMAL
1. Since rows are sorted (1s then 0s), use Binary Search to find count of 1s.
   - Find first 0. Index of first 0 = count of 1s.
2. Use a Max Heap of size k to maintain weakest rows.
   - Or Min Heap of size m and pop k.
   - Or just sort (since m is small <= 100, sorting is fast enough).

DETAILED EXPLANATION:
---------------------

Sorting Logic:
--------------
Pairs: [(2, 0), (4, 1), (1, 2), (2, 3), (5, 4)]

Sort:
1. (1, 2) - Count 1
2. (2, 0) - Count 2, Index 0 < 3
3. (2, 3) - Count 2, Index 3
4. (4, 1) - Count 4
5. (5, 4) - Count 5

Top 3: [2, 0, 3].


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Count and Sort (Simple & Fast for small m) ✓ RECOMMENDED
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # Create list of (count, index)
        # sum(row) works because 1s are soldiers
        strength = []
        for i, row in enumerate(mat):
            strength.append((sum(row), i))
            
        # Sort by count, then index
        strength.sort()
        
        # Extract indices
        return [idx for count, idx in strength[:k]]


# Approach 2: Binary Search Count (Optimization)
class SolutionBinarySearch:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        def count_soldiers(row):
            left, right = 0, len(row)
            while left < right:
                mid = (left + right) // 2
                if row[mid] == 1:
                    left = mid + 1
                else:
                    right = mid
            return left

        strength = []
        for i, row in enumerate(mat):
            strength.append((count_soldiers(row), i))
            
        strength.sort()
        return [idx for count, idx in strength[:k]]


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Count and Sort
--------------------------
Time Complexity: O(m * n + m log m)
  - Counting: m * n.
  - Sorting: m log m.

Space Complexity: O(m)
  - Store strength list.

Approach 2: Binary Search
-------------------------
Time Complexity: O(m log n + m log m)
  - Counting: m * log n.
  - Sorting: m log m.
  - Better if n is large.

Space Complexity: O(m)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: (Example 1)
  Output: [2,0,3]
  ✓ Correct sort order

Test Case 2: Tie Breaking
  Input: [[1,0],[1,0]], k=2
  Output: [0,1]
  ✓ Same count (1), index 0 comes first

Test Case 3: All Strong
  Input: [[1,1],[1,1]], k=1
  Output: [0]
  ✓ Tie break


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Sort ✓ RECOMMENDED
------------------------------
Pros:
  - Very simple.
  - Fast enough for constraints.

Cons:
  - O(m log m) sort.

Approach 2: Heap (Priority Queue)
---------------------------------
Maintain k smallest elements.
Pros: O(m log k).
Cons: More code.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Sorting Stability
   ✓ Python sort is stable, but tuple comparison (count, index) explicitly handles tie-breaking correctly.

2. Counting 1s
   ✓ `sum(row)` is O(n). Binary search is O(log n). Use binary search if n is huge.

3. Indexing
   ✓ Remember to store original index `i`.


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Weakest" defined by primary (count) and secondary (index) keys.
2. Tuple sorting `(count, index)` handles this naturally.
3. Binary search can optimize counting in sorted binary arrays.
4. Time O(m log m), Space O(m).


================================================================================
RELATED PROBLEMS
================================================================================

- Kth Largest Element in an Array (Medium)
- K Closest Points to Origin (Medium)
- Relative Ranks (Easy)


================================================================================
