================================================================================
TWO SUM - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an array of integers nums and an integer target, return indices of the 
two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may 
not use the same element twice.

You can return the answer in any order.

EXAMPLES:
---------
Example 1:
  Input: nums = [2,7,11,15], target = 9
  Output: [0,1]
  Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:
  Input: nums = [3,2,4], target = 6
  Output: [1,2]

Example 3:
  Input: nums = [3,3], target = 6
  Output: [0,1]

CONSTRAINTS:
------------
- 2 <= nums.length <= 10^4
- -10^9 <= nums[i] <= 10^9
- -10^9 <= target <= 10^9
- Only one valid answer exists


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding two numbers that sum to target efficiently
2. Returning indices, not the values themselves
3. Avoiding using the same element twice
4. Optimizing from O(n²) brute force to O(n)

ALGORITHM STEPS:
----------------
Approach 1: Brute Force (O(n²))
1. Use nested loops to check all pairs
2. For each element at index i, check all elements after it
3. If nums[i] + nums[j] == target, return [i, j]

Approach 2: Hash Map (O(n)) ✓ OPTIMAL
1. Create an empty hash map to store {value: index}
2. For each element in the array:
   a. Calculate complement = target - current_element
   b. Check if complement exists in hash map
   c. If yes, return [hash_map[complement], current_index]
   d. If no, store current element in hash map
3. This guarantees we find the pair in one pass


DETAILED EXPLANATION:
---------------------

Why Hash Map Approach Works:
-----------------------------
The key insight is that for any number x in the array, we need to find if 
(target - x) also exists. Instead of searching the entire array each time 
(which takes O(n)), we use a hash map for O(1) lookup.

Example Walkthrough with nums = [2, 7, 11, 15], target = 9:

Iteration 1: i=0, nums[0]=2
  - complement = 9 - 2 = 7
  - 7 not in hashMap
  - Add {2: 0} to hashMap
  - hashMap = {2: 0}

Iteration 2: i=1, nums[1]=7
  - complement = 9 - 7 = 2
  - 2 IS in hashMap at index 0
  - Return [0, 1] ✓

Why We Don't Use Same Element Twice:
-------------------------------------
We check the hash map BEFORE adding the current element, so we only find 
elements we've already seen (which are at different indices).

Brute Force vs Hash Map:
-------------------------
Brute Force: Check all pairs (i, j) where i < j
  - Time: O(n²) - for each element, check all others
  - Space: O(1) - no extra space needed

Hash Map: Store seen elements for instant lookup
  - Time: O(n) - single pass through array
  - Space: O(n) - hash map stores up to n elements


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Brute Force - O(n²)
def twoSum_Bruteforce(arr, target):
    # Nested loop = O(n × n) = O(n²)
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if (arr[i] + arr[j] == target):
                return [i, j]
    return "Such sum does not exist in the array"


# Approach 2: Hash Map - O(n) ✓ OPTIMAL
def twoSum_hashmap(nums, target):
    hashMap = {}
    for i in range(len(nums)):
        diff = target - nums[i]
        if diff in hashMap:
            return [hashMap[diff], i]
        hashMap[nums[i]] = i


# LeetCode Solution Class Format
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashMap = {}
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashMap:
                return [hashMap[complement], i]
            hashMap[nums[i]] = i
        return []  # Should never reach here given constraints


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Brute Force
-----------------------
Time Complexity: O(n²)
  - Outer loop runs n times
  - Inner loop runs (n-1) + (n-2) + ... + 1 = n(n-1)/2 times
  - Total: O(n²)

Space Complexity: O(1)
  - Only using a few variables
  - No additional data structures

Approach 2: Hash Map (Optimal)
-------------------------------
Time Complexity: O(n)
  - Single pass through the array
  - Hash map lookup is O(1) average case
  - Hash map insertion is O(1) average case
  - Total: O(n)

Space Complexity: O(n)
  - Hash map can store up to n elements in worst case
  - Worst case: no solution found, all elements stored


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Basic Example
  Input: nums = [2, 7, 11, 15], target = 9
  Output: [0, 1]
  ✓ First two elements sum to target

Test Case 2: Solution Not at Start
  Input: nums = [3, 2, 4], target = 6
  Output: [1, 2]
  ✓ Elements at indices 1 and 2

Test Case 3: Duplicate Values
  Input: nums = [3, 3], target = 6
  Output: [0, 1]
  ✓ Same value at different indices

Test Case 4: Negative Numbers
  Input: nums = [-1, -2, -3, -4, -5], target = -8
  Output: [2, 4]
  ✓ Works with negative numbers

Test Case 5: Large Numbers
  Input: nums = [1000000000, 999999999, 1], target = 1999999999
  Output: [0, 1]
  ✓ Handles large values within constraints


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Brute Force (Not Recommended)
------------------------------------------
Check all possible pairs using nested loops.

Pros:
  - Simple to understand and implement
  - No extra space needed (O(1))
  - Works for small arrays

Cons:
  - Very slow for large arrays: O(n²)
  - Not acceptable for n = 10,000 (100 million operations)

Approach 2: Hash Map (Current Solution) ✓ RECOMMENDED
------------------------------------------------------
Use hash map to store seen elements for O(1) lookup.

Pros:
  - Optimal time complexity: O(n)
  - Single pass through array
  - Fast even for large arrays
  - Clean and readable code

Cons:
  - Uses O(n) extra space
  - Slightly more complex than brute force

Approach 3: Two Pointers (Only works if array is sorted)
---------------------------------------------------------
Sort array, use two pointers from start and end.

Pros:
  - O(n log n) time if sorting needed
  - O(1) extra space (excluding sort)

Cons:
  - Requires sorting, which changes indices
  - Problem asks for original indices, not values
  - Not applicable to this problem


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using Same Element Twice
   ❌ Checking if nums[i] + nums[i] == target
   ✓ Ensure i != j in brute force, or check hash map before adding

2. Returning Values Instead of Indices
   ❌ return [nums[i], nums[j]]
   ✓ return [i, j]

3. Not Handling Duplicates Correctly
   ❌ Overwriting hash map entries for duplicate values
   ✓ Check hash map before adding, so we find previous occurrence

4. Inefficient Brute Force for Large Input
   ❌ Using O(n²) for n = 10,000
   ✓ Use hash map for O(n) solution

5. Forgetting Edge Cases
   ❌ Not testing with negative numbers, duplicates
   ✓ Test all constraint boundaries


================================================================================
KEY TAKEAWAYS
================================================================================

1. Hash maps provide O(1) lookup, enabling O(n²) → O(n) optimization
2. Trade space for time: O(n) space gives us O(n) time
3. Check hash map BEFORE adding to avoid using same element twice
4. Always consider if sorting would help (not in this case due to indices)
5. Two Sum is a fundamental pattern used in many other problems


================================================================================
RELATED PROBLEMS
================================================================================

- 3Sum (Medium) - Extension to three numbers
- 4Sum (Medium) - Extension to four numbers
- Two Sum II - Input Array Is Sorted (Easy) - Sorted version
- Two Sum III - Data Structure Design (Easy) - Design a data structure
- Subarray Sum Equals K (Medium) - Similar hash map technique
- Two Sum IV - Input is a BST (Easy) - BST variation


================================================================================
