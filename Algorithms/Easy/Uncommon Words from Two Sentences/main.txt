================================================================================
UNCOMMON WORDS FROM TWO SENTENCES - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
A sentence is a string of single-space separated words where each word consists 
only of lowercase letters.

A word is uncommon if it appears exactly once in one of the sentences, and does 
not appear in the other sentence.

Given two sentences s1 and s2, return a list of all the uncommon words. You may 
return the answer in any order.

EXAMPLES:
---------
Example 1:
  Input: s1 = "this apple is sweet", s2 = "this apple is sour"
  Output: ["sweet","sour"]
  Explanation: 
  "sweet" appears once in s1, zero times in s2.
  "sour" appears once in s2, zero times in s1.
  "this", "apple", "is" appear in both (or multiple times).

Example 2:
  Input: s1 = "apple apple", s2 = "banana"
  Output: ["banana"]
  Explanation:
  "apple" appears twice in s1.
  "banana" appears once in s2, zero times in s1.

CONSTRAINTS:
------------
- 1 <= s1.length, s2.length <= 200
- s1 and s2 consist of lowercase English letters and spaces.
- s1 and s2 do not have leading or trailing spaces.
- All the words in s1 and s2 are separated by a single space.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Understanding definition of "uncommon"
2. Efficiently counting words
3. Handling multiple occurrences in same sentence

ALGORITHM STEPS:
----------------
Approach 1: Combined Frequency Count (O(n+m)) ✓ OPTIMAL
1. Concatenate s1 and s2 with a space.
2. Split into a list of words.
3. Count frequency of every word.
4. Return words that have a count of exactly 1.

Why this works:
- If a word appears once in s1 and zero in s2 -> Total count = 1.
- If a word appears once in s2 and zero in s1 -> Total count = 1.
- If a word appears in both -> Total count >= 2.
- If a word appears twice in s1 -> Total count >= 2.
- So, "uncommon" is equivalent to "appears exactly once in combined text".

Approach 2: Separate Counts (As in provided code)
1. Count words in s1.
2. Count words in s2.
3. Check words in s1: countA[w] == 1 AND countB[w] == 0.
4. Check words in s2: countB[w] == 1 AND countA[w] == 0.


DETAILED EXPLANATION:
---------------------

Example: s1="apple apple", s2="banana"
--------------------------------------
Combined: "apple apple banana"
Counts:
  apple: 2
  banana: 1

Result: ["banana"]

Example: s1="this apple is sweet", s2="this apple is sour"
----------------------------------------------------------
Combined: "this apple is sweet this apple is sour"
Counts:
  this: 2
  apple: 2
  is: 2
  sweet: 1
  sour: 1

Result: ["sweet", "sour"]


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Combined Counting ✓ RECOMMENDED
from collections import Counter

class Solution:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        # Combine and split
        words = s1.split() + s2.split()
        
        # Count frequencies
        counts = Counter(words)
        
        # Filter words with count 1
        return [word for word, count in counts.items() if count == 1]


# Approach 2: Separate Counting (More verbose)
class SolutionSeparate:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        count1 = Counter(s1.split())
        count2 = Counter(s2.split())
        
        res = []
        
        # Words unique to s1
        for word in count1:
            if count1[word] == 1 and word not in count2:
                res.append(word)
                
        # Words unique to s2
        for word in count2:
            if count2[word] == 1 and word not in count1:
                res.append(word)
                
        return res


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n + m)
  - n, m are lengths of s1, s2.
  - Splitting takes O(n + m).
  - Counting takes O(n + m).
  - Filtering takes O(number of words).
  - Total: O(n + m).

Space Complexity: O(n + m)
  - Store all words in list and hash map.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: s1 = "this apple is sweet", s2 = "this apple is sour"
  Output: ["sweet","sour"]
  ✓ Correct

Test Case 2: Duplicates in One
  Input: s1 = "apple apple", s2 = "banana"
  Output: ["banana"]
  ✓ apple excluded (count 2)

Test Case 3: Overlap
  Input: s1 = "apple", s2 = "apple"
  Output: []
  ✓ apple excluded (count 2 total)

Test Case 4: Empty (Constraints say length >= 1, but good to know)
  Input: s1 = "a", s2 = "b"
  Output: ["a", "b"]
  ✓ Both unique


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Combined Counting ✓ RECOMMENDED
-------------------------------------------
Pros:
  - Very concise (3 lines).
  - Efficient.

Cons:
  - Creates a new list of all words.

Approach 2: Single Hash Map
---------------------------
Iterate s1, add to map. Iterate s2, add to map.
Same as Approach 1 but manual iteration.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Misunderstanding "Uncommon"
   ❌ Thinking it means "not in the other sentence" (ignoring duplicates in self)
   ✓ Must appear exactly once TOTAL.

2. String Concatenation
   ❌ s1 + s2 (might merge words if no space)
   ✓ s1 + " " + s2 OR s1.split() + s2.split()

3. Case Sensitivity
   ✓ Problem says lowercase only, so no need to handle case.


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Uncommon" definition simplifies to "frequency == 1 in combined text".
2. `Counter` is very useful for frequency problems.
3. String splitting and list combination is efficient in Python.
4. Time O(n+m), Space O(n+m).


================================================================================
RELATED PROBLEMS
================================================================================

- First Unique Character in a String (Easy)
- Intersection of Two Arrays (Easy)
- Find All Duplicates in an Array (Medium)
- Top K Frequent Elements (Medium)


================================================================================
