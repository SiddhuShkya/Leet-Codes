================================================================================
CONTAINS DUPLICATE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums, return true if any value appears at least twice 
in the array, and return false if every element is distinct.

EXAMPLES:
---------
Example 1:
  Input: nums = [1,2,3,1]
  Output: true

Example 2:
  Input: nums = [1,2,3,4]
  Output: false

Example 3:
  Input: nums = [1,1,1,3,3,4,3,2,4,2]
  Output: true

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Detecting duplicates efficiently
2. Avoiding O(n²) brute force comparison
3. Choosing optimal data structure
4. Handling large arrays (up to 10^5 elements)

ALGORITHM STEPS:
----------------
Approach 1: Using Set (Optimal)
1. Convert array to set
2. Compare lengths of set and array
3. If lengths differ, duplicates exist
4. Return true if different, false if same

Approach 2: Using Hash Set (Iterative)
1. Create empty hash set
2. For each element in array:
   a. If element in set, return true (duplicate found)
   b. Otherwise, add element to set
3. If loop completes, return false (no duplicates)

Approach 3: Sorting (Alternative)
1. Sort the array
2. Check adjacent elements
3. If any adjacent pair is equal, return true
4. Otherwise return false


DETAILED EXPLANATION:
---------------------

Why Set Works:
--------------
A set only stores unique elements. If the array has duplicates, the set will
have fewer elements than the array.

Example: nums = [1, 7, 3, 9, 2, 3]
  - Array length: 6
  - Set: {1, 2, 3, 7, 9}
  - Set length: 5
  - 6 != 5 → duplicates exist → return true

Set Approach Walkthrough:
--------------------------
nums = [1, 2, 3, 1]
  - set(nums) = {1, 2, 3}
  - len(set(nums)) = 3
  - len(nums) = 4
  - 3 != 4 → return true

nums = [1, 2, 3, 4]
  - set(nums) = {1, 2, 3, 4}
  - len(set(nums)) = 4
  - len(nums) = 4
  - 4 == 4 → return false

Hash Set Iterative Approach:
-----------------------------
Can short-circuit as soon as duplicate is found.

nums = [1, 2, 3, 1]
  - i=0: 1 not in set, add 1, set = {1}
  - i=1: 2 not in set, add 2, set = {1, 2}
  - i=2: 3 not in set, add 3, set = {1, 2, 3}
  - i=3: 1 IS in set → return true immediately


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Set Comparison - Most Concise
def containsDuplicate(nums):
    s = set(nums)
    if len(s) != len(nums):
        return True
    return False

# Even more concise
def containsDuplicate_v2(nums):
    return len(set(nums)) != len(nums)


# Approach 2: Hash Set Iterative - Can Short-Circuit
def containsDuplicate_iterative(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False


# Approach 3: Sorting
def containsDuplicate_sort(nums):
    nums.sort()
    for i in range(len(nums) - 1):
        if nums[i] == nums[i + 1]:
            return True
    return False


# LeetCode Solution Class Format
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Set Comparison
---------------------------
Time Complexity: O(n)
  - Converting to set: O(n)
  - Length comparison: O(1)
  - Total: O(n)

Space Complexity: O(n)
  - Set stores up to n unique elements
  - Total: O(n)

Approach 2: Hash Set Iterative
-------------------------------
Time Complexity: O(n)
  - Worst case: iterate through all elements
  - Best case: O(1) if duplicate is first two elements
  - Average: O(n)

Space Complexity: O(n)
  - Hash set stores up to n elements
  - Total: O(n)

Approach 3: Sorting
-------------------
Time Complexity: O(n log n)
  - Sorting: O(n log n)
  - Checking adjacent: O(n)
  - Total: O(n log n)

Space Complexity: O(1) or O(n)
  - Depends on sorting algorithm
  - In-place sort: O(1)
  - Python's sort: O(n) worst case


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Has Duplicates
  Input: nums = [1,2,3,1]
  Output: true
  ✓ Duplicate found (1 appears twice)

Test Case 2: No Duplicates
  Input: nums = [1,2,3,4]
  Output: false
  ✓ All elements unique

Test Case 3: Multiple Duplicates
  Input: nums = [1,1,1,3,3,4,3,2,4,2]
  Output: true
  ✓ Multiple duplicates exist

Test Case 4: Single Element
  Input: nums = [1]
  Output: false
  ✓ Cannot have duplicates with one element

Test Case 5: All Same
  Input: nums = [5,5,5,5,5]
  Output: true
  ✓ All elements are duplicates


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Set Comparison ✓ RECOMMENDED
-----------------------------------------
Convert to set and compare lengths.

Pros:
  - Most concise (one-liner possible)
  - O(n) time complexity
  - Very readable
  - Pythonic

Cons:
  - O(n) space complexity
  - Cannot short-circuit early
  - Must process entire array

Approach 2: Hash Set Iterative
-------------------------------
Iterate and check for duplicates.

Pros:
  - Can short-circuit on first duplicate
  - O(n) time complexity
  - Better for arrays with early duplicates

Cons:
  - Slightly more code
  - O(n) space complexity
  - Same worst-case as approach 1

Approach 3: Sorting
-------------------
Sort and check adjacent elements.

Pros:
  - Can be O(1) space with in-place sort
  - Simple logic after sorting

Cons:
  - O(n log n) time complexity
  - Slower than hash set approaches
  - Modifies original array (unless copied)


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using Nested Loops (Brute Force)
   ❌ O(n²) time complexity
   ✓ Use set for O(n) solution

2. Not Considering Space Complexity
   ❌ Ignoring O(n) space usage
   ✓ Be aware of trade-offs

3. Modifying Original Array
   ❌ Sorting in-place without copying
   ✓ Copy array if original must be preserved

4. Incorrect Set Usage
   ❌ Creating set but not using it properly
   ✓ Compare lengths or iterate with membership check

5. Edge Case - Single Element
   ❌ Not handling arrays with one element
   ✓ Single element cannot have duplicates


================================================================================
KEY TAKEAWAYS
================================================================================

1. Sets provide O(1) average lookup time for duplicate detection
2. Set length comparison is the most concise solution
3. Hash set iteration can short-circuit early
4. Sorting is slower (O(n log n)) but uses less space
5. Trade-off: time vs space complexity
6. Python's set() is highly optimized for this use case


================================================================================
RELATED PROBLEMS
================================================================================

- Contains Duplicate II (Easy) - Duplicates within k distance
- Contains Duplicate III (Hard) - Duplicates within value range
- Find All Duplicates in an Array (Medium) - Find all duplicates
- Single Number (Easy) - Find the non-duplicate
- Intersection of Two Arrays (Easy) - Set operations
- Valid Sudoku (Medium) - Duplicate detection in grid


================================================================================
