================================================================================
SEARCH INSERT POSITION - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given a sorted array of distinct integers and a target value, return the index 
if the target is found. If not, return the index where it would be if it were 
inserted in order.

You must write an algorithm with O(log n) runtime complexity.

EXAMPLES:
---------
Example 1:
  Input: nums = [1,3,5,6], target = 5
  Output: 2

Example 2:
  Input: nums = [1,3,5,6], target = 2
  Output: 1

Example 3:
  Input: nums = [1,3,5,6], target = 7
  Output: 4

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^4
- -10^4 <= nums[i] <= 10^4
- nums contains distinct values sorted in ascending order
- -10^4 <= target <= 10^4


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Achieving O(log n) time complexity
2. Finding exact position for insertion
3. Handling edge cases (target smaller/larger than all elements)
4. Binary search implementation

ALGORITHM STEPS:
----------------
Binary Search Approach:
1. Initialize left = 0, right = len(nums) - 1
2. While left <= right:
   a. Calculate mid = (left + right) // 2
   b. If nums[mid] == target, return mid
   c. If nums[mid] < target, search right half (left = mid + 1)
   d. If nums[mid] > target, search left half (right = mid - 1)
3. If not found, return left (insertion position)


DETAILED EXPLANATION:
---------------------

Why Binary Search:
------------------
Array is sorted, so we can eliminate half the search space each iteration.
This gives us O(log n) time complexity.

Key Insight:
------------
When binary search doesn't find the target, the `left` pointer ends up at 
the exact position where the target should be inserted to maintain sorted order.

Binary Search Walkthrough: nums = [1,3,5,6], target = 2
---------------------------------------------------------
Initial: left=0, right=3
  nums = [1,3,5,6]

Iteration 1:
  mid = (0 + 3) // 2 = 1
  nums[1] = 3
  3 > 2, so search left half
  right = mid - 1 = 0

Iteration 2:
  left=0, right=0
  mid = (0 + 0) // 2 = 0
  nums[0] = 1
  1 < 2, so search right half
  left = mid + 1 = 1

Loop ends (left > right)
Return left = 1

Verification: Insert 2 at index 1 → [1,2,3,5,6] ✓

Why `left` is the Insert Position:
-----------------------------------
When loop ends:
- All elements to left of `left` are < target
- All elements to right of `left` are > target
- Therefore, `left` is exactly where target should go

Example: nums = [1,3,5,6], target = 7
--------------------------------------
Binary search ends with left = 4 (after last element)
Insert 7 at index 4 → [1,3,5,6,7] ✓


================================================================================
CODE IMPLEMENTATION
================================================================================

# Binary Search ✓ OPTIMAL
def searchInsert(nums, target):
    low_idx = 0
    high_idx = len(nums) - 1
    
    while low_idx <= high_idx:
        mid_idx = (high_idx + low_idx) // 2
        
        if nums[mid_idx] == target:
            return mid_idx
        elif nums[mid_idx] < target:
            low_idx = mid_idx + 1
        else:
            high_idx = mid_idx - 1
    
    return low_idx


# Alternative: More explicit
def searchInsert_v2(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    # Target not found, left is insertion position
    return left


# Using Python's bisect module (built-in binary search)
import bisect

def searchInsert_bisect(nums, target):
    return bisect.bisect_left(nums, target)


# LeetCode Solution Class Format
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Binary Search Approach
----------------------
Time Complexity: O(log n)
  - Each iteration eliminates half the search space
  - Maximum iterations: log₂(n)
  - Total: O(log n) ✓ MEETS REQUIREMENT

Space Complexity: O(1)
  - Only using a few pointer variables
  - No recursion or extra data structures
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Target Found
  Input: nums = [1,3,5,6], target = 5
  Output: 2
  ✓ Target exists at index 2

Test Case 2: Insert in Middle
  Input: nums = [1,3,5,6], target = 2
  Output: 1
  ✓ Should insert at index 1

Test Case 3: Insert at End
  Input: nums = [1,3,5,6], target = 7
  Output: 4
  ✓ Larger than all elements

Test Case 4: Insert at Beginning
  Input: nums = [1,3,5,6], target = 0
  Output: 0
  ✓ Smaller than all elements

Test Case 5: Single Element - Found
  Input: nums = [1], target = 1
  Output: 0
  ✓ Single element match

Test Case 6: Single Element - Not Found
  Input: nums = [1], target = 2
  Output: 1
  ✓ Insert after single element


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Binary Search ✓ RECOMMENDED
----------------------------------------
Use binary search to find target or insertion position.

Pros:
  - O(log n) time complexity
  - Meets problem requirement
  - Optimal solution
  - O(1) space

Cons:
  - Requires understanding of binary search

Approach 2: Linear Search (Not Acceptable)
-------------------------------------------
Iterate through array to find position.

Pros:
  - Simple to implement
  - Easy to understand

Cons:
  - O(n) time complexity
  - Doesn't meet O(log n) requirement
  - Not acceptable for this problem

Approach 3: Built-in bisect
----------------------------
Use Python's bisect.bisect_left().

Pros:
  - One-liner solution
  - Optimized implementation

Cons:
  - Not demonstrating understanding
  - Not acceptable in interviews


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using Linear Search
   ❌ O(n) time doesn't meet requirement
   ✓ Use binary search for O(log n)

2. Wrong Mid Calculation
   ❌ mid = (left + right) / 2 (float division)
   ✓ mid = (left + right) // 2 (integer division)

3. Infinite Loop
   ❌ Not updating left or right properly
   ✓ Ensure left = mid + 1 or right = mid - 1

4. Wrong Return Value
   ❌ Returning right or mid when not found
   ✓ Return left (insertion position)

5. Off-by-One Errors
   ❌ Wrong loop condition or pointer updates
   ✓ Use left <= right and update correctly


================================================================================
KEY TAKEAWAYS
================================================================================

1. Binary search is required for O(log n) complexity
2. Sorted array enables binary search
3. When target not found, `left` is insertion position
4. Binary search eliminates half the search space each iteration
5. Template: while left <= right, return left
6. Understanding why `left` is correct is crucial


================================================================================
RELATED PROBLEMS
================================================================================

- Binary Search (Easy) - Basic binary search
- First Bad Version (Easy) - Binary search variant
- Search in Rotated Sorted Array (Medium) - Modified binary search
- Find First and Last Position (Medium) - Binary search bounds
- Search a 2D Matrix (Medium) - 2D binary search
- Sqrt(x) (Easy) - Binary search application


================================================================================
