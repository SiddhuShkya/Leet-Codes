================================================================================
VALID PALINDROME - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
A phrase is a palindrome if, after converting all uppercase letters into 
lowercase letters and removing all non-alphanumeric characters, it reads the 
same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

EXAMPLES:
---------
Example 1:
  Input: s = "A man, a plan, a canal: Panama"
  Output: true
  Explanation: "amanaplanacanalpanama" is a palindrome.

Example 2:
  Input: s = "race a car"
  Output: false
  Explanation: "raceacar" is not a palindrome.

Example 3:
  Input: s = " "
  Output: true
  Explanation: s is an empty string "" after removing non-alphanumeric 
  characters. Since an empty string reads the same forward and backward, it 
  is a palindrome.

CONSTRAINTS:
------------
- 1 <= s.length <= 2 * 10^5
- s consists only of printable ASCII characters


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Filtering non-alphanumeric characters
2. Case-insensitive comparison
3. Checking palindrome efficiently
4. Handling empty strings and spaces

ALGORITHM STEPS:
----------------
Approach 1: Clean and Compare
1. Convert to lowercase
2. Filter only alphanumeric characters
3. Compare string with its reverse

Approach 2: Two Pointers (Optimal)
1. Use left and right pointers
2. Skip non-alphanumeric characters
3. Compare characters (case-insensitive)
4. Move pointers inward


DETAILED EXPLANATION:
---------------------

Clean and Compare Approach:
---------------------------
1. Convert to lowercase: "A man..." → "a man..."
2. Keep only alphanumeric: "amanaplanacanalpanama"
3. Reverse and compare

Example: s = "A man, a plan, a canal: Panama"
  - Lowercase: "a man, a plan, a canal: panama"
  - Alphanumeric only: "amanaplanacanalpanama"
  - Reverse: "amanaplanacanalpanama"
  - Equal? Yes → palindrome!

Two Pointers Approach:
----------------------
More space-efficient - no new string created.

Example: s = "race a car"
  - left=0 ('r'), right=9 ('r')
  - Skip spaces and non-alphanumeric
  - Compare: 'r' == 'r' ✓
  - Continue...
  - Eventually: 'e' != 'c' ✗
  - Not palindrome

Why Two Pointers is Better:
----------------------------
- O(1) space (no new string)
- Can short-circuit on first mismatch
- More efficient for large strings


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Clean and Compare
def isPalindrome_clean(s):
    # Convert to lowercase
    s = s.lower()
    
    # Filter alphanumeric characters
    cleaned = ''
    for char in s:
        if char.isalnum():
            cleaned += char
    
    # Compare with reverse
    return cleaned == cleaned[::-1]


# More Pythonic version
def isPalindrome_pythonic(s):
    cleaned = ''.join(c.lower() for c in s if c.isalnum())
    return cleaned == cleaned[::-1]


# From original code
def isPalindrome_original(s):
    s = s.lower()
    letterList = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
                  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    numList = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']
    newStr = ''
    for char in s:
        if char in letterList or char in numList:
            newStr += char
    if newStr == newStr[::-1]:
        return True
    return False


# Approach 2: Two Pointers ✓ OPTIMAL
def isPalindrome_twopointers(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True


# LeetCode Solution Class Format
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            
            if s[left].lower() != s[right].lower():
                return False
            
            left += 1
            right -= 1
        
        return True


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Clean and Compare
------------------------------
Time Complexity: O(n)
  - Convert to lowercase: O(n)
  - Filter alphanumeric: O(n)
  - Reverse and compare: O(n)
  - Total: O(n)

Space Complexity: O(n)
  - Cleaned string: O(n)
  - Reversed string: O(n)
  - Total: O(n)

Approach 2: Two Pointers
-------------------------
Time Complexity: O(n)
  - Single pass with two pointers
  - Each character examined at most once
  - Total: O(n)

Space Complexity: O(1)
  - Only using two pointer variables
  - No extra strings created
  - Total: O(1) ✓ OPTIMAL


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Valid Palindrome with Punctuation
  Input: s = "A man, a plan, a canal: Panama"
  Output: true
  ✓ Ignores punctuation and case

Test Case 2: Not a Palindrome
  Input: s = "race a car"
  Output: false
  ✓ "raceacar" != "racaecar"

Test Case 3: Empty After Cleaning
  Input: s = " "
  Output: true
  ✓ Empty string is palindrome

Test Case 4: Simple Palindrome
  Input: s = "racecar"
  Output: true
  ✓ Simple case

Test Case 5: With Numbers
  Input: s = "A1b2B1a"
  Output: true
  ✓ "a1b2b1a" is palindrome

Test Case 6: Single Character
  Input: s = "a"
  Output: true
  ✓ Single character is palindrome


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Clean and Compare
------------------------------
Filter characters, then compare with reverse.

Pros:
  - Simple and intuitive
  - Easy to understand
  - Pythonic with list comprehension

Cons:
  - O(n) extra space
  - Creates multiple strings
  - Less efficient

Approach 2: Two Pointers ✓ RECOMMENDED
---------------------------------------
Compare from both ends simultaneously.

Pros:
  - O(n) time, O(1) space
  - Most efficient
  - Can short-circuit early
  - No extra strings

Cons:
  - Slightly more complex
  - Need to handle skipping logic


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Case
   ❌ Comparing 'A' and 'a' as different
   ✓ Convert to lowercase or use .lower()

2. Not Filtering Non-Alphanumeric
   ❌ Including spaces and punctuation
   ✓ Use isalnum() to filter

3. Creating Hardcoded Character Lists
   ❌ Manually listing all letters/numbers
   ✓ Use built-in isalnum() method

4. Not Handling Empty String
   ❌ Special casing empty strings
   ✓ Algorithm handles naturally

5. Inefficient String Building
   ❌ Using += in loop (O(n²) in some languages)
   ✓ Use join() or two pointers


================================================================================
KEY TAKEAWAYS
================================================================================

1. Two pointers provide O(1) space solution
2. isalnum() checks if character is alphanumeric
3. Case-insensitive comparison requires .lower()
4. Empty string is considered a palindrome
5. Can short-circuit on first mismatch
6. Python's string methods simplify filtering


================================================================================
RELATED PROBLEMS
================================================================================

- Palindrome Number (Easy) - Number palindrome
- Valid Palindrome II (Easy) - Allow one deletion
- Longest Palindromic Substring (Medium) - Find longest palindrome
- Palindrome Linked List (Easy) - Linked list version
- Palindrome Partitioning (Medium) - Partition into palindromes
- Shortest Palindrome (Hard) - Make shortest palindrome


================================================================================
