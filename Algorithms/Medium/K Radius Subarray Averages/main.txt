================================================================================
K RADIUS SUBARRAY AVERAGES - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You are given a 0-indexed array nums of n integers, and an integer k.

The k-radius average for a subarray of nums centered at some index i with the 
radius k is the average of all elements in nums between the indices i - k and 
i + k (inclusive). If there are less than k elements before or after the index 
i, then the k-radius average is -1.

Build and return an array avgs of length n where avgs[i] is the k-radius average 
for the subarray centered at index i.

The average of x elements is the sum of the x elements divided by x, using 
integer division. The integer division truncates toward zero, which means losing 
its fractional part.

EXAMPLES:
---------
Example 1:
  Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
  Output: [-1,-1,-1,5,4,4,-1,-1,-1]
  Explanation:
  - avg[0], avg[1], avg[2]: Less than k elements before. -1.
  - avg[3]: Range [0, 6] (7+4+3+9+1+8+5) / 7 = 37 / 7 = 5.
  - avg[4]: Range [1, 7] (4+3+9+1+8+5+2) / 7 = 32 / 7 = 4.
  - avg[5]: Range [2, 8] (3+9+1+8+5+2+6) / 7 = 34 / 7 = 4.
  - avg[6], avg[7], avg[8]: Less than k elements after. -1.

Example 2:
  Input: nums = [100000], k = 0
  Output: [100000]

Example 3:
  Input: nums = [8], k = 100000
  Output: [-1]

CONSTRAINTS:
------------
- n == nums.length
- 1 <= n <= 10^5
- 0 <= nums[i], k <= 10^5


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Calculating sum of range efficiently (avoid O(n*k))
2. Handling boundaries (indices < k or > n-k-1)
3. Integer division

ALGORITHM STEPS:
----------------
Approach 1: Sliding Window (O(n)) ✓ OPTIMAL
1. Initialize result array `avgs` with -1s.
2. Window size `window_len = 2 * k + 1`.
3. If `n < window_len`, return all -1s.
4. Calculate sum of first window (indices 0 to 2k).
5. Set `avgs[k]` = `sum // window_len`.
6. Slide window from `i = k + 1` to `n - k - 1`:
   - Subtract `nums[i - k - 1]` (element leaving window).
   - Add `nums[i + k]` (element entering window).
   - Set `avgs[i]` = `new_sum // window_len`.
7. Return `avgs`.

Approach 2: Prefix Sum (O(n))
1. Compute prefix sum array `P`.
2. Sum of range [i-k, i+k] = `P[i+k+1] - P[i-k]`.
3. Iterate and fill `avgs`.


DETAILED EXPLANATION:
---------------------

Sliding Window Logic:
---------------------
Nums: [7, 4, 3, 9, 1, 8, 5, 2, 6], k=3
Window Size = 7.

1. Initial Window [0..6]: [7,4,3,9,1,8,5]. Sum = 37.
   Center is index 3. avgs[3] = 37 // 7 = 5.

2. Slide to Center 4 (Window [1..7]):
   Remove nums[0] (7). Add nums[7] (2).
   Sum = 37 - 7 + 2 = 32.
   avgs[4] = 32 // 7 = 4.

3. Slide to Center 5 (Window [2..8]):
   Remove nums[1] (4). Add nums[8] (6).
   Sum = 32 - 4 + 6 = 34.
   avgs[5] = 34 // 7 = 4.

Indices 0,1,2 and 6,7,8 remain -1.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Sliding Window (Optimal) ✓ RECOMMENDED
class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        window_len = 2 * k + 1
        avgs = [-1] * n
        
        if n < window_len:
            return avgs
            
        # Initial window sum
        window_sum = sum(nums[:window_len])
        avgs[k] = window_sum // window_len
        
        # Slide window
        # Center starts at k+1, goes up to n-k-1
        for i in range(k + 1, n - k):
            # Remove element at i - k - 1 (leftmost of previous window)
            # Add element at i + k (rightmost of new window)
            window_sum = window_sum - nums[i - k - 1] + nums[i + k]
            avgs[i] = window_sum // window_len
            
        return avgs


# Approach 2: Prefix Sum
class SolutionPrefix:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        avgs = [-1] * n
        window_len = 2 * k + 1
        
        if n < window_len:
            return avgs
            
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
            
        for i in range(k, n - k):
            left = i - k
            right = i + k
            total = prefix[right + 1] - prefix[left]
            avgs[i] = total // window_len
            
        return avgs


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n)
  - Single pass to compute sums.

Space Complexity: O(1) (Sliding Window) or O(n) (Prefix Sum)
  - Sliding window only stores current sum.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: [7,4,3,9,1,8,5,2,6], k=3
  Output: [-1,-1,-1,5,4,4,-1,-1,-1]
  ✓ Correct

Test Case 2: k=0
  Input: [10], k=0
  Output: [10]
  ✓ Window size 1. Average is element itself.

Test Case 3: Array shorter than window
  Input: [8], k=10
  Output: [-1]
  ✓ Correct

Test Case 4: Exact fit
  Input: [1,2,3], k=1
  Output: [-1, 2, -1]
  ✓ Center at 1 valid.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Sliding Window ✓ RECOMMENDED
----------------------------------------
Pros:
  - O(1) extra space.
  - Very fast.

Cons:
  - None.

Approach 2: Prefix Sum
----------------------
Pros:
  - Easy to query any range.

Cons:
  - O(n) extra space.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Index Out of Bounds
   ❌ Accessing nums[i+k] without checking loop bounds
   ✓ Loop range `range(k + 1, n - k)` ensures safety.

2. Window Size Calculation
   ❌ k elements
   ✓ 2*k + 1 elements (k left + center + k right).

3. Integer Division
   ✓ Use `//` in Python.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Sliding Window is ideal for fixed-size subarray problems.
2. Update sum in O(1) by subtracting leaving element and adding entering element.
3. Time O(n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Maximum Average Subarray I (Easy)
- Moving Average from Data Stream (Easy)
- Minimum Size Subarray Sum (Medium)


================================================================================
