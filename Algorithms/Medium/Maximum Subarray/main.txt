================================================================================
MAXIMUM SUBARRAY - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums, find the subarray with the largest sum, and return 
its sum.

EXAMPLES:
---------
Example 1:
  Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
  Output: 6
  Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:
  Input: nums = [1]
  Output: 1
  Explanation: The subarray [1] has the largest sum 1.

Example 3:
  Input: nums = [5,4,-1,7,8]
  Output: 23
  Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Handling negative numbers
2. Achieving O(N) time complexity
3. Recognizing the "reset" condition

ALGORITHM STEPS:
----------------
Approach 1: Kadane's Algorithm (O(N)) ✓ OPTIMAL
1. Iterate through the array.
2. Maintain `current_sum` and `max_sum`.
3. Add `num` to `current_sum`.
4. Update `max_sum = max(max_sum, current_sum)`.
5. If `current_sum < 0`, reset `current_sum = 0`.
   - Why? Because a negative prefix will never help maximize a future subarray sum. 
     Better to start fresh from the next element.

Approach 2: Divide and Conquer (O(N log N))
1. Split array into left and right halves.
2. Max sum is max of:
   - Max sum in left half.
   - Max sum in right half.
   - Max sum crossing the midpoint.


DETAILED EXPLANATION:
---------------------

Kadane's Trace: [-2, 1, -3, 4, -1, 2, 1, -5, 4]

1. Num -2. Cur -2. Max -2.
   Cur < 0 -> Reset Cur to 0.
2. Num 1. Cur 1. Max 1.
3. Num -3. Cur -2. Max 1.
   Cur < 0 -> Reset Cur to 0.
4. Num 4. Cur 4. Max 4.
5. Num -1. Cur 3. Max 4.
6. Num 2. Cur 5. Max 5.
7. Num 1. Cur 6. Max 6.
8. Num -5. Cur 1. Max 6.
9. Num 4. Cur 5. Max 6.

Result: 6.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Kadane's Algorithm (Optimal) ✓ RECOMMENDED
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum = nums[0]
        curr_sum = 0
        
        for num in nums:
            if curr_sum < 0:
                curr_sum = 0
            curr_sum += num
            max_sum = max(max_sum, curr_sum)
            
        return max_sum


# Approach 2: Dynamic Programming (Explicit Array)
class SolutionDP:
    def maxSubArray(self, nums: List[int]) -> int:
        # dp[i] = max sum ending at index i
        dp = [0] * len(nums)
        dp[0] = nums[0]
        max_sum = dp[0]
        
        for i in range(1, len(nums)):
            # Either extend previous subarray or start new
            dp[i] = max(nums[i], nums[i] + dp[i-1])
            max_sum = max(max_sum, dp[i])
            
        return max_sum


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N)
  - Single pass.

Space Complexity: O(1)
  - Only variables.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Mixed
  Input: [-2,1,-3,4,-1,2,1,-5,4]
  Output: 6
  ✓ Correct

Test Case 2: All Negative
  Input: [-5, -2, -9]
  Output: -2
  ✓ Kadane's handles this (max_sum initialized to nums[0], not 0).

Test Case 3: All Positive
  Input: [1, 2, 3]
  Output: 6
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Kadane's ✓ RECOMMENDED
----------------------------------
Pros:
  - O(N) time, O(1) space.
  - Standard solution.

Cons:
  - None.

Approach 2: Divide and Conquer
------------------------------
Pros:
  - Good for parallel processing.

Cons:
  - O(N log N) is slower.
  - More complex implementation.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Initialization
   ❌ max_sum = 0
   ✓ max_sum = nums[0] (Handle all negative array)

2. Reset Logic
   ❌ Resetting `max_sum`
   ✓ Only reset `curr_sum` when it drops below zero.

3. Empty Array
   ✓ Constraints say length >= 1.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Kadane's Algorithm is the standard for Max Subarray.
2. "Negative prefix is useless".
3. Time O(N), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Maximum Product Subarray (Medium)
- Longest Turbulen Subarray (Medium)
- Maximum Sum Circular Subarray (Medium)


================================================================================
