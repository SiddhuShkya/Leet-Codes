Multiply Strings
Difficulty: Medium
Topics: Math, String, Simulation
================================================================================

PROBLEM STATEMENT
================================================================================
Given two non-negative integers num1 and num2 represented as strings, return the 
product of num1 and num2, also represented as a string.

Note: You must not use any built-in BigInteger library or convert the inputs to 
integer directly.

Example 1:
Input: num1 = "2", num2 = "3"
Output: "6"

Example 2:
Input: num1 = "123", num2 = "456"
Output: "56088"

Constraints:
- 1 <= num1.length, num2.length <= 200
- num1 and num2 consist of digits only.
- Both num1 and num2 do not contain any leading zero, except the number 0 itself.

SOLUTION APPROACHES
================================================================================

Approach 1: Elementary Math (Schoolbook Multiplication)
--------------------------------------------------------------------------------
Simulate the manual multiplication process we do on paper. Multiply each digit 
of num2 with each digit of num1, adding the results to the correct positions 
in an array.

Time Complexity: O(M * N) where M and N are lengths of the strings.
Space Complexity: O(M + N) for the result array.

def multiply(num1: str, num2: str) -> str:
    if num1 == "0" or num2 == "0":
        return "0"
    
    m, n = len(num1), len(num2)
    # Result can be at most m + n digits
    pos = [0] * (m + n)
    
    # Multiply each digit from right to left
    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            mul = int(num1[i]) * int(num2[j])
            p1, p2 = i + j, i + j + 1
            
            # Add to current position including previous carry
            total = mul + pos[p2]
            
            pos[p1] += total // 10  # Carry to p1
            pos[p2] = total % 10    # Remainder to p2
            
    # Convert result array to string, skipping leading zeros
    res = "".join(map(str, pos))
    return res.lstrip('0') if not res.startswith('0') else res

Approach 2: Naive Conversion (Python Specific)
--------------------------------------------------------------------------------
Although the problem forbids direct conversion, in Python, integers have 
arbitrary precision, so this works but defeats the purpose of the algorithmic 
challenge.

Time Complexity: O(M * N) (Python's int conversion and multiplication)
Space Complexity: O(M + N)

def multiply_naive(num1: str, num2: str) -> str:
    return str(int(num1) * int(num2))

DETAILED WALKTHROUGH
================================================================================
Let's trace Approach 1 with num1 = "123", num2 = "45"

1. Initialization:
   m=3, n=2. pos array of size 5: [0, 0, 0, 0, 0]

2. Outer Loop i=2 ('3'), Inner Loop j=1 ('5'):
   mul = 3 * 5 = 15
   p1=3, p2=4
   total = 15 + pos[4] (0) = 15
   pos[3] += 1 -> [0, 0, 0, 1, 0]
   pos[4] = 5  -> [0, 0, 0, 1, 5]

3. Outer Loop i=2 ('3'), Inner Loop j=0 ('4'):
   mul = 3 * 4 = 12
   p1=2, p2=3
   total = 12 + pos[3] (1) = 13
   pos[2] += 1 -> [0, 0, 1, 1, 5]
   pos[3] = 3  -> [0, 0, 1, 3, 5]

4. Outer Loop i=1 ('2'), Inner Loop j=1 ('5'):
   mul = 2 * 5 = 10
   p1=2, p2=3
   total = 10 + pos[3] (3) = 13
   pos[2] += 1 -> [0, 0, 2, 3, 5]
   pos[3] = 3  -> [0, 0, 2, 3, 5]

5. Outer Loop i=1 ('2'), Inner Loop j=0 ('4'):
   mul = 2 * 4 = 8
   p1=1, p2=2
   total = 8 + pos[2] (2) = 10
   pos[1] += 1 -> [0, 1, 2, 3, 5]
   pos[2] = 0  -> [0, 1, 0, 3, 5]

6. Outer Loop i=0 ('1'), Inner Loop j=1 ('5'):
   mul = 1 * 5 = 5
   p1=1, p2=2
   total = 5 + pos[2] (0) = 5
   pos[1] += 0 -> [0, 1, 0, 3, 5]
   pos[2] = 5  -> [0, 1, 5, 3, 5]

7. Outer Loop i=0 ('1'), Inner Loop j=0 ('4'):
   mul = 1 * 4 = 4
   p1=0, p2=1
   total = 4 + pos[1] (1) = 5
   pos[0] += 0 -> [0, 1, 5, 3, 5]
   pos[1] = 5  -> [0, 5, 5, 3, 5]

Final pos array: [0, 5, 5, 3, 5]
Result string: "5535" (Correct: 123 * 45 = 5535)

KEY INSIGHTS
================================================================================
1. Result Length: The product of two numbers with lengths M and N will have a 
   length of at most M + N.
2. Index Mapping: When multiplying num1[i] and num2[j], the result contributes 
   to indices i + j and i + j + 1 in the result array.
3. Reverse Iteration: Processing from right to left simplifies carry handling, 
   mimicking manual calculation.
4. No BigInt: The core challenge is managing carries and additions manually 
   without relying on language-specific large integer support.

EDGE CASES
================================================================================
1. Zero Input:
   Input: num1 = "0", num2 = "123"
   Output: "0" (Handled by initial check)

2. Single Digit:
   Input: num1 = "2", num2 = "3"
   Output: "6"

3. Large Numbers:
   Input: num1 = "99", num2 = "99"
   Output: "9801" (Max carry propagation)

4. Identity:
   Input: num1 = "1", num2 = "456"
   Output: "456"

5. Leading Zeros (if not constrained):
   Input: num1 = "002", num2 = "3"
   Output: "6" (Standard implementation might need adjustment if this was valid)

OPTIMIZATION NOTES
================================================================================
- Karatsuba Algorithm: A divide-and-conquer algorithm that multiplies numbers 
  in O(N^1.585) time. It is faster for very large numbers (thousands of bits) 
  but more complex to implement and often slower for small inputs (N < 200) 
  due to recursion overhead.
- Base Optimization: Instead of base 10, we could process chunks of digits 
  (e.g., base 10^9) to reduce the number of operations, fitting chunks into 
  standard 64-bit integers.

RELATED PROBLEMS
================================================================================
1. Add Strings (Easy)
2. Plus One (Easy)
3. Add Binary (Easy)
4. Add Two Numbers (Medium) - Linked List version
5. Basic Calculator II (Medium)
