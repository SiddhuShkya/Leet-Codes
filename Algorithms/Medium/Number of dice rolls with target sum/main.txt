================================================================================
NUMBER OF DICE ROLLS WITH TARGET SUM - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You have n dice, and each die has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out 
of the k^n total ways) to roll the dice so the sum of the face-up numbers 
equals target. Since the answer may be too large, return it modulo 10^9 + 7.

EXAMPLES:
---------
Example 1:
  Input: n = 1, k = 6, target = 3
  Output: 1
  Explanation: You throw one die with 6 faces.
  There is only one way to get a sum of 3.

Example 2:
  Input: n = 2, k = 6, target = 7
  Output: 6
  Explanation: You throw two dice, each with 6 faces.
  There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.

Example 3:
  Input: n = 30, k = 30, target = 500
  Output: 222616187
  Explanation: The answer must be returned modulo 10^9 + 7.

CONSTRAINTS:
------------
- 1 <= n, k <= 30
- 1 <= target <= 1000


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Counting combinations with sum constraint
2. Avoiding exponential recursion
3. Handling modulo arithmetic

ALGORITHM STEPS:
----------------
Approach 1: Dynamic Programming (Bottom-Up) (O(n * target * k)) ✓ OPTIMAL
1. Define `dp[i][j]` as the number of ways to get sum `j` using `i` dice.
2. Base case: `dp[0][0] = 1` (0 dice, sum 0 is 1 way). All other `dp[0][j] = 0`.
3. Iterate `i` from 1 to `n` (number of dice).
4. Iterate `j` from 1 to `target` (current sum).
5. Iterate `face` from 1 to `k` (current die value).
   - If `j - face >= 0`:
     - `dp[i][j] += dp[i-1][j-face]`
     - `dp[i][j] %= MOD`
6. Return `dp[n][target]`.

Approach 2: Space Optimized DP (O(target * k))
1. Notice `dp[i][j]` only depends on `dp[i-1]`.
2. Use two rows: `prev` and `curr`.

Approach 3: Memoization (Top-Down)
1. `dfs(dice_left, current_target)`
2. Base cases:
   - `dice_left == 0 and current_target == 0`: return 1
   - `dice_left == 0 or current_target < 0`: return 0
3. Loop `f` from 1 to `k`:
   - `res += dfs(dice_left - 1, current_target - f)`
4. Cache result.


DETAILED EXPLANATION:
---------------------

Example: n=2, k=6, target=7
DP Table (Rows=Dice 0..2, Cols=Sum 0..7)

Row 0 (0 dice): [1, 0, 0, 0, 0, 0, 0, 0]

Row 1 (1 die):
- Sum 1: From Sum 0 + Face 1 -> 1 way.
- Sum 2: From Sum 0 + Face 2 -> 1 way.
...
- Sum 6: 1 way.
- Sum 7: 0 ways (Face > 6 impossible).

Row 2 (2 dice):
- Sum 7:
  - Face 1: Need Sum 6 from 1 die (1 way).
  - Face 2: Need Sum 5 from 1 die (1 way).
  ...
  - Face 6: Need Sum 1 from 1 die (1 way).
  - Total: 1+1+1+1+1+1 = 6 ways.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Bottom-Up DP (Optimal) ✓ RECOMMENDED
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        MOD = 10**9 + 7
        
        # dp[i][j] = ways to get sum j with i dice
        # Optimize: can use just 1D array or 2 rows
        dp = [0] * (target + 1)
        dp[0] = 1  # 0 dice, 0 sum
        
        for i in range(n): # For each die
            new_dp = [0] * (target + 1)
            for j in range(1, target + 1): # For each target sum
                # Try all faces 1 to k
                # Optimization: only iterate valid faces
                for face in range(1, min(k, j) + 1):
                    new_dp[j] = (new_dp[j] + dp[j - face]) % MOD
            dp = new_dp
            
        return dp[target]


# Approach 2: Top-Down Memoization
class SolutionMemo:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        MOD = 10**9 + 7
        memo = {}
        
        def dfs(dice_idx, curr_target):
            if dice_idx == n:
                return 1 if curr_target == 0 else 0
            if curr_target < 0:
                return 0
            
            state = (dice_idx, curr_target)
            if state in memo:
                return memo[state]
            
            ways = 0
            for face in range(1, k + 1):
                ways = (ways + dfs(dice_idx + 1, curr_target - face)) % MOD
            
            memo[state] = ways
            return ways
            
        return dfs(0, target)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n * target * k)
  - We fill a table of size n * target.
  - Each cell takes O(k) to compute.

Space Complexity: O(target) (Space Optimized) or O(n * target) (Table)
  - Storing DP states.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: n=1, k=6, target=3
  Output: 1
  ✓ Correct

Test Case 2: n=2, k=6, target=7
  Output: 6
  ✓ Correct

Test Case 3: Impossible Target
  Input: n=2, k=6, target=15
  Output: 0
  ✓ Max sum is 12. Correct.

Test Case 4: Large
  Input: n=30, k=30, target=500
  Output: 222616187
  ✓ Modulo arithmetic works.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Bottom-Up DP ✓ RECOMMENDED
--------------------------------------
Pros:
  - Iterative, no recursion overhead.
  - Easy to space optimize.

Cons:
  - O(n*target*k) can be slow if k is large (but k<=30 here).

Approach 2: Recursion + Memoization
-----------------------------------
Pros:
  - Intuitive translation of problem.

Cons:
  - Recursion depth limits.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Modulo Arithmetic
   ❌ `dp[j] += ...` without mod
   ✓ Apply `% MOD` at each addition to prevent overflow (in fixed-size int languages) and keep numbers small.

2. Loop Bounds
   ✓ `range(1, min(k, j) + 1)` ensures we don't subtract more than current sum `j`.

3. Base Case
   ✓ `dp[0] = 1` (0 sum with 0 dice is valid).


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Number of ways to get sum" is a classic Knapsack-like DP.
2. State: (Number of items used, Current Sum).
3. Time O(n*target*k), Space O(target).


================================================================================
RELATED PROBLEMS
================================================================================

- Coin Change II (Medium)
- Combination Sum IV (Medium)
- Target Sum (Medium)


================================================================================
