================================================================================
PERMUTATIONS II - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given a collection of numbers, nums, that might contain duplicates, return all 
possible unique permutations in any order.

EXAMPLES:
---------
Example 1:
  Input: nums = [1,1,2]
  Output:
  [[1,1,2],
   [1,2,1],
   [2,1,1]]

Example 2:
  Input: nums = [1,2,3]
  Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

CONSTRAINTS:
------------
- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Generating permutations
2. Handling duplicates to ensure uniqueness
3. Efficiency (avoiding generating duplicates then filtering)

ALGORITHM STEPS:
----------------
Approach 1: Backtracking with Counter (Hash Map) ✓ OPTIMAL
1. Count frequency of each number in `nums`.
2. Define a recursive function `backtrack(path)`:
   - If `len(path) == len(nums)`, we found a valid permutation. Add to result.
   - Iterate through unique numbers in the counter.
   - If `count[num] > 0`:
     - Add `num` to `path`.
     - Decrement `count[num]`.
     - Recurse: `backtrack(path)`.
     - Backtrack: Remove `num` from `path`, increment `count[num]`.

Approach 2: Backtracking with Sorting
1. Sort `nums`.
2. Use a `used` boolean array.
3. Iterate `i` from 0 to n-1.
4. If `used[i]` is true, skip.
5. If `i > 0` and `nums[i] == nums[i-1]` and `!used[i-1]`, skip.
   - This condition ensures we only use the first instance of a duplicate number 
     in a specific position, preventing duplicate permutations.
6. Mark `used[i]`, recurse, unmark.


DETAILED EXPLANATION:
---------------------

Counter Approach Logic:
-----------------------
Input: [1, 1, 2]
Counter: {1: 2, 2: 1}

1. Start (Empty path).
   - Try 1: Count{1:1, 2:1}. Path [1].
     - Try 1: Count{1:0, 2:1}. Path [1, 1].
       - Try 2: Count{1:0, 2:0}. Path [1, 1, 2]. DONE.
     - Try 2: Count{1:1, 2:0}. Path [1, 2].
       - Try 1: Count{1:0, 2:0}. Path [1, 2, 1]. DONE.
   - Try 2: Count{1:2, 2:0}. Path [2].
     - Try 1: Count{1:1, 2:0}. Path [2, 1].
       - Try 1: Count{1:0, 2:0}. Path [2, 1, 1]. DONE.

Result: [[1,1,2], [1,2,1], [2,1,1]]
Note that we iterate over *unique* keys of the counter, so we never try the "second 1" 
at the root level separately. This automatically handles duplicates.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Backtracking with Counter (Optimal) ✓ RECOMMENDED
from collections import Counter

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        perm = []
        count = Counter(nums)
        n = len(nums)
        
        def dfs():
            if len(perm) == n:
                res.append(perm[:]) # Make a copy
                return
            
            for num in count:
                if count[num] > 0:
                    # Choose
                    perm.append(num)
                    count[num] -= 1
                    
                    # Explore
                    dfs()
                    
                    # Unchoose (Backtrack)
                    count[num] += 1
                    perm.pop()
                    
        dfs()
        return res


# Approach 2: Backtracking with Sorting
class SolutionSort:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        used = [False] * len(nums)
        
        def backtrack(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if used[i]:
                    continue
                # Skip duplicates: if same as prev and prev not used, skip
                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                    continue
                    
                used[i] = True
                path.append(nums[i])
                backtrack(path)
                path.pop()
                used[i] = False
                
        backtrack([])
        return res


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N * N!)
  - In worst case (no duplicates), N! permutations.
  - Copying list takes O(N).
  - With duplicates, it's strictly better but bounded by this.

Space Complexity: O(N)
  - Recursion depth N.
  - Storage for path and counter.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Duplicates
  Input: [1,1,2]
  Output: [[1,1,2], [1,2,1], [2,1,1]]
  ✓ Correct count (3)

Test Case 2: Unique
  Input: [1,2,3]
  Output: 6 permutations
  ✓ Correct

Test Case 3: All Same
  Input: [1,1,1]
  Output: [[1,1,1]]
  ✓ Correct

Test Case 4: Empty
  Input: []
  Output: [[]]
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Counter ✓ RECOMMENDED
---------------------------------
Pros:
  - Very intuitive.
  - Naturally handles duplicates without tricky "used" logic.

Cons:
  - None.

Approach 2: Sorting
-------------------
Pros:
  - Standard template for permutation problems.

Cons:
  - Requires sorting.
  - Logic `!used[i-1]` is subtle and easy to get wrong.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Shallow Copy
   ❌ res.append(perm)
   ✓ res.append(perm[:]) or perm.copy()

2. Duplicate Handling
   ❌ Generating all N! then using set() to filter
   ✓ Very inefficient for inputs like [1,1,1,1,1,1,1,1] (8! vs 1).

3. Modifying Counter Inside Loop
   ✓ Ensure you increment/decrement correctly around the recursive call.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Permutations with duplicates -> Use Counter or Sort+Skip.
2. Backtracking pattern: Choose -> Explore -> Unchoose.
3. Time O(N!), Space O(N).


================================================================================
RELATED PROBLEMS
================================================================================

- Permutations (Medium) - No duplicates
- Next Permutation (Medium)
- Permutation Sequence (Hard)
- Combinations (Medium)


================================================================================
