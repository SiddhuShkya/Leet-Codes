================================================================================
SEARCH A 2D MATRIX - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You are given an m x n integer matrix matrix with the following two properties:
1. Each row is sorted in non-decreasing order.
2. The first integer of each row is greater than the last integer of the 
   previous row.

Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

EXAMPLES:
---------
Example 1:
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
  Output: true

Example 2:
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
  Output: false

CONSTRAINTS:
------------
- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 100
- -10^4 <= matrix[i][j], target <= 10^4


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Utilizing the sorted properties efficiently
2. Mapping 2D coordinates to 1D index (or vice versa)
3. Handling edge cases (empty matrix)

ALGORITHM STEPS:
----------------
Approach 1: Binary Search (Treat as 1D Array) (O(log(MN))) ✓ OPTIMAL
1. The matrix properties imply that if we flatten the matrix, it forms a strictly 
   increasing sequence.
2. We can perform a standard binary search on the range `[0, m*n - 1]`.
3. Mapping index `mid` to coordinates:
   - `row = mid // n`
   - `col = mid % n`
4. Compare `matrix[row][col]` with `target`.

Approach 2: Staircase Search (O(M+N))
1. Start at top-right corner `(0, n-1)`.
2. If `current == target`: return True.
3. If `current < target`: Move down (`row++`) because current row is too small.
4. If `current > target`: Move left (`col--`) because current col is too big.
5. Repeat until found or out of bounds.
(Note: This is optimal for "Search a 2D Matrix II" where the second property 
doesn't hold, but for this problem, Binary Search is faster).


DETAILED EXPLANATION:
---------------------

Binary Search Logic:
--------------------
Matrix (3x4):
[ 1,  3,  5,  7]
[10, 11, 16, 20]
[23, 30, 34, 60]
Target: 3.

Range: [0, 11].
1. Mid = 5.
   - Row = 5 // 4 = 1.
   - Col = 5 % 4 = 1.
   - Val = matrix[1][1] = 11.
   - 11 > 3. Right = Mid - 1 = 4.

2. Range: [0, 4].
   - Mid = 2.
   - Row = 0, Col = 2. Val = 5.
   - 5 > 3. Right = Mid - 1 = 1.

3. Range: [0, 1].
   - Mid = 0.
   - Row = 0, Col = 0. Val = 1.
   - 1 < 3. Left = Mid + 1 = 1.

4. Range: [1, 1].
   - Mid = 1.
   - Row = 0, Col = 1. Val = 3.
   - 3 == 3. Found.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Binary Search (Optimal for LC 74) ✓ RECOMMENDED
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False
            
        m, n = len(matrix), len(matrix[0])
        left, right = 0, m * n - 1
        
        while left <= right:
            mid = (left + right) // 2
            mid_val = matrix[mid // n][mid % n]
            
            if mid_val == target:
                return True
            elif mid_val < target:
                left = mid + 1
            else:
                right = mid - 1
                
        return False


# Approach 2: Staircase Search (Optimal for LC 240, Valid here too)
# (As implemented in provided main.py)
class SolutionStaircase:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False
            
        rows, cols = len(matrix), len(matrix[0])
        r, c = 0, cols - 1
        
        while r < rows and c >= 0:
            if matrix[r][c] == target:
                return True
            elif matrix[r][c] < target:
                r += 1
            else:
                c -= 1
                
        return False


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Binary Search
-------------------------
Time Complexity: O(log(M * N))
  - Standard binary search.

Space Complexity: O(1)
  - Only variables.

Approach 2: Staircase Search
----------------------------
Time Complexity: O(M + N)
  - At each step, we eliminate a row or a column.

Space Complexity: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Found
  Input: [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target=3
  Output: True
  ✓ Correct

Test Case 2: Not Found
  Input: [[1,3]], target=2
  Output: False
  ✓ Correct

Test Case 3: Empty
  Input: [], target=1
  Output: False
  ✓ Handled


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Binary Search ✓ RECOMMENDED
---------------------------------------
Pros:
  - Fastest time complexity O(log MN).

Cons:
  - Requires coordinate mapping logic.

Approach 2: Staircase Search
----------------------------
Pros:
  - Works for a broader class of matrices (where rows/cols sorted independently).
  - Simple logic.

Cons:
  - Slower O(M+N) vs O(log MN).


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Coordinate Mapping
   ❌ `mid // m` (using rows instead of cols)
   ✓ `row = mid // n` (divide by columns per row)
   ✓ `col = mid % n` (remainder)

2. Boundary Checks
   ✓ `left <= right` in binary search.

3. Empty Matrix
   ✓ Check `if not matrix` or `if not matrix[0]`.


================================================================================
KEY TAKEAWAYS
================================================================================

1. If a 2D matrix is sorted row-by-row and connected, it's just a 1D sorted array.
2. Binary Search is O(log MN).
3. Staircase Search is O(M+N).


================================================================================
RELATED PROBLEMS
================================================================================

- Search a 2D Matrix II (Medium) - Staircase required
- Search in Rotated Sorted Array (Medium)


================================================================================
