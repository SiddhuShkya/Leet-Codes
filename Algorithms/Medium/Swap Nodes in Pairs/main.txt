================================================================================
SWAP NODES IN PAIRS - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given a linked list, swap every two adjacent nodes and return its head. You must 
solve the problem without modifying the values in the list's nodes (i.e., only 
nodes themselves may be changed).

EXAMPLES:
---------
Example 1:
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]

Example 2:
  Input: head = []
  Output: []

Example 3:
  Input: head = [1]
  Output: [1]

CONSTRAINTS:
------------
- The number of nodes in the list is in the range [0, 100].
- 0 <= Node.val <= 100


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Manipulating multiple pointers (prev, first, second, next_pair)
2. Handling edge cases (empty list, single node, odd length)
3. Keeping the list connected

ALGORITHM STEPS:
----------------
Approach 1: Iterative (O(n)) ✓ OPTIMAL
1. Use a dummy node pointing to head.
2. `prev` points to dummy.
3. While `prev.next` and `prev.next.next` exist (at least 2 nodes left):
   - Identify `first` = prev.next
   - Identify `second` = prev.next.next
   - Identify `next_pair` = second.next
   - Swap:
     - `second.next = first`
     - `first.next = next_pair`
     - `prev.next = second`
   - Advance `prev` to `first` (which is now the second node in the pair).
4. Return `dummy.next`.

Approach 2: Recursive (O(n))
1. Base case: If head is None or head.next is None, return head.
2. Identify `first` = head, `second` = head.next.
3. Recursion: `first.next = swapPairs(second.next)`.
4. Swap: `second.next = first`.
5. Return `second` (new head of this pair).


DETAILED EXPLANATION:
---------------------

Iterative Swap Trace: [1, 2, 3, 4]
----------------------------------
Dummy -> 1 -> 2 -> 3 -> 4
Prev = Dummy

1. First = 1, Second = 2, NextPair = 3.
2. Swap:
   - 2 -> 1
   - 1 -> 3
   - Dummy -> 2
   Structure: Dummy -> 2 -> 1 -> 3 -> 4
3. Advance Prev to 1.

Next Iteration:
Prev = 1.
1. First = 3, Second = 4, NextPair = None.
2. Swap:
   - 4 -> 3
   - 3 -> None
   - 1 -> 4
   Structure: Dummy -> 2 -> 1 -> 4 -> 3 -> None
3. Advance Prev to 3.

Loop ends. Return Dummy.next (2).


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Iterative (Optimal Space) ✓ RECOMMENDED
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        prev = dummy
        
        while prev.next and prev.next.next:
            # Identify nodes
            first = prev.next
            second = prev.next.next
            
            # Save next pair start
            next_pair = second.next
            
            # Perform swap
            second.next = first
            first.next = next_pair
            prev.next = second
            
            # Advance prev
            prev = first
            
        return dummy.next


# Approach 2: Recursive (Elegant)
class SolutionRecursive:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
            
        first = head
        second = head.next
        
        # Recurse for the rest
        first.next = self.swapPairs(second.next)
        
        # Swap current pair
        second.next = first
        
        # Second becomes the new head of this sub-list
        return second


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Iterative
---------------------
Time Complexity: O(n)
  - Visit every node.

Space Complexity: O(1)
  - Only pointers.

Approach 2: Recursive
---------------------
Time Complexity: O(n)
  - Visit every node.

Space Complexity: O(n)
  - Stack depth.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Even Length
  Input: [1,2,3,4]
  Output: [2,1,4,3]
  ✓ Correct

Test Case 2: Odd Length
  Input: [1,2,3]
  Output: [2,1,3]
  ✓ Last node left alone

Test Case 3: Empty
  Input: []
  Output: []
  ✓ Correct

Test Case 4: Single Node
  Input: [1]
  Output: [1]
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Iterative ✓ RECOMMENDED
-----------------------------------
Pros:
  - O(1) space.
  - Safe from stack overflow.

Cons:
  - More pointer management code.

Approach 2: Recursive
---------------------
Pros:
  - Very clean code.

Cons:
  - O(n) stack space.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Losing Reference
   ❌ Not saving `next_pair` before changing `first.next`
   ✓ Always save pointers before breaking links

2. Infinite Loop
   ❌ Not advancing `prev` correctly
   ✓ `prev` should move to `first` (the node that was swapped to the 2nd position)

3. Edge Cases
   ✓ Check `head` and `head.next` immediately


================================================================================
KEY TAKEAWAYS
================================================================================

1. Dummy node simplifies head operations.
2. Swapping requires 3 pointers usually (prev, curr, next).
3. Recursive solution is elegant but uses stack space.
4. Time O(n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Reverse Nodes in k-Group (Hard)
- Swap Nodes in Pairs (Medium) is k-Group with k=2
- Reverse Linked List (Easy)


================================================================================
