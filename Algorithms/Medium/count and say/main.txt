================================================================================
COUNT AND SAY - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
The count-and-say sequence is a sequence of digit strings defined by the 
recursive formula:
- countAndSay(1) = "1"
- countAndSay(n) is the way you would "say" the digit string from 
  countAndSay(n-1), which is then converted into a different digit string.

To determine how you "say" a digit string, split it into the minimal number of 
substrings such that each substring contains exactly one unique digit. Then for 
each substring, say the number of digits, then say the digit. Finally, 
concatenate every said digit.

EXAMPLES:
---------
Example 1:
  Input: n = 1
  Output: "1"

Example 2:
  Input: n = 4
  Output: "1211"
  Explanation:
  countAndSay(1) = "1"
  countAndSay(2) = say "1" = one 1 = "11"
  countAndSay(3) = say "11" = two 1s = "21"
  countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"

CONSTRAINTS:
------------
- 1 <= n <= 30


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Understanding the recursive generation rule
2. Parsing the previous string to count consecutive characters
3. Constructing the new string efficiently

ALGORITHM STEPS:
----------------
Approach 1: Iterative / Recursive Simulation (O(N * L)) ✓ OPTIMAL
1. Base case: if n=1, return "1".
2. Recursively get the string for n-1.
3. Iterate through the previous string to count runs of identical digits.
4. Maintain `count` and `current_char`.
5. When character changes (or end of string):
   - Append `str(count) + current_char` to result.
   - Reset count.
6. Return result.

DETAILED EXPLANATION:
---------------------

Generate n=4:
1. n=1: "1"
2. n=2: Read "1".
   - One '1'.
   - Result: "11"
3. n=3: Read "11".
   - Two '1's.
   - Result: "21"
4. n=4: Read "21".
   - One '2'. Append "12".
   - One '1'. Append "11".
   - Result: "1211"

5. n=5: Read "1211".
   - One '1'. Append "11".
   - One '2'. Append "12".
   - Two '1's. Append "21".
   - Result: "111221"


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Iterative (Optimal) ✓ RECOMMENDED
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return "1"
            
        prev = "1"
        for _ in range(2, n + 1):
            curr = []
            count = 1
            length = len(prev)
            
            for i in range(length):
                # Check if next char is same
                if i < length - 1 and prev[i] == prev[i+1]:
                    count += 1
                else:
                    # End of run
                    curr.append(str(count))
                    curr.append(prev[i])
                    count = 1
            
            prev = "".join(curr)
            
        return prev


# Approach 2: Recursive
class SolutionRecursive:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return "1"
            
        prev = self.countAndSay(n - 1)
        res = []
        count = 1
        
        for i in range(len(prev)):
            if i == len(prev) - 1 or prev[i] != prev[i+1]:
                res.append(str(count))
                res.append(prev[i])
                count = 1
            else:
                count += 1
                
        return "".join(res)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N * L)
  - N iterations.
  - L is the length of the string, which grows exponentially (approx 1.3^N).
  - For N=30, length is manageable (~4000 digits).

Space Complexity: O(L)
  - Store the string.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: n=1
  Output: "1"
  ✓ Correct

Test Case 2: n=4
  Output: "1211"
  ✓ Correct

Test Case 3: n=5
  Output: "111221"
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Iterative ✓ RECOMMENDED
-----------------------------------
Pros:
  - Avoids recursion depth limit (though N=30 is small).
  - Clear state update.

Cons:
  - None.

Approach 2: Regular Expressions
-------------------------------
Use `re.findall(r'((\d)\2*)', s)` to group digits.
Pros: Short code.
Cons: Slower due to regex overhead.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Off-by-one
   ❌ Accessing `prev[i+1]` at last index
   ✓ Check `i < length - 1` or handle last group after loop.

2. Type Conversion
   ❌ `res += count + char` (int + str error)
   ✓ `res += str(count) + char`

3. String Concatenation
   ❌ `res += ...` inside loop
   ✓ Use list `[]` and `"".join()` for O(L) construction instead of O(L^2).


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Run-length encoding" logic.
2. Sequence grows rapidly in length but N is small (30).
3. Time O(N * L), Space O(L).


================================================================================
RELATED PROBLEMS
================================================================================

- String Compression (Medium)
- Encode and Decode Strings (Medium)


================================================================================
