================================================================================
JUMP GAME II - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You are given a 0-indexed array of integers nums of length n. You are initially 
positioned at nums[0].

Each element nums[i] represents the maximum length of a forward jump from index i. 
In other words, if you are at nums[i], you can jump to any nums[i + j] where:
- 0 <= j <= nums[i] and
- i + j < n

Return the minimum number of jumps to reach nums[n - 1]. The test cases are 
generated such that you can reach nums[n - 1].

EXAMPLES:
---------
Example 1:
  Input: nums = [2,3,1,1,4]
  Output: 2
  Explanation: The minimum number of jumps to reach the last index is 2. 
  Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:
  Input: nums = [2,3,0,1,4]
  Output: 2

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 1000
- It's guaranteed that you can reach nums[n - 1].


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding minimum jumps (not just reachability)
2. Avoiding O(N^2) DP
3. Greedy choice property

ALGORITHM STEPS:
----------------
Approach 1: Greedy BFS (Range Based) (O(N)) ✓ OPTIMAL
1. We process the array in "windows" or "levels" of jumps.
2. `l` and `r` define the current range of indices reachable with `jumps` number of jumps.
3. Initially `l=0, r=0, jumps=0`.
4. While `r < n - 1`:
   - Calculate `farthest` reachable from any index in range `[l, r]`.
   - `farthest = max(i + nums[i])` for `i` in `l..r`.
   - Update range: `l = r + 1`, `r = farthest`.
   - `jumps += 1`.
5. Return `jumps`.

Approach 2: Implicit BFS (End Pointer)
1. `jumps = 0`, `current_jump_end = 0`, `farthest = 0`.
2. Iterate `i` from 0 to n-2:
   - `farthest = max(farthest, i + nums[i])`.
   - If `i == current_jump_end`:
     - `jumps += 1`
     - `current_jump_end = farthest`
3. Return `jumps`.


DETAILED EXPLANATION:
---------------------

Input: [2, 3, 1, 1, 4]
Target: Index 4.

1. Start: Range [0, 0]. Jumps = 0.
   - Max reach from index 0 (val 2) is 0+2 = 2.
   - New Range: [1, 2]. Jumps = 1.

2. Range [1, 2].
   - Index 1 (val 3) -> reach 1+3 = 4.
   - Index 2 (val 1) -> reach 2+1 = 3.
   - Farthest is 4.
   - New Range: [3, 4]. Jumps = 2.

3. r (4) >= n-1 (4). Stop.
   Result: 2.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Greedy BFS (Range) ✓ RECOMMENDED
class Solution:
    def jump(self, nums: List[int]) -> int:
        jumps = 0
        l, r = 0, 0
        
        while r < len(nums) - 1:
            farthest = 0
            # Find farthest reachable in current level
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            
            # Move to next level
            l = r + 1
            r = farthest
            jumps += 1
            
        return jumps


# Approach 2: Implicit BFS (Cleaner Loop)
class SolutionImplicit:
    def jump(self, nums: List[int]) -> int:
        jumps = 0
        current_jump_end = 0
        farthest = 0
        
        # Note: Iterate to n-2 because if we are at n-1 we don't need to jump
        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])
            
            if i == current_jump_end:
                jumps += 1
                current_jump_end = farthest
                
        return jumps


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N)
  - We visit every element at most once (or twice in range approach).

Space Complexity: O(1)
  - Only variables.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: [2,3,1,1,4]
  Output: 2
  ✓ Correct

Test Case 2: [2,3,0,1,4]
  Output: 2
  ✓ Correct

Test Case 3: [1]
  Output: 0
  ✓ Loop doesn't run. Correct.

Test Case 4: [1, 2]
  Output: 1
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Greedy BFS ✓ RECOMMENDED
------------------------------------
Pros:
  - O(N) time.
  - O(1) space.

Cons:
  - None.

Approach 2: DP (O(N^2))
-----------------------
`dp[i] = 1 + min(dp[j])` for reachable j.
Pros: General DP practice.
Cons: Too slow for N=10^4.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Loop Bound
   ❌ Iterating to `n-1` in Implicit BFS
   ✓ If `i` reaches `n-1`, we are already there. We shouldn't jump again. Stop at `n-2`.

2. Unreachable Target
   ✓ Problem guarantees reachability. If not guaranteed, check `if farthest <= i` (stuck).

3. Initialization
   ✓ `l=0, r=0` for start.


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Minimum jumps" in unweighted graph/array = BFS.
2. Array structure allows optimizing BFS queue to simple pointers (Range BFS).
3. Time O(N), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Jump Game (Medium) - Reachability only
- Jump Game III (Medium) - BFS
- Minimum Number of Taps to Open to Water a Garden (Hard)


================================================================================
