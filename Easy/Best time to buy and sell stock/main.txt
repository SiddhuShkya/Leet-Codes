================================================================================
BEST TIME TO BUY AND SELL STOCK - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
You are given an array prices where prices[i] is the price of a given stock 
on the ith day.

You want to maximize your profit by choosing a single day to buy one stock 
and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot 
achieve any profit, return 0.

EXAMPLES:
---------
Example 1:
  Input: prices = [7,1,5,3,6,4]
  Output: 5
  Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), 
  profit = 6-1 = 5.
  Note that buying on day 2 and selling on day 1 is not allowed because you 
  must buy before you sell.

Example 2:
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: In this case, no transactions are done and the max profit = 0.

CONSTRAINTS:
------------
- 1 <= prices.length <= 10^5
- 0 <= prices[i] <= 10^4


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Must buy before selling (can't go back in time)
2. Finding optimal buy and sell days
3. Avoiding O(n²) brute force
4. Handling decreasing prices (no profit possible)

ALGORITHM STEPS:
----------------
Approach 1: Two Pointers (Optimal)
1. Initialize left pointer at 0 (buy day)
2. Initialize right pointer at 1 (sell day)
3. Track maximum profit
4. For each day:
   a. If prices[left] < prices[right], calculate profit
   b. Update max profit if current profit is higher
   c. If prices[left] >= prices[right], move left to right (found lower buy price)
   d. Always move right pointer forward
5. Return maximum profit

Approach 2: Track Minimum Price
1. Initialize min_price to infinity
2. Initialize max_profit to 0
3. For each price:
   a. Update min_price if current price is lower
   b. Calculate profit = current_price - min_price
   c. Update max_profit if profit is higher
4. Return max_profit


DETAILED EXPLANATION:
---------------------

Key Insight:
------------
For maximum profit, we want to:
  - Buy at the LOWEST price
  - Sell at the HIGHEST price AFTER buying

We can't sell before buying, so we must track the minimum price seen so far
and calculate profit for each subsequent price.

Two Pointers Approach Walkthrough:
-----------------------------------
prices = [7, 1, 5, 3, 6, 4]

Initial: l=0 (price=7), r=1 (price=1), maxProfit=0

Step 1: l=0(7), r=1(1)
  - 7 > 1, so move l to r (found lower buy price)
  - l=1, r=2

Step 2: l=1(1), r=2(5)
  - 1 < 5, profit = 5-1 = 4
  - maxProfit = 4
  - r=3

Step 3: l=1(1), r=3(3)
  - 1 < 3, profit = 3-1 = 2
  - maxProfit stays 4
  - r=4

Step 4: l=1(1), r=4(6)
  - 1 < 6, profit = 6-1 = 5
  - maxProfit = 5
  - r=5

Step 5: l=1(1), r=5(4)
  - 1 < 4, profit = 4-1 = 3
  - maxProfit stays 5

Return 5

Minimum Price Tracking:
-----------------------
prices = [7, 1, 5, 3, 6, 4]

Day 0: price=7, min_price=7, profit=0, max_profit=0
Day 1: price=1, min_price=1, profit=0, max_profit=0
Day 2: price=5, min_price=1, profit=4, max_profit=4
Day 3: price=3, min_price=1, profit=2, max_profit=4
Day 4: price=6, min_price=1, profit=5, max_profit=5
Day 5: price=4, min_price=1, profit=3, max_profit=5

Return 5


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Two Pointers
def maxProfit(prices):
    l, r = 0, 1  # left=buy, right=sell
    maxProfit = 0
    
    while r < len(prices):
        # Profitable transaction?
        if prices[l] < prices[r]:
            profit = prices[r] - prices[l]
            maxProfit = max(maxProfit, profit)
        else:
            # Found lower buy price, update left
            l = r
        r += 1
    
    return maxProfit


# Approach 2: Track Minimum Price
def maxProfit_v2(prices):
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        # Update minimum price seen so far
        min_price = min(min_price, price)
        # Calculate profit if we sell today
        profit = price - min_price
        # Update maximum profit
        max_profit = max(max_profit, profit)
    
    return max_profit


# LeetCode Solution Class Format
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        l, r = 0, 1
        maxProfit = 0
        
        while r < len(prices):
            if prices[l] < prices[r]:
                profit = prices[r] - prices[l]
                maxProfit = max(maxProfit, profit)
            else:
                l = r
            r += 1
        
        return maxProfit


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Two Pointers
-------------------------
Time Complexity: O(n)
  - Single pass through array
  - Each element visited once
  - Total: O(n)

Space Complexity: O(1)
  - Only using a few variables (l, r, maxProfit)
  - No additional data structures
  - Total: O(1)

Approach 2: Track Minimum Price
--------------------------------
Time Complexity: O(n)
  - Single pass through array
  - Each element processed once
  - Total: O(n)

Space Complexity: O(1)
  - Only using min_price and max_profit variables
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Profit Possible
  Input: prices = [7,1,5,3,6,4]
  Output: 5
  ✓ Buy at 1, sell at 6

Test Case 2: No Profit (Decreasing)
  Input: prices = [7,6,4,3,1]
  Output: 0
  ✓ Prices only decrease, no profit possible

Test Case 3: Single Day
  Input: prices = [5]
  Output: 0
  ✓ Cannot buy and sell on same day

Test Case 4: Two Days
  Input: prices = [1,2]
  Output: 1
  ✓ Buy at 1, sell at 2

Test Case 5: Maximum at End
  Input: prices = [1,2,3,4,5]
  Output: 4
  ✓ Buy at 1, sell at 5


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Two Pointers ✓ RECOMMENDED
---------------------------------------
Use left pointer for buy, right for sell.

Pros:
  - Intuitive with buy/sell pointers
  - O(n) time, O(1) space
  - Clear logic

Cons:
  - Slightly more complex than min tracking
  - Need to manage two pointers

Approach 2: Track Minimum Price ✓ ALSO GOOD
--------------------------------------------
Track minimum price and calculate profit.

Pros:
  - Very clean and simple
  - O(n) time, O(1) space
  - Easy to understand
  - Single loop

Cons:
  - Less intuitive than two pointers
  - Doesn't explicitly show buy/sell days

Approach 3: Brute Force (Not Recommended)
------------------------------------------
Try all pairs of buy/sell days.

Pros:
  - Simple to understand

Cons:
  - O(n²) time complexity
  - Too slow for large inputs
  - Not acceptable


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Selling Before Buying
   ❌ Considering prices[i] - prices[j] where i > j
   ✓ Must buy before selling (i < j)

2. Using Brute Force
   ❌ Nested loops checking all pairs
   ✓ Use single pass with tracking

3. Not Handling No Profit Case
   ❌ Returning negative profit
   ✓ Return 0 if no profit possible

4. Incorrect Pointer Updates
   ❌ Not moving left pointer when finding lower price
   ✓ Update left when prices[right] < prices[left]

5. Off-by-One Errors
   ❌ Starting right pointer at 0
   ✓ Right pointer starts at 1 (must be after left)


================================================================================
KEY TAKEAWAYS
================================================================================

1. Single pass solution is possible with O(1) space
2. Track minimum price seen so far for optimal buy point
3. Calculate profit for each potential sell point
4. Two pointers provide intuitive buy/sell representation
5. Must buy before selling (temporal constraint)
6. Return 0 if no profit is possible


================================================================================
RELATED PROBLEMS
================================================================================

- Best Time to Buy and Sell Stock II (Medium) - Multiple transactions
- Best Time to Buy and Sell Stock III (Hard) - At most 2 transactions
- Best Time to Buy and Sell Stock IV (Hard) - At most k transactions
- Best Time to Buy and Sell Stock with Cooldown (Medium) - With cooldown
- Best Time to Buy and Sell Stock with Transaction Fee (Medium) - With fee
- Maximum Subarray (Medium) - Similar single-pass optimization


================================================================================
