================================================================================
CAN MAKE ARITHMETIC PROGRESSION FROM SEQUENCE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
A sequence of numbers is called an arithmetic progression if the difference 
between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to 
form an arithmetic progression. Otherwise, return false.

EXAMPLES:
---------
Example 1:
  Input: arr = [3,5,1]
  Output: true
  Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with 
  differences 2 and -2 respectively, between each consecutive elements.

Example 2:
  Input: arr = [1,2,4]
  Output: false
  Explanation: There is no way to reorder the elements to obtain an 
  arithmetic progression.

CONSTRAINTS:
------------
- 2 <= arr.length <= 1000
- -10^6 <= arr[i] <= 10^6


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Determining if elements form AP
2. Handling unsorted input
3. Optimizing time complexity

ALGORITHM STEPS:
----------------
Approach 1: Sorting (O(n log n)) ✓ SIMPLEST
1. Sort the array.
2. Calculate difference `diff = arr[1] - arr[0]`.
3. Iterate from i=2 to end.
4. If `arr[i] - arr[i-1] != diff`, return False.
5. Return True.

Approach 2: Set / Math (O(n)) ✓ OPTIMAL
1. Find min and max of array.
2. Calculate total range = max - min.
3. If range % (n-1) != 0, return False (cannot divide evenly).
4. Calculate required difference `diff = range / (n-1)`.
5. If diff == 0, check if all elements are same (or just return True if duplicates allowed/handled).
6. Use a set to store seen elements.
7. For each number `num` in arr:
   - Check if `(num - min) % diff == 0`.
   - Check if `num` is already in set (duplicates not allowed in AP unless diff=0).
   - Add to set.
8. Return True.


DETAILED EXPLANATION:
---------------------

Sorting Approach:
-----------------
AP property: a, a+d, a+2d, ...
If we sort the array, consecutive elements must have constant difference.

Example: [3, 5, 1]
Sorted: [1, 3, 5]
Diff: 3-1 = 2
Check: 5-3 = 2 == Diff? Yes.
Return True.

Example: [1, 2, 4]
Sorted: [1, 2, 4]
Diff: 2-1 = 1
Check: 4-2 = 2 != Diff.
Return False.

O(n) Approach Logic:
--------------------
An AP is defined by start term (min), common difference (diff), and length (n).
Max term = min + (n-1)*diff.
So, diff = (max - min) / (n-1).

If (max - min) is not divisible by (n-1), impossible.
If divisible, every element `x` must satisfy: `x = min + k*diff`.
So `(x - min)` must be divisible by `diff`.
Also, all elements must be unique (unless diff=0).


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Sorting (Simple) ✓ RECOMMENDED
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        diff = arr[1] - arr[0]
        
        for i in range(2, len(arr)):
            if arr[i] - arr[i-1] != diff:
                return False
                
        return True


# Approach 2: O(n) Math + Set
class SolutionOptimal:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        n = len(arr)
        min_val = min(arr)
        max_val = max(arr)
        
        if (max_val - min_val) % (n - 1) != 0:
            return False
        
        diff = (max_val - min_val) // (n - 1)
        
        if diff == 0:
            # If diff is 0, all elements must be equal
            return len(set(arr)) == 1
        
        seen = set()
        for num in arr:
            # Check if num fits in the progression
            if (num - min_val) % diff != 0:
                return False
            
            # Check for duplicates (not allowed if diff != 0)
            if num in seen:
                return False
            
            seen.add(num)
            
        return True


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Sorting
-------------------
Time Complexity: O(n log n)
  - Sorting dominates.

Space Complexity: O(1) or O(log n)
  - Sorting space.

Approach 2: O(n) Math
---------------------
Time Complexity: O(n)
  - Finding min/max: O(n).
  - Iterating array: O(n).

Space Complexity: O(n)
  - Set to store elements.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Valid AP
  Input: [3,5,1]
  Output: true
  ✓ Sorted: 1,3,5 (diff 2)

Test Case 2: Invalid AP
  Input: [1,2,4]
  Output: false
  ✓ Sorted: 1,2,4 (diffs 1, 2)

Test Case 3: Negative Numbers
  Input: [-1,-3,-5]
  Output: true
  ✓ Sorted: -5,-3,-1 (diff 2)

Test Case 4: All Same
  Input: [1,1,1]
  Output: true
  ✓ Diff 0

Test Case 5: Duplicates (Invalid)
  Input: [1,2,2,3]
  Output: false
  ✓ Cannot form AP with duplicates (unless all same)


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Sorting ✓ RECOMMENDED
---------------------------------
Pros:
  - Very simple to code.
  - O(1) extra space (usually).
  - Fast enough for n=1000.

Cons:
  - O(n log n) time.

Approach 2: Math + Set
----------------------
Pros:
  - O(n) time.

Cons:
  - O(n) space.
  - More complex logic.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Sorting
   ❌ Checking adjacent elements in unsorted array
   ✓ Must sort first or use math approach

2. Division by Zero
   ❌ Calculating diff when n=1 (Constraints say n>=2)
   ✓ Constraints handle this, but good to be aware

3. Modulo Check
   ❌ Forgetting to check if (max-min) is divisible by (n-1)
   ✓ Essential for O(n) approach

4. Duplicates
   ❌ Ignoring duplicates in O(n) approach
   ✓ AP with diff != 0 cannot have duplicates


================================================================================
KEY TAKEAWAYS
================================================================================

1. AP property: constant difference between sorted elements.
2. Sorting is the easiest way to check.
3. O(n) check possible using min, max, and set.
4. Diff = (max - min) / (n - 1).


================================================================================
RELATED PROBLEMS
================================================================================

- Arithmetic Slices (Medium)
- Arithmetic Subarrays (Medium)
- Check If It Is a Straight Line (Easy)


================================================================================
