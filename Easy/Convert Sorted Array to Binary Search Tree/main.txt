================================================================================
CONVERT SORTED ARRAY TO BINARY SEARCH TREE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums where the elements are sorted in ascending order, 
convert it to a height-balanced binary search tree.

A height-balanced binary tree is a binary tree in which the depth of the two 
subtrees of every node never differs by more than one.

EXAMPLES:
---------
Example 1:
  Input: nums = [-10,-3,0,5,9]
  Output: [0,-3,9,-10,null,5]
  Explanation: [0,-10,5,null,-3,null,9] is also accepted:
       0
      / \
    -3   9
    /   /
  -10  5

Example 2:
  Input: nums = [1,3]
  Output: [3,1]
  Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^4
- -10^4 <= nums[i] <= 10^4
- nums is sorted in a strictly increasing order.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Creating a height-balanced tree
2. Maintaining BST property (left < root < right)
3. Choosing the correct root
4. Recursive construction

ALGORITHM STEPS:
----------------
1. Find the middle element of the current array/subarray.
2. Make this middle element the root of the current subtree.
3. Recursively construct the left subtree using the left half of the array.
4. Recursively construct the right subtree using the right half of the array.
5. Return the root.

DETAILED EXPLANATION:
---------------------

Why Middle Element?
-------------------
To ensure the tree is height-balanced, we need roughly equal numbers of nodes 
on the left and right. In a sorted array, the middle element divides the array 
into two equal (or nearly equal) halves.
- Elements to the left are smaller -> Left Subtree
- Elements to the right are larger -> Right Subtree

Example: [-10, -3, 0, 5, 9]
----------------------------
1. Middle element: 0 (index 2)
   - Root = 0
   - Left part: [-10, -3]
   - Right part: [5, 9]

2. Left Subtree from [-10, -3]:
   - Middle: -3 (or -10 depending on implementation)
   - If -3 is root:
     - Left part: [-10] -> Left child of -3
     - Right part: [] -> Right child of -3 is null

3. Right Subtree from [5, 9]:
   - Middle: 9 (or 5)
   - If 9 is root:
     - Left part: [5] -> Left child of 9
     - Right part: [] -> Right child of 9 is null

Resulting Tree:
      0
     / \
   -3   9
   /   /
 -10  5

Recursive Logic:
----------------
function buildBST(left, right):
  if left > right: return None
  mid = (left + right) // 2
  node = new TreeNode(nums[mid])
  node.left = buildBST(left, mid - 1)
  node.right = buildBST(mid + 1, right)
  return node


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Recursive (Slicing) - Simple but creates copies
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        
        # Slicing creates new lists (O(N) space overhead per call)
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        
        return root


# Approach 2: Recursive (Indices) - Optimized Space ✓ RECOMMENDED
class SolutionOptimized:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(left, right):
            if left > right:
                return None
            
            # Choose middle element (prevents overflow in other languages)
            mid = left + (right - left) // 2
            
            node = TreeNode(nums[mid])
            node.left = helper(left, mid - 1)
            node.right = helper(mid + 1, right)
            
            return node
        
        return helper(0, len(nums) - 1)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Recursive (Slicing)
--------------------------------
Time Complexity: O(n log n) or O(n) depending on slicing implementation
  - Python slicing is O(k), so total time can be higher.
  - T(n) = 2T(n/2) + O(n) -> O(n log n)

Space Complexity: O(n)
  - Creating copies of arrays.

Approach 2: Recursive (Indices)
--------------------------------
Time Complexity: O(n)
  - Visit each node exactly once.
  - T(n) = 2T(n/2) + O(1) -> O(n)

Space Complexity: O(log n)
  - Recursion stack depth is height of tree.
  - Balanced tree height is log n.
  - (Ignoring output space for the tree itself)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Odd number of elements
  Input: [-10,-3,0,5,9]
  Output: [0,-3,9,-10,null,5]
  ✓ Balanced, root is 0

Test Case 2: Even number of elements
  Input: [1,3]
  Output: [3,1] or [1,null,3]
  ✓ Balanced

Test Case 3: Single element
  Input: [1]
  Output: [1]
  ✓ Trivial case

Test Case 4: Empty array
  Input: []
  Output: []
  ✓ Base case


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Recursive with Indices ✓ RECOMMENDED
-------------------------------------------------
Pass left and right indices instead of slicing array.

Pros:
  - O(n) time
  - O(log n) space
  - No array copying

Cons:
  - Slightly more code than slicing

Approach 2: Iterative
---------------------
Use a stack to simulate recursion. Push (node, left_index, right_index).

Pros:
  - No recursion stack limit

Cons:
  - Complex to implement
  - Harder to read


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using Array Slicing in Recursion
   ❌ nums[:mid] inside recursive call
   ✓ Use indices (left, right) to avoid O(n) copying

2. Wrong Base Case
   ❌ if left == right
   ✓ if left > right: return None

3. Integer Overflow (in other languages)
   ❌ (left + right) // 2
   ✓ left + (right - left) // 2 (Safe for large integers)

4. Off-by-one Errors
   ❌ helper(left, mid)
   ✓ helper(left, mid - 1) for left child


================================================================================
KEY TAKEAWAYS
================================================================================

1. Middle of sorted array is the root of a balanced BST.
2. Recursively apply this to left and right halves.
3. Use indices to avoid expensive array slicing.
4. Resulting tree is always height-balanced (depth difference <= 1).
5. Time complexity O(n), Space O(log n).


================================================================================
RELATED PROBLEMS
================================================================================

- Convert Sorted List to Binary Search Tree (Medium) - Similar but with Linked List
- Balance a Binary Search Tree (Medium) - Rebalance existing tree
- Validate Binary Search Tree (Medium) - Check BST property
- Binary Search (Easy) - Same divide and conquer principle


================================================================================
