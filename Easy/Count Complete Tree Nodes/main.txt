================================================================================
COUNT COMPLETE TREE NODES - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely 
filled in a complete binary tree, and all nodes in the last level are as far 
left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

EXAMPLES:
---------
Example 1:
  Input: root = [1,2,3,4,5,6]
  Output: 6

Example 2:
  Input: root = []
  Output: 0

Example 3:
  Input: root = [1]
  Output: 1

CONSTRAINTS:
------------
- The number of nodes in the tree is in the range [0, 5 * 10^4].
- 0 <= Node.val <= 5 * 10^4
- The tree is guaranteed to be complete.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Counting nodes faster than O(n)
2. Utilizing "Complete Binary Tree" property
3. Calculating height efficiently
4. Determining if subtrees are full

ALGORITHM STEPS:
----------------
Approach 1: Linear Scan (O(n)) - Too Slow for Follow-up
1. Traverse every node and count.

Approach 2: Binary Search on Height (O((log n)^2)) ✓ OPTIMAL
1. Calculate height of left-most path (left_h).
2. Calculate height of right-most path (right_h).
3. If left_h == right_h:
   - It's a Perfect Binary Tree.
   - Nodes = 2^h - 1 (where h is number of levels)
4. If left_h != right_h:
   - Recursively count: 1 + count(left) + count(right)

Optimized Logic (used in provided code):
----------------------------------------
1. Get height of left subtree (left_h).
2. Get height of right subtree (right_h).
   - Note: Here height usually refers to depth of left-most node.
3. If left_h == right_h:
   - Left subtree is a perfect binary tree of height left_h.
   - Count = (2^left_h - 1) [left nodes] + 1 [root] + count(right)
   - Count = 2^left_h + count(right)
4. If left_h > right_h:
   - Right subtree is a perfect binary tree of height right_h.
   - Count = (2^right_h - 1) [right nodes] + 1 [root] + count(left)
   - Count = 2^right_h + count(left)


DETAILED EXPLANATION:
---------------------

Complete Binary Tree Property:
------------------------------
- Filled from left to right.
- Height is log n.
- Subtrees are also complete binary trees.

Height Calculation:
-------------------
Since it's complete, height can be found by just going left.
h = 0
curr = root
while curr:
    h += 1
    curr = curr.left

Logic Trace:
------------
       1
     /   \
    2     3
   / \   /
  4   5 6

Root (1):
- Left child (2) height: 2 (nodes 2->4)
- Right child (3) height: 2 (nodes 3->6)
- Heights equal? Yes.
- Left subtree (2) is perfect.
- Nodes = 2^2 + count(right) = 4 + count(3)

Count(3):
- Left child (6) height: 1
- Right child (null) height: 0
- Heights equal? No.
- Right subtree (null) is perfect (empty).
- Nodes = 2^0 + count(left) = 1 + count(6)

Count(6):
- Left height 0, Right height 0.
- Equal.
- Nodes = 2^0 + count(null) = 1 + 0 = 1

Total = 4 + (1 + 1) = 6. Correct.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Linear Search (O(n)) - Simple but not optimal
class SolutionLinear:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)


# Approach 2: Height Comparison (O((log n)^2)) ✓ RECOMMENDED
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        def get_height(node):
            height = 0
            while node:
                height += 1
                node = node.left
            return height
        
        left_height = get_height(root.left)
        right_height = get_height(root.right)
        
        if left_height == right_height:
            # Left subtree is perfect
            # Nodes: (2^h - 1) left + 1 root + right_recursive
            # = 2^h + countNodes(root.right)
            return (1 << left_height) + self.countNodes(root.right)
        else:
            # Right subtree is perfect (but one level shorter)
            # Nodes: (2^h_right - 1) right + 1 root + left_recursive
            # = 2^h_right + countNodes(root.left)
            return (1 << right_height) + self.countNodes(root.left)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Linear
------------------
Time Complexity: O(n)
  - Visit every node.

Approach 2: Height Comparison
-----------------------------
Time Complexity: O((log n)^2)
  - At each step, we calculate height which takes O(log n).
  - We recurse down the height of the tree, so O(log n) steps.
  - Total: O(log n) * O(log n) = O((log n)^2).
  - Since n <= 50,000, log n ≈ 16. 16^2 = 256 ops vs 50,000 ops. Much faster.

Space Complexity: O(log n)
  - Recursion stack depth is height of tree.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Complete Tree
  Input: [1,2,3,4,5,6]
  Output: 6
  ✓ Correct count

Test Case 2: Perfect Tree
  Input: [1,2,3]
  Output: 3
  ✓ Left height == Right height

Test Case 3: Single Node
  Input: [1]
  Output: 1
  ✓ Base case

Test Case 4: Empty
  Input: []
  Output: 0
  ✓ Base case


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Linear Traversal
----------------------------
Pros: Simple.
Cons: O(n), doesn't use problem constraints.

Approach 2: Binary Search on Leaf Nodes
---------------------------------------
Binary search the existence of nodes in the last level.
Index nodes 0 to 2^h - 1. Check if index exists using bit manipulation.
Pros: O((log n)^2).
Cons: Slightly more complex implementation than height comparison.

Approach 3: Height Comparison ✓ RECOMMENDED
-------------------------------------------
Pros: Elegant, optimal complexity, leverages recursive structure.
Cons: Requires understanding of perfect binary tree properties.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using O(n) Solution
   ❌ Simple recursion
   ✓ Use height property for < O(n)

2. Height Calculation
   ❌ Traversing both left and right to find height
   ✓ Only traverse left (guaranteed by complete property)

3. Off-by-one in Formula
   ❌ 2^h
   ✓ 2^h includes root if we consider subtree count as (2^h - 1) + 1

4. Bit Shift vs Power
   ✓ Use 1 << h for 2^h (faster/cleaner)


================================================================================
KEY TAKEAWAYS
================================================================================

1. Complete Binary Tree: Levels filled left to right.
2. Perfect Binary Tree: All levels full. Nodes = 2^h - 1.
3. Height of complete tree can be found in O(log n) by going left.
4. If left_h == right_h, left subtree is perfect.
5. If left_h > right_h, right subtree is perfect (one level less).
6. Time complexity O((log n)^2) is standard for this problem.


================================================================================
RELATED PROBLEMS
================================================================================

- Closest Binary Search Tree Value (Easy)
- Search in a Binary Search Tree (Easy)
- Binary Tree Maximum Path Sum (Hard)
- Kth Smallest Element in a BST (Medium)


================================================================================
