================================================================================
COUNT THE NUMBER OF CONSISTENT STRINGS - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
You are given a string allowed consisting of distinct characters and an array of 
strings words. A string is consistent if all characters in the string appear in 
the string allowed.

Return the number of consistent strings in the array words.

EXAMPLES:
---------
Example 1:
  Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
  Output: 2
  Explanation: Strings "aaab" and "baa" are consistent since they only contain 
  characters 'a' and 'b'.

Example 2:
  Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
  Output: 7
  Explanation: All strings are consistent.

Example 3:
  Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
  Output: 4
  Explanation: Strings "cc", "acd", "ac", and "d" are consistent.

CONSTRAINTS:
------------
- 1 <= words.length <= 10^4
- 1 <= allowed.length <= 26
- 1 <= words[i].length <= 10
- The characters in allowed are distinct.
- words[i] and allowed contain only lowercase English letters.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Efficient lookup of allowed characters
2. Checking every character of every word
3. Optimizing for large input

ALGORITHM STEPS:
----------------
Approach 1: Hash Set (O(N*M)) ✓ OPTIMAL
1. Convert `allowed` string to a Set for O(1) lookup.
2. Initialize `count = 0`.
3. For each word in `words`:
   - Check if every character in `word` is present in the Set.
   - If yes, increment `count`.
4. Return `count`.

Approach 2: Boolean Array (O(N*M))
1. Create a boolean array of size 26.
2. Mark indices corresponding to `allowed` characters as True.
3. Check each word against this array.

Approach 3: Bit Mask (O(N*M))
1. Create an integer mask where bits corresponding to `allowed` chars are set.
2. For each word, create a mask of its characters.
3. Check if `(word_mask | allowed_mask) == allowed_mask` OR `(word_mask & ~allowed_mask) == 0`.


DETAILED EXPLANATION:
---------------------

Set Approach:
-------------
Allowed: "ab" -> Set{'a', 'b'}

Word: "ad"
- 'a' in Set? Yes.
- 'd' in Set? No. -> Inconsistent.

Word: "aaab"
- 'a' in Set? Yes.
- 'a' in Set? Yes.
- 'a' in Set? Yes.
- 'b' in Set? Yes. -> Consistent.

Why Set?
--------
String search `char in string` is O(L) where L is length of allowed.
Set search is O(1).
Since allowed length is small (26), difference is small, but Set is conceptually better.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Set (Optimal & Clean) ✓ RECOMMENDED
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        allowed_set = set(allowed)
        count = 0
        
        for word in words:
            is_consistent = True
            for char in word:
                if char not in allowed_set:
                    is_consistent = False
                    break
            
            if is_consistent:
                count += 1
                
        return count


# Approach 2: Pythonic One-Liner
class SolutionPythonic:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        allowed_set = set(allowed)
        # Check if set of word is subset of allowed set
        return sum(1 for word in words if set(word).issubset(allowed_set))


# Approach 3: Bit Mask (Fastest low-level)
class SolutionBitMask:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        mask = 0
        for char in allowed:
            mask |= (1 << (ord(char) - ord('a')))
            
        count = 0
        for word in words:
            word_consistent = True
            for char in word:
                if not (mask & (1 << (ord(char) - ord('a')))):
                    word_consistent = False
                    break
            if word_consistent:
                count += 1
        return count


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N * M)
  - N = number of words, M = max length of word.
  - We must visit every character of every word in worst case.
  - Set construction is O(K) where K is allowed length (max 26).

Space Complexity: O(1)
  - Set stores max 26 characters.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Mixed
  Input: "ab", ["ad","bd","aaab","baa"]
  Output: 2
  ✓ "aaab", "baa"

Test Case 2: All Consistent
  Input: "abc", ["a","b","c"]
  Output: 3
  ✓ All valid

Test Case 3: None Consistent
  Input: "a", ["b","c"]
  Output: 0
  ✓ None valid

Test Case 4: Empty Word?
  Constraints say length >= 1.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Set ✓ RECOMMENDED
-----------------------------
Pros:
  - Clean, readable.
  - O(1) lookup.

Cons:
  - None.

Approach 2: Bit Mask
--------------------
Pros:
  - Very fast bitwise ops.
  - O(1) space (integer).

Cons:
  - Less readable.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Linear Search in Allowed
   ❌ if char in allowed (where allowed is string)
   ✓ Use set(allowed) for O(1) lookup (though with len<=26 it's fast anyway)

2. Logic Error
   ❌ Breaking loop but counting anyway
   ✓ Use flag or `else` block in for loop (Python specific)

3. Subset Check Overhead
   ❌ set(word).issubset() creates new set for every word
   ✓ Direct iteration is often faster/less memory intensive for simple checks


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Consistent" means "Subset".
2. Hash Set provides O(1) containment check.
3. Bit manipulation can simulate sets for small universes (like 26 chars).
4. Time O(total characters), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Number of Strings That Appear as Substrings in Word (Easy)
- Check If Two String Arrays are Equivalent (Easy)


================================================================================
