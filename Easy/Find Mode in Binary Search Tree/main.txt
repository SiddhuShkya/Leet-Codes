================================================================================
FIND MODE IN BINARY SEARCH TREE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the root of a binary search tree (BST) with duplicates, return all the 
mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than or equal to the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

EXAMPLES:
---------
Example 1:
  Input: root = [1,null,2,2]
  Output: [2]

Example 2:
  Input: root = [0]
  Output: [0]

CONSTRAINTS:
------------
- The number of nodes in the tree is in the range [1, 10^4].
- -10^5 <= Node.val <= 10^5

Follow up: Could you do that without using any extra space? (Assume that the 
implicit stack space incurred due to recursion does not count).


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Handling duplicates in BST
2. Finding frequency of all elements
3. Optimizing space to O(1) (excluding recursion stack)
4. Handling multiple modes

ALGORITHM STEPS:
----------------
Approach 1: Hash Map (O(n) space)
1. Traverse tree (any order).
2. Count frequencies in a hash map.
3. Find max frequency.
4. Collect all keys with max frequency.

Approach 2: Inorder Traversal (O(1) extra space) ✓ OPTIMAL
1. Perform inorder traversal (Left -> Root -> Right).
   - In a BST, this visits nodes in non-decreasing order.
   - Duplicates will be adjacent.
2. Track:
   - current_val: value being processed
   - current_count: streak of current_val
   - max_count: highest streak seen so far
   - modes: list of result values
3. For each node:
   - If val == current_val: increment count
   - Else: reset count to 1
   - If count > max_count: 
     - Update max_count
     - Clear modes list and add current_val
   - If count == max_count:
     - Add current_val to modes


DETAILED EXPLANATION:
---------------------

Why Inorder Traversal?
----------------------
In a BST, inorder traversal yields sorted values.
Example: [1, null, 2, 2]
Tree:
  1
   \
    2
   /
  2

Inorder: 1, 2, 2

Processing Stream: 1, 2, 2
--------------------------
1. Node 1:
   - prev = None
   - count = 1
   - max_count = 1
   - modes = [1]
   - prev = 1

2. Node 2:
   - val (2) != prev (1)
   - count = 1
   - max_count = 1 (equal)
   - modes = [1, 2]
   - prev = 2

3. Node 2:
   - val (2) == prev (2)
   - count = 2
   - count (2) > max_count (1)
   - max_count = 2
   - modes = [2] (cleared previous)
   - prev = 2

Result: [2]

Two-Pass Optimization (Strict O(1) extra space):
------------------------------------------------
To avoid storing the `modes` list (which could be O(n) in worst case e.g. [1,2,3,4]), 
we can do two passes:
1. First pass: Find max_count.
2. Second pass: Collect elements with count == max_count.
However, usually storing the result list is acceptable.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Hash Map (Simple but O(n) space)
from collections import Counter
class SolutionMap:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        counter = Counter()
        
        def dfs(node):
            if not node: return
            counter[node.val] += 1
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        max_freq = max(counter.values())
        return [k for k, v in counter.items() if v == max_freq]


# Approach 2: Inorder Traversal (O(1) extra space) ✓ RECOMMENDED
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.current_val = None
        self.current_count = 0
        self.max_count = 0
        self.modes = []
        
        def handle_value(val):
            if val == self.current_val:
                self.current_count += 1
            else:
                self.current_val = val
                self.current_count = 1
            
            if self.current_count > self.max_count:
                self.max_count = self.current_count
                self.modes = [val]
            elif self.current_count == self.max_count:
                self.modes.append(val)
        
        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            handle_value(node.val)
            inorder(node.right)
            
        inorder(root)
        return self.modes


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Hash Map
--------------------
Time Complexity: O(n)
  - Visit each node once.
  - Counter operations are O(1).

Space Complexity: O(n)
  - Store counts for all unique elements.

Approach 2: Inorder Traversal
-----------------------------
Time Complexity: O(n)
  - Visit each node once.

Space Complexity: O(1) (excluding recursion stack and output)
  - Only store a few variables.
  - Recursion stack is O(h).
  - Meets follow-up requirement.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Single Mode
  Input: [1,null,2,2]
  Output: [2]
  ✓ 2 appears twice, 1 appears once.

Test Case 2: Multiple Modes
  Input: [1,2]
  Output: [1,2]
  ✓ Both appear once.

Test Case 3: Single Node
  Input: [1]
  Output: [1]
  ✓ Trivial.

Test Case 4: All Same
  Input: [2,2,2]
  Output: [2]
  ✓ Only one value.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Hash Map
--------------------
Pros:
  - Very easy to implement.
  - Works for any tree (not just BST).

Cons:
  - O(n) space.

Approach 2: Inorder Traversal ✓ RECOMMENDED
-------------------------------------------
Pros:
  - O(1) extra space.
  - Leverages BST property.

Cons:
  - Slightly more complex logic.
  - Recursion stack still takes space (Morris traversal can make it truly O(1)).


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Multiple Modes
   ❌ Returning only one value
   ✓ Return a list of all modes

2. Resetting Logic
   ❌ Not resetting count when value changes
   ✓ Set current_count = 1 when val != current_val

3. Updating Max Count
   ❌ Not clearing modes list when new max found
   ✓ modes = [val] when count > max_count

4. Order of Traversal
   ❌ Preorder/Postorder for O(1) space
   ✓ Must be Inorder to group duplicates together


================================================================================
KEY TAKEAWAYS
================================================================================

1. Inorder traversal of BST gives sorted sequence.
2. Duplicates in sorted sequence are adjacent.
3. Can find mode in one pass by tracking streaks.
4. O(1) extra space is possible by not storing all counts.
5. Multiple modes are possible.


================================================================================
RELATED PROBLEMS
================================================================================

- Validate Binary Search Tree (Medium)
- Kth Smallest Element in a BST (Medium)
- Binary Search Tree Iterator (Medium)
- Minimum Absolute Difference in BST (Easy)


================================================================================
