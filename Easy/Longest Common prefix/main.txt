================================================================================
LONGEST COMMON PREFIX - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Write a function to find the longest common prefix string amongst an array of 
strings.

If there is no common prefix, return an empty string "".

EXAMPLES:
---------
Example 1:
  Input: strs = ["flower","flow","flight"]
  Output: "fl"

Example 2:
  Input: strs = ["dog","racecar","car"]
  Output: ""
  Explanation: There is no common prefix among the input strings.

CONSTRAINTS:
------------
- 1 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] consists of only lowercase English letters


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Handling strings of different lengths
2. Finding common prefix across all strings
3. Stopping when mismatch is found
4. Handling edge cases (empty strings, single string)

ALGORITHM STEPS:
----------------
Approach 1: Vertical Scanning
1. Use first string as reference
2. For each character position i in first string:
   a. Check if all other strings have character at position i
   b. Check if all strings have same character at position i
   c. If any string is too short or has different character, return prefix
   d. Otherwise, add character to prefix
3. Return final prefix

Approach 2: Horizontal Scanning
1. Start with first string as prefix
2. For each subsequent string:
   a. Reduce prefix until it matches beginning of current string
   b. If prefix becomes empty, return ""
3. Return final prefix

Approach 3: Divide and Conquer
1. Divide array into two halves
2. Recursively find LCP of each half
3. Merge results by finding LCP of two prefixes


DETAILED EXPLANATION:
---------------------

Vertical Scanning Walkthrough:
-------------------------------
strs = ["flower", "flow", "flight"]

i=0: Check 'f' in all strings
  - "flower"[0] = 'f' ✓
  - "flow"[0] = 'f' ✓
  - "flight"[0] = 'f' ✓
  - All match, prefix = "f"

i=1: Check 'l' in all strings
  - "flower"[1] = 'l' ✓
  - "flow"[1] = 'l' ✓
  - "flight"[1] = 'l' ✓
  - All match, prefix = "fl"

i=2: Check 'o' in all strings
  - "flower"[2] = 'o' ✓
  - "flow"[2] = 'o' ✓
  - "flight"[2] = 'i' ✗
  - Mismatch! Return "fl"

Horizontal Scanning Walkthrough:
---------------------------------
strs = ["flower", "flow", "flight"]

prefix = "flower"

Compare with "flow":
  - "flower" doesn't match start of "flow"
  - Reduce: "flowe" doesn't match
  - Reduce: "flow" matches! ✓
  - prefix = "flow"

Compare with "flight":
  - "flow" doesn't match start of "flight"
  - Reduce: "flo" doesn't match
  - Reduce: "fl" matches! ✓
  - prefix = "fl"

Return "fl"


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Vertical Scanning ✓ RECOMMENDED
def longestCommonPrefix(strs):
    if not strs:
        return ""
    
    prefix = ""
    # Iterate through characters of first string
    for i in range(len(strs[0])):
        # Check if all strings have this character
        for s in strs:
            if i == len(s) or strs[0][i] != s[i]:
                return prefix
        # All strings have matching character
        prefix += strs[0][i]
    
    return prefix


# Approach 2: Horizontal Scanning
def longestCommonPrefix_horizontal(strs):
    if not strs:
        return ""
    
    prefix = strs[0]
    for i in range(1, len(strs)):
        # Reduce prefix until it matches start of current string
        while strs[i].find(prefix) != 0:
            prefix = prefix[:-1]
            if not prefix:
                return ""
    
    return prefix


# Approach 3: Using Python's zip (Elegant)
def longestCommonPrefix_zip(strs):
    if not strs:
        return ""
    
    prefix = ""
    # zip(*strs) groups characters at same position
    for chars in zip(*strs):
        if len(set(chars)) == 1:  # All same character
            prefix += chars[0]
        else:
            break
    
    return prefix


# LeetCode Solution Class Format
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        prefix = ""
        for i in range(len(strs[0])):
            for s in strs:
                if i == len(s) or strs[0][i] != s[i]:
                    return prefix
            prefix += strs[0][i]
        
        return prefix


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Vertical Scanning
------------------------------
Time Complexity: O(S)
  - S = sum of all characters in all strings
  - Worst case: all strings are identical
  - Best case: O(n) if first character differs
  - Average: O(S)

Space Complexity: O(1)
  - Only using prefix string (output)
  - No additional data structures
  - Total: O(1)

Approach 2: Horizontal Scanning
--------------------------------
Time Complexity: O(S)
  - S = sum of all characters
  - Each character compared at most once
  - Total: O(S)

Space Complexity: O(1)
  - Only storing prefix
  - Total: O(1)

Approach 3: Using zip
---------------------
Time Complexity: O(S)
  - zip creates tuples of characters
  - Check each tuple once
  - Total: O(S)

Space Complexity: O(m)
  - m = length of shortest string
  - zip creates tuples
  - Total: O(m)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Common Prefix Exists
  Input: strs = ["flower","flow","flight"]
  Output: "fl"
  ✓ First two characters match

Test Case 2: No Common Prefix
  Input: strs = ["dog","racecar","car"]
  Output: ""
  ✓ No common prefix

Test Case 3: Single String
  Input: strs = ["alone"]
  Output: "alone"
  ✓ Entire string is the prefix

Test Case 4: All Identical
  Input: strs = ["test","test","test"]
  Output: "test"
  ✓ Entire string is common

Test Case 5: Empty String in Array
  Input: strs = ["flower","flow",""]
  Output: ""
  ✓ Empty string means no common prefix

Test Case 6: Prefix is Entire First String
  Input: strs = ["ab","abc","abcd"]
  Output: "ab"
  ✓ Shortest string is the prefix


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Vertical Scanning ✓ RECOMMENDED
--------------------------------------------
Compare characters at same position across all strings.

Pros:
  - Intuitive and clear
  - Early termination on mismatch
  - O(S) time, O(1) space

Cons:
  - Nested loops may seem complex

Approach 2: Horizontal Scanning
--------------------------------
Reduce prefix by comparing with each string.

Pros:
  - Simple logic
  - Easy to understand

Cons:
  - May do redundant work
  - String slicing overhead

Approach 3: Using zip
---------------------
Group characters at same position using zip.

Pros:
  - Very Pythonic and elegant
  - Concise code

Cons:
  - Less intuitive for beginners
  - Creates intermediate tuples


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Handling Empty Array
   ❌ Not checking if strs is empty
   ✓ Return "" if not strs

2. Index Out of Bounds
   ❌ Not checking if i >= len(s)
   ✓ Check i == len(s) before accessing s[i]

3. Not Handling Empty Strings
   ❌ Assuming all strings have length > 0
   ✓ Check for empty strings in array

4. Inefficient String Concatenation
   ❌ Using += in loop (can be slow)
   ✓ For large inputs, use list and join

5. Wrong Loop Bounds
   ❌ Using len(strs) instead of len(strs[0])
   ✓ Iterate through first string's length


================================================================================
KEY TAKEAWAYS
================================================================================

1. Vertical scanning is most intuitive approach
2. Early termination saves time when mismatch found early
3. Must handle edge cases: empty array, empty strings
4. Common prefix length ≤ length of shortest string
5. Time complexity is O(S) where S = total characters
6. Python's zip provides elegant solution


================================================================================
RELATED PROBLEMS
================================================================================

- Longest Common Subsequence (Medium) - Similar but subsequence
- Implement strStr() (Easy) - String matching
- Add Binary (Easy) - String manipulation
- Longest Palindromic Substring (Medium) - String analysis
- Group Anagrams (Medium) - String comparison
- Valid Palindrome (Easy) - String validation


================================================================================
