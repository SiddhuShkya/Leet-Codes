================================================================================
MAJORITY ELEMENT - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You 
may assume that the majority element always exists in the array.

EXAMPLES:
---------
Example 1:
  Input: nums = [3,2,3]
  Output: 3

Example 2:
  Input: nums = [2,2,1,1,1,2,2]
  Output: 2

CONSTRAINTS:
------------
- n == nums.length
- 1 <= n <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9

Follow-up: Could you solve the problem in linear time and in O(1) space?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding element appearing > n/2 times
2. Achieving O(n) time complexity
3. Optimizing to O(1) space (follow-up)
4. Handling large arrays efficiently

ALGORITHM STEPS:
----------------
Approach 1: Hash Map (Simple)
1. Count frequency of each element
2. Return element with count > n/2

Approach 2: Boyer-Moore Voting Algorithm (Optimal)
1. Initialize candidate and count
2. For each element:
   - If count == 0, set current element as candidate
   - If element == candidate, increment count
   - Otherwise, decrement count
3. Return candidate

Approach 3: Sorting
1. Sort array
2. Return middle element (guaranteed to be majority)


DETAILED EXPLANATION:
---------------------

Hash Map Approach:
------------------
Count occurrences and find element with count > n/2.

Example: nums = [2,2,1,1,1,2,2]
  - Count: {2: 4, 1: 3}
  - n/2 = 3.5
  - Element 2 appears 4 times > 3.5
  - Return 2

Boyer-Moore Voting Algorithm:
------------------------------
Brilliant algorithm that finds majority in O(n) time, O(1) space!

Key insight: Majority element appears > n/2 times, so if we pair each 
majority element with a different element, majority will still remain.

Example: nums = [2,2,1,1,1,2,2]
---------------------------------
candidate=None, count=0

i=0: nums[0]=2
  count==0, set candidate=2, count=1

i=1: nums[1]=2
  2==candidate, count=2

i=2: nums[2]=1
  1!=candidate, count=1

i=3: nums[3]=1
  1!=candidate, count=0

i=4: nums[4]=1
  count==0, set candidate=1, count=1

i=5: nums[5]=2
  2!=candidate, count=0

i=6: nums[6]=2
  count==0, set candidate=2, count=1

Return candidate=2

Why It Works:
-------------
The majority element will always "survive" the cancellation process because
it appears more than all other elements combined.

Sorting Approach:
-----------------
After sorting, the middle element must be the majority element.

Example: nums = [2,2,1,1,1,2,2]
  - Sorted: [1,1,1,2,2,2,2]
  - Middle (index 3): 2
  - Return 2


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Hash Map
def majorityElement_hashmap(nums):
    hp = {}
    threshold = len(nums) // 2
    
    for num in nums:
        if num not in hp:
            hp[num] = 1
        else:
            hp[num] += 1
    
    for k, v in hp.items():
        if v > threshold:
            return k


# Using Counter (Pythonic)
from collections import Counter

def majorityElement_counter(nums):
    counts = Counter(nums)
    return counts.most_common(1)[0][0]


# Approach 2: Boyer-Moore Voting ✓ OPTIMAL
def majorityElement_voting(nums):
    candidate = None
    count = 0
    
    for num in nums:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1
    
    return candidate


# Approach 3: Sorting
def majorityElement_sort(nums):
    nums.sort()
    return nums[len(nums) // 2]


# LeetCode Solution Class Format
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate = None
        count = 0
        
        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)
        
        return candidate


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Hash Map
---------------------
Time Complexity: O(n)
  - Single pass to count: O(n)
  - Find majority: O(n) worst case
  - Total: O(n)

Space Complexity: O(n)
  - Hash map stores up to n elements
  - Total: O(n)

Approach 2: Boyer-Moore Voting
-------------------------------
Time Complexity: O(n)
  - Single pass through array
  - Total: O(n)

Space Complexity: O(1)
  - Only using two variables
  - Total: O(1) ✓ OPTIMAL

Approach 3: Sorting
-------------------
Time Complexity: O(n log n)
  - Sorting: O(n log n)
  - Total: O(n log n)

Space Complexity: O(1) or O(n)
  - Depends on sorting algorithm
  - In-place sort: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Simple Majority
  Input: nums = [3,2,3]
  Output: 3
  ✓ 3 appears 2/3 times

Test Case 2: Larger Array
  Input: nums = [2,2,1,1,1,2,2]
  Output: 2
  ✓ 2 appears 4/7 times

Test Case 3: All Same
  Input: nums = [1,1,1,1]
  Output: 1
  ✓ 1 appears 4/4 times

Test Case 4: Single Element
  Input: nums = [1]
  Output: 1
  ✓ Only element is majority

Test Case 5: Two Elements
  Input: nums = [1,1]
  Output: 1
  ✓ Both are same


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Hash Map
---------------------
Count frequencies and find majority.

Pros:
  - Simple and intuitive
  - O(n) time complexity
  - Easy to understand

Cons:
  - O(n) space complexity
  - Not optimal for follow-up

Approach 2: Boyer-Moore Voting ✓ RECOMMENDED
---------------------------------------------
Voting algorithm to find majority.

Pros:
  - O(n) time, O(1) space
  - Meets follow-up requirement
  - Elegant algorithm
  - Optimal solution

Cons:
  - Less intuitive
  - Requires understanding algorithm

Approach 3: Sorting
-------------------
Sort and return middle element.

Pros:
  - Simple to implement
  - Guaranteed correct

Cons:
  - O(n log n) time - not optimal
  - Modifies input array


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Wrong Threshold
   ❌ Using >= n/2 instead of > n/2
   ✓ Majority means > n/2, not >= n/2

2. Not Handling Edge Cases
   ❌ Not testing single element
   ✓ Handle n=1 case

3. Assuming Sorted Input
   ❌ Assuming array is sorted
   ✓ Array can be in any order

4. Using O(n) Space
   ❌ Not optimizing for follow-up
   ✓ Use Boyer-Moore for O(1) space

5. Not Understanding Boyer-Moore
   ❌ Implementing incorrectly
   ✓ Understand cancellation concept


================================================================================
KEY TAKEAWAYS
================================================================================

1. Boyer-Moore Voting is optimal: O(n) time, O(1) space
2. Majority element appears > n/2 times (more than half)
3. Cancellation property: majority survives pairing
4. Hash map is simpler but uses O(n) space
5. Sorting works but is O(n log n) time
6. Problem guarantees majority exists


================================================================================
RELATED PROBLEMS
================================================================================

- Majority Element II (Medium) - Elements appearing > n/3 times
- Find Mode in Binary Search Tree (Easy) - Most frequent in BST
- Top K Frequent Elements (Medium) - K most frequent
- Single Number (Easy) - Similar voting concept
- Missing Number (Easy) - Finding unique element
- Contains Duplicate (Easy) - Frequency checking


================================================================================
