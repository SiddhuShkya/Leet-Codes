================================================================================
MINIMUM ABSOLUTE DIFFERENCE IN BST - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the root of a Binary Search Tree (BST), return the minimum absolute 
difference between the values of any two different nodes in the tree.

EXAMPLES:
---------
Example 1:
  Input: root = [4,2,6,1,3]
  Output: 1
  Explanation: 
  Sorted values: [1, 2, 3, 4, 6]
  Differences: |2-1|=1, |3-2|=1, |4-3|=1, |6-4|=2
  Minimum is 1.

Example 2:
  Input: root = [1,0,48,null,null,12,49]
  Output: 1
  Explanation:
  Sorted values: [0, 1, 12, 48, 49]
  Min diff is between 48 and 49 (or 0 and 1).

CONSTRAINTS:
------------
- The number of nodes in the tree is in the range [2, 10^4].
- 0 <= Node.val <= 10^5


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding min difference efficiently
2. Avoiding O(n^2) comparisons
3. Leveraging BST property

ALGORITHM STEPS:
----------------
Approach 1: Convert to Array (O(n) space)
1. Perform inorder traversal to get sorted list of values.
2. Iterate through list and find min difference between adjacent elements.

Approach 2: Inorder Traversal with Prev Pointer (O(1) extra space) ✓ OPTIMAL
1. Perform inorder traversal.
2. Keep track of `prev_val` (value of previously visited node).
3. At each node:
   - If prev_val is not None:
     - diff = current_val - prev_val
     - min_diff = min(min_diff, diff)
   - Update prev_val = current_val


DETAILED EXPLANATION:
---------------------

Why Inorder Traversal?
----------------------
In a BST, inorder traversal yields values in ascending order.
The minimum difference between any two nodes MUST be between two adjacent nodes 
in the sorted sequence.

Proof:
Suppose sorted sequence is a, b, c.
a < b < c.
Diff(a, c) = c - a
Diff(a, b) = b - a
Diff(b, c) = c - b
Since b > a, (c - a) > (c - b).
So diff between non-adjacent nodes is always larger than diff between adjacent nodes.

Example: [4,2,6,1,3]
--------------------
Tree:
      4
     / \
    2   6
   / \
  1   3

Inorder: 1, 2, 3, 4, 6

1. Node 1: prev=None
2. Node 2: prev=1, diff=2-1=1, min=1, prev=2
3. Node 3: prev=2, diff=3-2=1, min=1, prev=3
4. Node 4: prev=3, diff=4-3=1, min=1, prev=4
5. Node 6: prev=4, diff=6-4=2, min=1, prev=6

Result: 1


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: List Conversion (Simple)
class SolutionList:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        vals = []
        def inorder(node):
            if not node: return
            inorder(node.left)
            vals.append(node.val)
            inorder(node.right)
        
        inorder(root)
        
        min_diff = float('inf')
        for i in range(1, len(vals)):
            min_diff = min(min_diff, vals[i] - vals[i-1])
            
        return min_diff


# Approach 2: In-Place Traversal (Optimal) ✓ RECOMMENDED
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.prev = None
        self.min_diff = float('inf')
        
        def inorder(node):
            if not node:
                return
            
            # Left
            inorder(node.left)
            
            # Process current
            if self.prev is not None:
                self.min_diff = min(self.min_diff, node.val - self.prev)
            self.prev = node.val
            
            # Right
            inorder(node.right)
        
        inorder(root)
        return self.min_diff


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: List Conversion
---------------------------
Time Complexity: O(n)
  - Visit all nodes: O(n)
  - Iterate list: O(n)

Space Complexity: O(n)
  - Store all values in list.

Approach 2: In-Place Traversal
------------------------------
Time Complexity: O(n)
  - Visit all nodes once.

Space Complexity: O(h)
  - Recursion stack height.
  - O(log n) for balanced tree.
  - O(1) extra space (excluding stack).


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard BST
  Input: [4,2,6,1,3]
  Output: 1
  ✓ Adjacent values: 1,2,3,4,6. Diffs: 1,1,1,2.

Test Case 2: Large Diff
  Input: [1, null, 100]
  Output: 99
  ✓ 100 - 1 = 99.

Test Case 3: Zero Diff (Duplicates?)
  Note: Problem constraints say "two different nodes". If duplicates allowed, 
  min diff could be 0. If strictly increasing, min diff > 0.
  LeetCode usually implies unique values unless specified.
  If duplicates exist, logic still holds (diff = 0).


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Brute Force
-----------------------
Compare every node with every other node.
Pros: None.
Cons: O(n^2) time.

Approach 2: Inorder Traversal ✓ RECOMMENDED
-------------------------------------------
Pros: O(n) time, O(h) space.
Cons: None.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Not Using Absolute Difference
   ❌ node.val - prev
   ✓ abs(node.val - prev) (though inorder guarantees node.val > prev)

2. Comparing Non-Adjacent Nodes
   ❌ Comparing root with children only
   ✓ Must compare in sorted order (inorder)

3. Initializing Min Diff
   ❌ min_diff = 0
   ✓ min_diff = float('inf')

4. Handling First Node
   ❌ Accessing prev when it's None
   ✓ Check if self.prev is not None


================================================================================
KEY TAKEAWAYS
================================================================================

1. BST Inorder Traversal = Sorted Sequence.
2. Min difference is always between adjacent sorted values.
3. No need to store all values; just track previous value.
4. Time complexity O(n), Space O(h).


================================================================================
RELATED PROBLEMS
================================================================================

- Find Mode in Binary Search Tree (Easy)
- Kth Smallest Element in a BST (Medium)
- Validate Binary Search Tree (Medium)
- Two Sum IV - Input is a BST (Easy)


================================================================================
