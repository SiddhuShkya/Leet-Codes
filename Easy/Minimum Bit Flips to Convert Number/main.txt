================================================================================
MINIMUM BIT FLIPS TO CONVERT NUMBER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
A bit flip of a number x is choosing a bit in the binary representation of x and 
flipping it from either 0 to 1 or 1 to 0.

For example, for x = 7, the binary representation is 111 and we may choose any 
bit (including any leading zeros not shown) and flip it. We can flip the first 
bit from the right to get 110, flip the second bit from the right to get 101, 
flip the fifth bit from the right (a leading zero) to get 10111, etc.

Given two integers start and goal, return the minimum number of bit flips to 
convert start to goal.

EXAMPLES:
---------
Example 1:
  Input: start = 10, goal = 7
  Output: 3
  Explanation: The binary representation of 10 is 1010. The binary representation 
  of 7 is 0111. We need to flip the 1st, 3rd, and 4th bits.
  1010 -> 1011 -> 0011 -> 0111 (3 flips).

Example 2:
  Input: start = 3, goal = 4
  Output: 3
  Explanation: 3 is 011, 4 is 100.
  011 -> 010 -> 000 -> 100 (3 flips).

CONSTRAINTS:
------------
- 0 <= start, goal <= 10^9


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Identifying differing bits
2. Counting set bits efficiently

ALGORITHM STEPS:
----------------
Approach 1: XOR and Count (O(1) / O(log n)) ✓ OPTIMAL
1. Calculate `diff = start ^ goal` (XOR operation).
   - XOR returns 1 where bits differ, 0 where they are same.
2. Count the number of 1s in `diff`.
   - This is the number of flips needed.

How to count 1s?
- Method A: `bin(diff).count('1')` (Pythonic)
- Method B: Loop `while diff > 0: diff &= (diff - 1); count += 1` (Brian Kernighan's algorithm)
- Method C: Loop `while diff: count += diff & 1; diff >>= 1`


DETAILED EXPLANATION:
---------------------

Example: Start=10 (1010), Goal=7 (0111)
---------------------------------------
1. XOR:
   1 0 1 0
 ^ 0 1 1 1
   -------
   1 1 0 1  (Decimal 13)

2. Count set bits in 1101:
   - 1st bit is 1.
   - 2nd bit is 0.
   - 3rd bit is 1.
   - 4th bit is 1.
   - Total = 3.

Why XOR?
--------
0 ^ 0 = 0 (Same, no flip needed)
1 ^ 1 = 0 (Same, no flip needed)
0 ^ 1 = 1 (Different, flip needed)
1 ^ 0 = 1 (Different, flip needed)
So XOR perfectly isolates the positions that need flipping.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: XOR and Built-in Count (Optimal) ✓ RECOMMENDED
class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        # XOR to find differing bits, then count them
        return bin(start ^ goal).count('1')


# Approach 2: XOR and Manual Count (Bit Manipulation)
class SolutionManual:
    def minBitFlips(self, start: int, goal: int) -> int:
        xor_val = start ^ goal
        count = 0
        while xor_val:
            # Check last bit
            count += xor_val & 1
            # Shift right
            xor_val >>= 1
        return count


# Approach 3: Brian Kernighan's Algorithm (Fastest for sparse bits)
class SolutionKernighan:
    def minBitFlips(self, start: int, goal: int) -> int:
        xor_val = start ^ goal
        count = 0
        while xor_val:
            xor_val &= (xor_val - 1) # Clears the lowest set bit
            count += 1
        return count


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(1) (or O(log n))
  - Number of bits is fixed (32 or 64).
  - Operations are constant time relative to input value magnitude.

Space Complexity: O(1)
  - Only variables used.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Mixed
  Input: 10, 7
  Output: 3
  ✓ 1010 ^ 0111 = 1101 (3 bits)

Test Case 2: Adjacent
  Input: 3, 4
  Output: 3
  ✓ 011 ^ 100 = 111 (3 bits)

Test Case 3: Same
  Input: 5, 5
  Output: 0
  ✓ 0 flips

Test Case 4: Zero
  Input: 0, 1
  Output: 1
  ✓ 0 ^ 1 = 1


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: XOR + Count ✓ RECOMMENDED
-------------------------------------
Pros:
  - One liner in Python.
  - Very efficient.

Cons:
  - None.

Approach 2: Manual Bit Comparison
---------------------------------
Loop through bits of both numbers and compare.
Pros: No XOR needed (if XOR unavailable).
Cons: More code.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Confusing AND/OR with XOR
   ❌ start & goal or start | goal
   ✓ Use XOR (^) for differences

2. Infinite Loop
   ❌ while xor_val > 0 without shifting
   ✓ Must shift (>>= 1) or clear bit (&= x-1)

3. Negative Numbers
   ✓ Problem constraints say 0 <= start, goal, so no sign bit issues.


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Number of flips" = "Hamming Distance".
2. Hamming Distance is calculated using XOR + Bit Count.
3. Time O(1), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Hamming Distance (Easy) - Exact same problem
- Number of 1 Bits (Easy)
- Counting Bits (Easy)
- Single Number (Easy)


================================================================================
