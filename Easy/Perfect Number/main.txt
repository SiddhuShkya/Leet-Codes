================================================================================
PERFECT NUMBER - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
A perfect number is a positive integer that is equal to the sum of its positive 
divisors, excluding the number itself. A divisor of an integer x is an integer 
that can divide x evenly.

Given an integer n, return true if n is a perfect number, otherwise return false.

EXAMPLES:
---------
Example 1:
  Input: num = 28
  Output: true
  Explanation: 28 = 1 + 2 + 4 + 7 + 14
  1, 2, 4, 7, and 14 are all divisors of 28.

Example 2:
  Input: num = 7
  Output: false

CONSTRAINTS:
------------
- 1 <= num <= 10^8


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding all divisors efficiently
2. Summing divisors (excluding number itself)
3. Optimizing to avoid checking all numbers
4. Handling edge cases

ALGORITHM STEPS:
----------------
Approach 1: Optimized Divisor Sum
1. If num <= 1, return false
2. Initialize sum = 1 (1 is always a divisor)
3. For i from 2 to √num:
   - If num % i == 0:
     - Add i to sum
     - If i ≠ num/i, add num/i to sum
4. Return sum == num

Approach 2: Brute Force
1. Sum all divisors from 1 to num-1
2. Check if sum equals num


DETAILED EXPLANATION:
---------------------

Perfect Number Definition:
--------------------------
A number equals the sum of its proper divisors (divisors excluding itself).

Examples:
- 6 = 1 + 2 + 3 → perfect ✓
- 28 = 1 + 2 + 4 + 7 + 14 → perfect ✓
- 7 has divisors [1], sum = 1 ≠ 7 → not perfect ✗

Optimization: Check up to √num
-------------------------------
For every divisor i < √num, there's a corresponding divisor num/i > √num.

Example: num = 28, √28 ≈ 5.29

i=2: 28 % 2 == 0
  - Add 2 (divisor)
  - Add 28/2 = 14 (corresponding divisor)

i=4: 28 % 4 == 0
  - Add 4 (divisor)
  - Add 28/4 = 7 (corresponding divisor)

i=5: 28 % 5 != 0, skip

Divisors found: 1, 2, 4, 7, 14
Sum: 1 + 2 + 4 + 7 + 14 = 28 ✓

Special Case: Perfect Squares
------------------------------
For perfect squares, √num is a divisor.
Must avoid counting it twice.

Example: num = 36, √36 = 6
When i = 6:
  - 36 % 6 == 0
  - Add 6 (divisor)
  - Don't add 36/6 = 6 again (i == num/i)

Algorithm Walkthrough: num = 28
--------------------------------
sum = 1 (start with 1)

i=2: 28 % 2 == 0
  sum += 2 → sum = 3
  2 ≠ 14, sum += 14 → sum = 17

i=3: 28 % 3 != 0, skip

i=4: 28 % 4 == 0
  sum += 4 → sum = 21
  4 ≠ 7, sum += 7 → sum = 28

i=5: 5² = 25 < 28, but 28 % 5 != 0, skip

Loop ends (i² > 28)
sum = 28 == num → return true


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Optimized ✓ RECOMMENDED
class Solution(object):
    def checkPerfectNumber(self, num):
        if num <= 1:
            return False
        
        total = 1  # 1 is always a divisor
        i = 2
        
        while i * i <= num:
            if num % i == 0:
                total += i
                # Add corresponding divisor if different
                if i != num // i:
                    total += num // i
            i += 1
        
        return total == num


# Approach 2: Brute Force (Not Optimal)
def checkPerfectNumber_brute(num):
    if num <= 1:
        return False
    
    total = 0
    for i in range(1, num):
        if num % i == 0:
            total += i
    
    return total == num


# Using known perfect numbers (Cheating)
def checkPerfectNumber_known(num):
    # First 5 perfect numbers (within constraint)
    perfect_numbers = {6, 28, 496, 8128, 33550336}
    return num in perfect_numbers


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Optimized
----------------------
Time Complexity: O(√n)
  - Loop from 2 to √num
  - Total: O(√n)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)

Approach 2: Brute Force
-----------------------
Time Complexity: O(n)
  - Check all numbers from 1 to num-1
  - Total: O(n)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Perfect Number
  Input: num = 28
  Output: true
  ✓ 28 = 1 + 2 + 4 + 7 + 14

Test Case 2: Not Perfect
  Input: num = 7
  Output: false
  ✓ Divisors: [1], sum = 1 ≠ 7

Test Case 3: First Perfect Number
  Input: num = 6
  Output: true
  ✓ 6 = 1 + 2 + 3

Test Case 4: One
  Input: num = 1
  Output: false
  ✓ 1 has no proper divisors

Test Case 5: Large Perfect Number
  Input: num = 8128
  Output: true
  ✓ Fourth perfect number


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Optimized Divisor Sum ✓ RECOMMENDED
------------------------------------------------
Check divisors up to √num.

Pros:
  - O(√n) time complexity
  - Efficient for large numbers
  - Optimal solution

Cons:
  - Slightly more complex logic

Approach 2: Brute Force
-----------------------
Check all numbers from 1 to num-1.

Pros:
  - Simple and intuitive
  - Easy to implement

Cons:
  - O(n) time - too slow for large numbers
  - Not optimal

Approach 3: Known Perfect Numbers
----------------------------------
Use hardcoded set of perfect numbers.

Pros:
  - O(1) time

Cons:
  - Not general solution
  - Cheating
  - Not acceptable in interviews


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Including Number Itself
   ❌ Adding num to sum of divisors
   ✓ Only add proper divisors (excluding num)

2. Counting Divisors Twice
   ❌ Adding both i and num/i when i² = num
   ✓ Check if i != num/i

3. Wrong Loop Bound
   ❌ Looping to num instead of √num
   ✓ Loop while i * i <= num

4. Not Handling 1
   ❌ Considering 1 as perfect
   ✓ Return false for num <= 1

5. Integer Division
   ❌ Using / instead of //
   ✓ Use // for integer division


================================================================================
KEY TAKEAWAYS
================================================================================

1. Perfect number = sum of proper divisors
2. Optimize by checking divisors up to √num
3. For each divisor i, also add num/i
4. Avoid counting √num twice for perfect squares
5. Time complexity: O(√n)
6. Only 5 perfect numbers exist below 10^8


================================================================================
RELATED PROBLEMS
================================================================================

- Ugly Number (Easy) - Number properties
- Happy Number (Easy) - Number manipulation
- Add Digits (Easy) - Number theory
- Power of Two (Easy) - Number properties
- Self Dividing Numbers (Easy) - Divisor checking
- Count Primes (Medium) - Prime numbers


================================================================================
