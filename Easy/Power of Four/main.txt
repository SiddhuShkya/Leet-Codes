================================================================================
POWER OF FOUR - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4^x.

EXAMPLES:
---------
Example 1:
  Input: n = 16
  Output: true

Example 2:
  Input: n = 5
  Output: false

Example 3:
  Input: n = 1
  Output: true

CONSTRAINTS:
------------
- -2^31 <= n <= 2^31 - 1

Follow-up: Could you solve it without loops/recursion?


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Distinguishing power of 4 from power of 2
2. Handling negative numbers and zero
3. Solving without loops (follow-up)
4. Using bit manipulation efficiently

ALGORITHM STEPS:
----------------
Approach 1: Bit Manipulation (Optimal)
1. Check if n is power of 2: n > 0 and (n & (n-1)) == 0
2. Check if the single 1-bit is at even position
3. Use mask 0x55555555 to check even positions

Approach 2: Loop Division
1. If n <= 0, return false
2. If n == 1, return true
3. While n > 1:
   - If n % 4 != 0, return false
   - Divide n by 4
4. Return true

Approach 3: Modulo Check
1. Check if power of 2
2. Check if n % 3 == 1


DETAILED EXPLANATION:
---------------------

Powers of 4 in Binary:
----------------------
1   = 0001 (4^0)
4   = 0100 (4^1)
16  = 00010000 (4^2)
64  = 01000000 (4^3)
256 = 0100000000 (4^4)

Pattern: Powers of 4 have single 1-bit at EVEN positions (0, 2, 4, 6, ...)

Powers of 2 (not 4):
--------------------
2  = 0010 (position 1 - odd)
8  = 1000 (position 3 - odd)
32 = 100000 (position 5 - odd)

Bit Manipulation Approach:
---------------------------
Step 1: Check if power of 2
  - n & (n-1) == 0

Step 2: Check if 1-bit is at even position
  - Use mask 0x55555555 = 01010101010101010101010101010101
  - This mask has 1's at all even positions
  - n & 0x55555555 != 0 means 1-bit is at even position

Example: n = 16
  16 in binary: 00010000
  16 & 15 = 0 ✓ (power of 2)
  16 & 0x55555555 = 00010000 & 01010101... = 00010000 ≠ 0 ✓
  Return true

Example: n = 8
  8 in binary: 1000
  8 & 7 = 0 ✓ (power of 2)
  8 & 0x55555555 = 1000 & 0101... = 0000 = 0 ✗
  Return false

Modulo Approach:
----------------
Observation: All powers of 4 satisfy (n % 3 == 1)

4^0 = 1  → 1 % 3 = 1 ✓
4^1 = 4  → 4 % 3 = 1 ✓
4^2 = 16 → 16 % 3 = 1 ✓
4^3 = 64 → 64 % 3 = 1 ✓

Why? 4 ≡ 1 (mod 3), so 4^x ≡ 1^x ≡ 1 (mod 3)


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Bit Manipulation ✓ OPTIMAL
def isPowerOfFour_bit(n):
    # Check if power of 2 AND 1-bit at even position
    return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0


# Approach 2: Loop Division (From original)
def isPowerOfFour_loop(n):
    if n == 1:
        return True
    if n <= 0:
        return False
    
    while n > 1:
        if n % 4 != 0:
            return False
        n = n // 4
    
    return True


# Approach 3: Modulo Check
def isPowerOfFour_mod(n):
    # Power of 2 AND n % 3 == 1
    return n > 0 and (n & (n - 1)) == 0 and n % 3 == 1


# Using logarithm (not recommended)
import math

def isPowerOfFour_log(n):
    if n <= 0:
        return False
    log_val = math.log(n, 4)
    return log_val == int(log_val)


# LeetCode Solution Class Format
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Bit Manipulation
-----------------------------
Time Complexity: O(1)
  - All operations are constant time
  - Total: O(1)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1) ✓ OPTIMAL

Approach 2: Loop Division
--------------------------
Time Complexity: O(log n)
  - Divide by 4 each iteration
  - log₄(n) iterations
  - Total: O(log n)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)

Approach 3: Modulo Check
-------------------------
Time Complexity: O(1)
  - Constant time operations
  - Total: O(1)

Space Complexity: O(1)
  - Only using variables
  - Total: O(1)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Power of 4
  Input: n = 16
  Output: true
  ✓ 4^2 = 16

Test Case 2: Not Power of 4
  Input: n = 5
  Output: false
  ✓ No x where 4^x = 5

Test Case 3: One
  Input: n = 1
  Output: true
  ✓ 4^0 = 1

Test Case 4: Power of 2 but not 4
  Input: n = 8
  Output: false
  ✓ 8 = 2^3, not a power of 4

Test Case 5: Zero
  Input: n = 0
  Output: false
  ✓ 0 is not a power of 4

Test Case 6: Negative
  Input: n = -64
  Output: false
  ✓ Negative numbers not powers of 4


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Bit Manipulation with Mask ✓ RECOMMENDED
-----------------------------------------------------
Check power of 2 and even bit position.

Pros:
  - O(1) time and space
  - No loops or recursion
  - Elegant and efficient
  - Meets follow-up requirement

Cons:
  - Requires understanding bit manipulation
  - Magic number 0x55555555

Approach 2: Modulo Check ✓ ALSO GOOD
-------------------------------------
Check power of 2 and n % 3 == 1.

Pros:
  - O(1) time and space
  - No magic numbers
  - Mathematical elegance

Cons:
  - Less intuitive why it works

Approach 3: Loop Division
--------------------------
Repeatedly divide by 4.

Pros:
  - Intuitive and easy to understand

Cons:
  - O(log n) time
  - Uses loops (violates follow-up)


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Only Checking Power of 2
   ❌ Returning true for all powers of 2
   ✓ Must distinguish 4^x from 2^x

2. Wrong Bit Mask
   ❌ Using wrong mask value
   ✓ Use 0x55555555 for even positions

3. Not Handling Zero/Negatives
   ❌ Not checking n <= 0
   ✓ Return false for n <= 0

4. Floating Point Issues
   ❌ Using log with floating point
   ✓ Use bit manipulation for exact results

5. Confusing with Power of Two
   ❌ Thinking same as Power of Two
   ✓ Power of 4 is subset of Power of 2


================================================================================
KEY TAKEAWAYS
================================================================================

1. Powers of 4 are powers of 2 with 1-bit at even positions
2. Mask 0x55555555 checks even bit positions
3. Alternative: n % 3 == 1 for all powers of 4
4. Must first verify it's a power of 2
5. Bit manipulation gives O(1) solution
6. Power of 4 ⊂ Power of 2


================================================================================
RELATED PROBLEMS
================================================================================

- Power of Two (Easy) - Similar for base 2
- Power of Three (Easy) - Similar for base 3
- Number of 1 Bits (Easy) - Counting set bits
- Single Number (Easy) - Bit manipulation
- Missing Number (Easy) - XOR technique
- Reverse Bits (Easy) - Bit operations


================================================================================
