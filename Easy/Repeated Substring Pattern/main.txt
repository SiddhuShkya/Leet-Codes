================================================================================
REPEATED SUBSTRING PATTERN - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given a string s, check if it can be constructed by taking a substring of it 
and appending multiple copies of the substring together.

EXAMPLES:
---------
Example 1:
  Input: s = "abab"
  Output: true
  Explanation: It is the substring "ab" twice.

Example 2:
  Input: s = "aba"
  Output: false

Example 3:
  Input: s = "abcabcabcabc"
  Output: true
  Explanation: It is the substring "abc" four times or the substring "abcabc" twice.

CONSTRAINTS:
------------
- 1 <= s.length <= 10^4
- s consists of lowercase English letters.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding the repeating unit
2. Optimizing check to avoid O(n^2)
3. Handling edge cases

ALGORITHM STEPS:
----------------
Approach 1: Brute Force (O(n^2))
1. Iterate length `l` from 1 to `n // 2`.
2. If `n % l == 0`:
   - Substring `sub = s[:l]`.
   - Construct `formed = sub * (n // l)`.
   - If `formed == s`, return True.
3. Return False.

Approach 2: String Manipulation Trick (O(n)) ✓ OPTIMAL
1. Concatenate string with itself: `ss = s + s`.
2. Remove first and last characters: `ss_folded = ss[1:-1]`.
3. Check if `s` is in `ss_folded`.
4. If yes, return True.

Why Approach 2 works?
---------------------
If s is formed by repeating block P (s = P P ... P), then s + s = P P ... P P ... P.
Removing first and last chars breaks the first P and last P.
But since P is repeating, the inner part still contains a full s (shifted by length of P).
Example: s = "abab" (P="ab")
s+s = "abababab"
Trimmed: "bababa"
"abab" is inside "bababa". True.

Example: s = "aba"
s+s = "abaaba"
Trimmed: "baab"
"aba" is NOT inside "baab". False.


DETAILED EXPLANATION:
---------------------

Brute Force Logic:
------------------
s = "abab", n=4
1. l=1 ("a"). 4%1==0. "a"*4 = "aaaa" != "abab".
2. l=2 ("ab"). 4%2==0. "ab"*2 = "abab" == "abab". Return True.

s = "aba", n=3
1. l=1 ("a"). 3%1==0. "a"*3 = "aaa" != "aba".
2. Loop ends (l goes up to n//2 = 1). Return False.

String Trick Logic:
-------------------
Theorem: s is periodic iff s in (s+s)[1:-1].
Proof involves rotation invariance. If s is periodic with period p, shifting s by p 
results in s. (s+s) contains all rotations. If s is found in (s+s) at index k (where 0 < k < n), 
then s is a rotation of itself by k, implying periodicity.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Brute Force (Intuitive)
class SolutionBrute:
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        for i in range(1, n // 2 + 1):
            if n % i == 0:
                sub = s[:i]
                if sub * (n // i) == s:
                    return True
        return False


# Approach 2: String Trick (Optimal & Clever) ✓ RECOMMENDED
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        # (s + s)[1:-1] removes the first char of first copy 
        # and last char of second copy.
        # If s is composed of repeating substrings, it will appear in the middle.
        return s in (s + s)[1:-1]


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Brute Force
-----------------------
Time Complexity: O(n^2)
  - Loop runs n/2 times.
  - String construction/comparison takes O(n).
  - Total O(n^2).

Space Complexity: O(n)
  - Store constructed string.

Approach 2: String Trick
------------------------
Time Complexity: O(n)
  - String concatenation and find operation are O(n) (KMP algorithm underneath).

Space Complexity: O(n)
  - Create string of size 2n.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Simple Repeat
  Input: "abab"
  Output: true
  ✓ "ab" * 2

Test Case 2: No Repeat
  Input: "aba"
  Output: false
  ✓ Prime length usually fails unless single char

Test Case 3: Long Repeat
  Input: "abcabcabcabc"
  Output: true
  ✓ "abc" * 4

Test Case 4: Single Char
  Input: "a"
  Output: false (Wait, constraints say len >= 1. "a" cannot be substring of itself multiple times?
  Actually, problem says "substring of it and appending MULTIPLE copies".
  "a" -> substring "a" repeated 1 time? No, must be at least 2 copies.
  So "a" is False. "aa" is True ("a"*2).
  Let's check logic:
  Brute force: range(1, 0) -> empty loop -> False. Correct.
  String trick: "aa"[1:-1] -> "" -> "a" in "" -> False. Correct.

Test Case 5: "aa"
  Brute: l=1 ("a"). "a"*2 == "aa". True.
  Trick: "aaaa"[1:-1] -> "aa". "aa" in "aa". True.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Brute Force
-----------------------
Pros:
  - Easy to understand.
  - No "magic".

Cons:
  - O(n^2) is slow for large N (though N=10^4 might pass).

Approach 2: KMP Algorithm
-------------------------
Compute LPS (Longest Prefix Suffix) array.
If len % (len - lps[-1]) == 0 and lps[-1] > 0, then True.
Pros: O(n) time, O(n) space.
Cons: Complex to implement.

Approach 3: String Trick ✓ RECOMMENDED
--------------------------------------
Pros:
  - One liner.
  - O(n).

Cons:
  - Requires knowing the theorem.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Loop Range
   ❌ range(1, n)
   ✓ range(1, n // 2 + 1) (substring must be at most half length)

2. Single Character Input
   ✓ "a" should return False (cannot repeat multiple times to form "a")

3. String Trick Indices
   ❌ (s+s)[1:] or (s+s)[:-1]
   ✓ Must exclude BOTH ends [1:-1] to ensure we don't match the original s at start or end


================================================================================
KEY TAKEAWAYS
================================================================================

1. Periodic string s is a rotation of itself.
2. `s in (s+s)[1:-1]` is a standard check for periodicity.
3. Brute force is acceptable but O(n^2).
4. Time O(n), Space O(n).


================================================================================
RELATED PROBLEMS
================================================================================

- Implement strStr() (Easy)
- Repeated String Match (Medium)
- Rotate String (Easy) - Uses similar s+s trick


================================================================================
