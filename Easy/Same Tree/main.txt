================================================================================
SAME TREE - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given the roots of two binary trees p and q, write a function to check if they 
are the same or not.

Two binary trees are considered the same if they are structurally identical, and 
the nodes have the same value.

EXAMPLES:
---------
Example 1:
  Input: p = [1,2,3], q = [1,2,3]
  Output: true

Example 2:
  Input: p = [1,2], q = [1,null,2]
  Output: false

Example 3:
  Input: p = [1,2,1], q = [1,1,2]
  Output: false

CONSTRAINTS:
------------
- The number of nodes in both trees is in the range [0, 100]
- -10^4 <= Node.val <= 10^4


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Comparing tree structure and values
2. Handling null nodes correctly
3. Recursive vs iterative approach
4. Edge cases (empty trees, single node)

ALGORITHM STEPS:
----------------
Approach 1: Recursive (Optimal)
1. Base case: if both null, return true
2. If one null and other not, return false
3. If values different, return false
4. Recursively check left and right subtrees

Approach 2: Iterative (BFS/DFS)
1. Use queue/stack to traverse both trees
2. Compare nodes at each step
3. Return false if any mismatch
4. Return true if complete traversal matches


DETAILED EXPLANATION:
---------------------

Recursive Approach:
-------------------
Natural solution for tree problems.

Base cases:
1. Both p and q are null → trees are same (true)
2. One is null, other isn't → trees different (false)
3. Values are different → trees different (false)

Recursive case:
Check if left subtrees are same AND right subtrees are same

Example: p = [1,2,3], q = [1,2,3]
------------------------------------------
Compare roots: 1 == 1 ✓
  Compare left subtrees (2 vs 2):
    2 == 2 ✓
    Both have no children ✓
  Compare right subtrees (3 vs 3):
    3 == 3 ✓
    Both have no children ✓
Return true

Example: p = [1,2], q = [1,null,2]
-----------------------------------
Compare roots: 1 == 1 ✓
  Compare left subtrees (2 vs null):
    One is null, other isn't ✗
Return false


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Recursive ✓ OPTIMAL
class Solution(object):
    def isSameTree(self, p, q):
        # Both null
        if p is None and q is None:
            return True
        
        # One null, other not
        if p is None or q is None:
            return False
        
        # Values different
        if p.val != q.val:
            return False
        
        # Check left and right subtrees
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)


# More concise version
def isSameTree_concise(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree_concise(p.left, q.left) and isSameTree_concise(p.right, q.right)


# Approach 2: Iterative (BFS)
from collections import deque

def isSameTree_iterative(p, q):
    queue = deque([(p, q)])
    
    while queue:
        node1, node2 = queue.popleft()
        
        # Both null
        if not node1 and not node2:
            continue
        
        # One null or values different
        if not node1 or not node2 or node1.val != node2.val:
            return False
        
        # Add children to queue
        queue.append((node1.left, node2.left))
        queue.append((node1.right, node2.right))
    
    return True


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Recursive
----------------------
Time Complexity: O(min(n, m))
  - n = number of nodes in p
  - m = number of nodes in q
  - Visit each node once until mismatch
  - Worst case: O(min(n, m))

Space Complexity: O(min(h1, h2))
  - h1 = height of tree p
  - h2 = height of tree q
  - Recursion stack depth
  - Worst case (skewed tree): O(n)
  - Best case (balanced): O(log n)

Approach 2: Iterative
---------------------
Time Complexity: O(min(n, m))
  - Same as recursive
  - Total: O(min(n, m))

Space Complexity: O(min(n, m))
  - Queue stores nodes
  - Worst case: O(n)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Identical Trees
  Input: p = [1,2,3], q = [1,2,3]
  Output: true
  ✓ Same structure and values

Test Case 2: Different Structure
  Input: p = [1,2], q = [1,null,2]
  Output: false
  ✓ Different structure

Test Case 3: Different Values
  Input: p = [1,2,1], q = [1,1,2]
  Output: false
  ✓ Same structure, different values

Test Case 4: Both Empty
  Input: p = null, q = null
  Output: true
  ✓ Both empty trees are same

Test Case 5: One Empty
  Input: p = [1], q = null
  Output: false
  ✓ One empty, one not


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Recursive ✓ RECOMMENDED
------------------------------------
Natural recursive solution.

Pros:
  - Clean and elegant
  - Easy to understand
  - Concise code
  - Natural for tree problems

Cons:
  - Uses recursion stack space
  - Stack overflow for very deep trees

Approach 2: Iterative
---------------------
Use queue for BFS traversal.

Pros:
  - No recursion
  - Explicit control over traversal
  - Can handle very deep trees

Cons:
  - More code
  - Less intuitive
  - Uses queue space


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Wrong Null Checks
   ❌ Not handling both null case first
   ✓ Check both null before one null

2. Not Checking Values
   ❌ Only checking structure
   ✓ Check both structure and values

3. Wrong Logical Operator
   ❌ Using OR instead of AND for subtrees
   ✓ Both left AND right must be same

4. Not Handling Empty Trees
   ❌ Assuming trees are non-empty
   ✓ Handle null root cases

5. Comparing Pointers
   ❌ Comparing p == q (pointer equality)
   ✓ Compare structure and values


================================================================================
KEY TAKEAWAYS
================================================================================

1. Recursive solution is natural for tree problems
2. Must check both structure and values
3. Base cases: both null, one null, values different
4. Use AND for combining subtree results
5. Time complexity is O(min(n, m))
6. Classic tree traversal problem


================================================================================
RELATED PROBLEMS
================================================================================

- Symmetric Tree (Easy) - Check if tree is symmetric
- Subtree of Another Tree (Easy) - Check if subtree
- Invert Binary Tree (Easy) - Tree transformation
- Maximum Depth of Binary Tree (Easy) - Tree traversal
- Balanced Binary Tree (Easy) - Tree properties
- Merge Two Binary Trees (Easy) - Tree merging


================================================================================
