================================================================================
VALID ANAGRAM - LEETCODE EASY
================================================================================

PROBLEM STATEMENT:
------------------
Given two strings s and t, return true if t is an anagram of s, and false 
otherwise.

An anagram is a word or phrase formed by rearranging the letters of a different 
word or phrase, typically using all the original letters exactly once.

EXAMPLES:
---------
Example 1:
  Input: s = "anagram", t = "nagaram"
  Output: true

Example 2:
  Input: s = "rat", t = "car"
  Output: false

CONSTRAINTS:
------------
- 1 <= s.length, t.length <= 5 * 10^4
- s and t consist of lowercase English letters


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Ensuring both strings have same length
2. Checking if all characters match with same frequency
3. Choosing efficient comparison method
4. Handling edge cases (empty strings, single character)

ALGORITHM STEPS:
----------------
Approach 1: Sorting (Simple)
1. Check if lengths are equal (if not, return false)
2. Sort both strings
3. Compare sorted strings
4. Return true if equal, false otherwise

Approach 2: Hash Map/Counter (Optimal for large strings)
1. Check if lengths are equal
2. Count frequency of each character in both strings
3. Compare frequency maps
4. Return true if maps are equal

Approach 3: Single Hash Map
1. Check if lengths are equal
2. Count characters in first string
3. Decrement counts using second string
4. Check if all counts are zero


DETAILED EXPLANATION:
---------------------

Why Length Check is Important:
-------------------------------
If strings have different lengths, they cannot be anagrams. This is a quick
O(1) check that can save processing time.

Sorting Approach:
-----------------
Example with s = "anagram", t = "nagaram":
  - sorted(s) = ['a', 'a', 'a', 'g', 'm', 'n', 'r']
  - sorted(t) = ['a', 'a', 'a', 'g', 'm', 'n', 'r']
  - Compare: equal → true

Example with s = "rat", t = "car":
  - sorted(s) = ['a', 'r', 't']
  - sorted(t) = ['a', 'c', 'r']
  - Compare: not equal → false

Hash Map Approach:
------------------
Count frequency of each character and compare.

Example with s = "anagram":
  - Frequency: {'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1}
  
Example with t = "nagaram":
  - Frequency: {'n': 1, 'a': 3, 'g': 1, 'r': 1, 'm': 1}
  
Both have same frequencies → true


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Sorting - Simple and Clean
def isAnagram(s, t):
    if len(s) == len(t):
        if sorted(s) == sorted(t):
            return True
        return False
    return False

# More concise version
def isAnagram_v2(s, t):
    return sorted(s) == sorted(t)


# Approach 2: Using Counter (Hash Map)
from collections import Counter

def isAnagram_counter(s, t):
    return Counter(s) == Counter(t)


# Approach 3: Manual Hash Map
def isAnagram_hashmap(s, t):
    if len(s) != len(t):
        return False
    
    char_count = {}
    
    # Count characters in s
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
    
    # Decrement using characters in t
    for char in t:
        if char not in char_count:
            return False
        char_count[char] -= 1
        if char_count[char] < 0:
            return False
    
    return all(count == 0 for count in char_count.values())


# LeetCode Solution Class Format
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Sorting
-------------------
Time Complexity: O(n log n)
  - Sorting s: O(n log n) where n = len(s)
  - Sorting t: O(m log m) where m = len(t)
  - Comparison: O(n)
  - Total: O(n log n) assuming n ≈ m

Space Complexity: O(n)
  - Sorting creates new sorted lists
  - Total: O(n) for sorted arrays

Approach 2: Hash Map/Counter
-----------------------------
Time Complexity: O(n)
  - Counting characters in s: O(n)
  - Counting characters in t: O(m)
  - Comparing maps: O(k) where k = unique characters (max 26)
  - Total: O(n + m) = O(n)

Space Complexity: O(1) or O(k)
  - Hash map stores at most 26 characters (lowercase English)
  - Can be considered O(1) since it's bounded
  - More precisely: O(k) where k ≤ 26


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Valid Anagram
  Input: s = "anagram", t = "nagaram"
  Output: true
  ✓ All characters match with same frequency

Test Case 2: Invalid Anagram - Different Characters
  Input: s = "rat", t = "car"
  Output: false
  ✓ Different characters ('t' vs 'c')

Test Case 3: Different Lengths
  Input: s = "a", t = "ab"
  Output: false
  ✓ Different lengths cannot be anagrams

Test Case 4: Single Character
  Input: s = "a", t = "a"
  Output: true
  ✓ Single matching character

Test Case 5: Empty Strings
  Input: s = "", t = ""
  Output: true
  ✓ Empty strings are anagrams of each other

Test Case 6: Same Characters, Different Frequency
  Input: s = "aaab", t = "aab"
  Output: false
  ✓ Different frequencies


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Sorting ✓ RECOMMENDED FOR SIMPLICITY
-------------------------------------------------
Sort both strings and compare.

Pros:
  - Very simple and readable
  - One-liner solution possible
  - Easy to understand

Cons:
  - O(n log n) time complexity
  - Not optimal for very large strings
  - Creates new sorted arrays

Approach 2: Hash Map/Counter ✓ OPTIMAL
---------------------------------------
Count character frequencies and compare.

Pros:
  - O(n) time complexity
  - Optimal for large strings
  - Can short-circuit on first mismatch

Cons:
  - Slightly more code
  - Uses O(k) extra space
  - More complex than sorting

Approach 3: Array Counting (For lowercase only)
------------------------------------------------
Use array of size 26 for character counts.

Pros:
  - O(n) time, O(1) space (fixed size 26)
  - Very fast for lowercase English only
  - No hash map overhead

Cons:
  - Only works for lowercase English letters
  - Less flexible than hash map


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Forgetting Length Check
   ❌ Not checking if len(s) != len(t) first
   ✓ Quick O(1) check before processing

2. Case Sensitivity
   ❌ Not handling uppercase/lowercase properly
   ✓ Problem states lowercase only, but be aware

3. Incorrect Frequency Counting
   ❌ Not handling duplicate characters correctly
   ✓ Use proper counting mechanism

4. Comparing Unsorted Strings
   ❌ Comparing s == t directly
   ✓ Must sort or count frequencies first

5. Not Handling Empty Strings
   ❌ Special casing empty strings unnecessarily
   ✓ Algorithm handles them naturally


================================================================================
KEY TAKEAWAYS
================================================================================

1. Sorting is simple but O(n log n) time complexity
2. Hash map approach is optimal with O(n) time
3. For lowercase English only, array of size 26 works well
4. Always check lengths first for quick rejection
5. Anagram means same characters with same frequencies
6. Python's Counter makes this problem trivial


================================================================================
RELATED PROBLEMS
================================================================================

- Group Anagrams (Medium) - Group strings that are anagrams
- Find All Anagrams in a String (Medium) - Find anagram substrings
- Permutation in String (Medium) - Similar character frequency problem
- Valid Palindrome (Easy) - Another string comparison problem
- Isomorphic Strings (Easy) - Character mapping problem


================================================================================
