================================================================================
COUNT NICE PAIRS IN AN ARRAY - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You are given an array nums that consists of non-negative integers. Let us define 
rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, 
and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the 
following conditions:

- 0 <= i < j < nums.length
- nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])

Return the number of nice pairs of indices. Since that number can be too large, 
return it modulo 10^9 + 7.

EXAMPLES:
---------
Example 1:
  Input: nums = [42,11,1,97]
  Output: 2
  Explanation: The two pairs are:
  - (0,3): 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
  - (1,2): 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.

Example 2:
  Input: nums = [13,10,35,24,76]
  Output: 4

CONSTRAINTS:
------------
- 1 <= nums.length <= 10^5
- 0 <= nums[i] <= 10^9


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Equation manipulation to simplify the condition
2. Efficiently counting pairs
3. Handling large numbers and modulo

ALGORITHM STEPS:
----------------
Approach 1: Hash Map + Math (O(N)) ✓ OPTIMAL
1. Analyze the condition: `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])`.
2. Rearrange terms to group `i` and `j`:
   `nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])`.
3. Let `diff(x) = x - rev(x)`.
   The condition becomes `diff(nums[i]) == diff(nums[j])`.
4. Problem reduces to: Count pairs (i, j) such that `diff(nums[i]) == diff(nums[j])`.
5. Calculate `diff` for every number.
6. Store frequencies in a Hash Map.
7. If a value appears `k` times, it contributes `k * (k - 1) / 2` pairs.
   (Combination formula nC2).
8. Sum up pairs and return modulo 10^9 + 7.


DETAILED EXPLANATION:
---------------------

Input: [42, 11, 1, 97]

1. Calculate diffs:
   - 42: 42 - 24 = 18
   - 11: 11 - 11 = 0
   - 1: 1 - 1 = 0
   - 97: 97 - 79 = 18

2. Frequencies:
   - 18: 2 times
   - 0: 2 times

3. Pairs:
   - For 18: 2 * 1 / 2 = 1 pair.
   - For 0: 2 * 1 / 2 = 1 pair.
   - Total: 2.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Hash Map (Optimal) ✓ RECOMMENDED
from collections import defaultdict

class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        def rev(x):
            # Reverse integer
            return int(str(x)[::-1])
            
        freq = defaultdict(int)
        ans = 0
        
        for num in nums:
            # Calculate transformation
            val = num - rev(num)
            
            # Add current count to answer (pairs formed with previous occurrences)
            ans = (ans + freq[val]) % MOD
            
            # Increment frequency
            freq[val] += 1
            
        return ans


# Alternative implementation (Calculate all freqs first)
class SolutionFreq:
    def countNicePairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        freq = defaultdict(int)
        
        for num in nums:
            val = num - int(str(num)[::-1])
            freq[val] += 1
            
        ans = 0
        for count in freq.values():
            # nC2 formula: n * (n-1) / 2
            ans = (ans + (count * (count - 1) // 2)) % MOD
            
        return ans


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N * D)
  - N is array length.
  - D is number of digits (log10(num)) for reversing. D <= 10.
  - Effectively O(N).

Space Complexity: O(N)
  - Hash map stores up to N unique differences.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: [42, 11, 1, 97]
  Diffs: [18, 0, 0, 18]
  Freqs: {18:2, 0:2} -> 1 + 1 = 2.
  ✓ Correct

Test Case 2: [13, 10, 35, 24, 76]
  Diffs:
  13-31 = -18
  10-1 = 9
  35-53 = -18
  24-42 = -18
  76-67 = 9
  Freqs: {-18: 3, 9: 2}
  Pairs: 3C2 (3) + 2C2 (1) = 4.
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Hash Map ✓ RECOMMENDED
----------------------------------
Pros:
  - O(N) time.
  - Simple logic transformation.

Cons:
  - None.

Approach 2: Brute Force
-----------------------
Check every pair.
Pros: Trivial.
Cons: O(N^2) - TLE for N=10^5.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Modulo Arithmetic
   ❌ Applying mod at the very end only
   ✓ Apply mod during summation to avoid overflow (though Python handles large ints, it's good practice).

2. Reversing Logic
   ✓ `int(str(x)[::-1])` is easiest in Python.
   ✓ Math approach `res = res*10 + num%10` works too.

3. Equation Rearrangement
   ✓ Crucial step. Without `nums[i] - rev(nums[i])`, problem is hard.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Algebraic manipulation simplifies "pair condition" problems.
   Move `i` terms to one side, `j` terms to other.
2. `count * (count - 1) // 2` is the number of pairs for `count` identical items.
3. Time O(N), Space O(N).


================================================================================
RELATED PROBLEMS
================================================================================

- Two Sum (Easy)
- Continuous Subarray Sum (Medium)
- Subarray Sum Equals K (Medium)


================================================================================
