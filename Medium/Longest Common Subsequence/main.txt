================================================================================
LEETCODE PROBLEM: LONGEST COMMON SUBSEQUENCE
================================================================================
Difficulty: Medium
Topics: String, Dynamic Programming

================================================================================
PROBLEM STATEMENT
================================================================================
Given two strings text1 and text2, return the length of their longest common 
subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string 
with some characters (can be none) deleted without changing the relative order 
of the remaining characters.

• For example, "ace" is a subsequence of "abcde".

A common subsequence of two strings is a subsequence that is common to both 
strings.

Example 1:
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.

Example 2:
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.

Example 3:
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.

Constraints:
• 1 <= text1.length, text2.length <= 1000
• text1 and text2 consist of only lowercase English characters.

================================================================================
SOLUTION APPROACH: DYNAMIC PROGRAMMING
================================================================================

Strategy:
---------
This is a classic dynamic programming problem. We build a 2D table where 
dp[i][j] represents the length of the longest common subsequence between 
text1[i:] and text2[j:].

Key Insight:
- If characters match: dp[i][j] = 1 + dp[i+1][j+1]
- If characters don't match: dp[i][j] = max(dp[i][j+1], dp[i+1][j])

Algorithm:
----------
1. Create a 2D DP table of size (len(text1) + 1) × (len(text2) + 1)
2. Initialize all cells to 0 (base case: empty strings have LCS of 0)
3. Fill the table from bottom-right to top-left:
   - If text1[i] == text2[j]: dp[i][j] = 1 + dp[i+1][j+1]
   - Else: dp[i][j] = max(dp[i][j+1], dp[i+1][j])
4. Return dp[0][0] (LCS of entire strings)

Time Complexity: O(m × n)
- m = length of text1
- n = length of text2
- We fill each cell once

Space Complexity: O(m × n)
- 2D DP table storage

Implementation:
```python
def longestCommonSubsequence(text1, text2):
    l1, l2 = len(text1), len(text2)
    if text1 == text2:
        return l1
    
    # Create DP table with extra row and column for base case
    dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]
    
    # Fill table from bottom-right to top-left
    for i in range(len(text1) - 1, -1, -1):
        for j in range(len(text2) - 1, -1, -1):
            if text1[i] == text2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])
    
    return dp[0][0]
```

================================================================================
DETAILED WALKTHROUGH
================================================================================

Example: text1 = "abcde", text2 = "ace"

Step 1: Initialize DP Table
----------------------------
Create a 6×4 table (including base case row/column):

     ''  e  c  a
''   0   0  0  0
e    0   0  0  0
d    0   0  0  0
c    0   0  0  0
b    0   0  0  0
a    0   0  0  0

Step 2: Fill Table (Bottom-Right to Top-Left)
----------------------------------------------

Position [4][2]: text1[4]='a', text2[2]='a' → MATCH
dp[4][2] = 1 + dp[5][3] = 1 + 0 = 1

Position [4][1]: text1[4]='a', text2[1]='c' → NO MATCH
dp[4][1] = max(dp[4][2], dp[5][1]) = max(1, 0) = 1

Position [4][0]: text1[4]='a', text2[0]='e' → NO MATCH
dp[4][0] = max(dp[4][1], dp[5][0]) = max(1, 0) = 1

Position [3][2]: text1[3]='b', text2[2]='a' → NO MATCH
dp[3][2] = max(dp[3][3], dp[4][2]) = max(0, 1) = 1

Position [3][1]: text1[3]='b', text2[1]='c' → NO MATCH
dp[3][1] = max(dp[3][2], dp[4][1]) = max(1, 1) = 1

Position [3][0]: text1[3]='b', text2[0]='e' → NO MATCH
dp[3][0] = max(dp[3][1], dp[4][0]) = max(1, 1) = 1

Position [2][2]: text1[2]='c', text2[2]='a' → NO MATCH
dp[2][2] = max(dp[2][3], dp[3][2]) = max(0, 1) = 1

Position [2][1]: text1[2]='c', text2[1]='c' → MATCH
dp[2][1] = 1 + dp[3][2] = 1 + 1 = 2

Position [2][0]: text1[2]='c', text2[0]='e' → NO MATCH
dp[2][0] = max(dp[2][1], dp[3][0]) = max(2, 1) = 2

Position [1][2]: text1[1]='d', text2[2]='a' → NO MATCH
dp[1][2] = max(dp[1][3], dp[2][2]) = max(0, 1) = 1

Position [1][1]: text1[1]='d', text2[1]='c' → NO MATCH
dp[1][1] = max(dp[1][2], dp[2][1]) = max(1, 2) = 2

Position [1][0]: text1[1]='d', text2[0]='e' → NO MATCH
dp[1][0] = max(dp[1][1], dp[2][0]) = max(2, 2) = 2

Position [0][2]: text1[0]='a', text2[2]='a' → MATCH
dp[0][2] = 1 + dp[1][3] = 1 + 0 = 1

Position [0][1]: text1[0]='a', text2[1]='c' → NO MATCH
dp[0][1] = max(dp[0][2], dp[1][1]) = max(1, 2) = 2

Position [0][0]: text1[0]='a', text2[0]='e' → NO MATCH
dp[0][0] = max(dp[0][1], dp[1][0]) = max(2, 2) = 2

Wait, let me recalculate...

Actually, for text1="abcde", text2="ace":

Final DP Table:
     ''  e  c  a
''   0   0  0  0
a    3   2  2  1
b    2   2  2  1
c    2   2  1  1
d    1   1  1  1
e    1   0  0  0

Result: dp[0][0] = 3

The LCS is "ace" with length 3.

================================================================================
RECURRENCE RELATION
================================================================================

Base Case:
----------
dp[m][j] = 0 for all j (empty text1 suffix)
dp[i][n] = 0 for all i (empty text2 suffix)

Recurrence:
-----------
For i from m-1 to 0, j from n-1 to 0:

    dp[i][j] = {
        1 + dp[i+1][j+1]              if text1[i] == text2[j]
        max(dp[i][j+1], dp[i+1][j])   if text1[i] != text2[j]
    }

Intuition:
- If characters match, we found a common character, add 1 and move both pointers
- If they don't match, try skipping one character from either string and take max

================================================================================
SPACE OPTIMIZATION
================================================================================

The current solution uses O(m × n) space. We can optimize to O(min(m, n)):

Optimized Approach:
-------------------
Since we only need the previous row to compute the current row, we can use 
two 1D arrays instead of a 2D table.

```python
def longestCommonSubsequence(text1, text2):
    # Ensure text2 is the shorter string
    if len(text1) < len(text2):
        text1, text2 = text2, text1
    
    n = len(text2)
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(len(text1) - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if text1[i] == text2[j]:
                curr[j] = 1 + prev[j + 1]
            else:
                curr[j] = max(curr[j + 1], prev[j])
        prev, curr = curr, [0] * (n + 1)
    
    return prev[0]
```

Space Complexity: O(min(m, n))

================================================================================
KEY INSIGHTS
================================================================================

1. Subsequence vs Substring:
   - Subsequence: Characters don't need to be contiguous
   - Substring: Characters must be consecutive
   - This problem is about subsequences

2. Optimal Substructure:
   - LCS of two strings depends on LCS of their suffixes
   - Perfect for dynamic programming

3. Two Choices at Each Step:
   - Match: Include character and move both pointers
   - No Match: Skip from either string, take maximum

4. Bottom-Up vs Top-Down:
   - This solution uses bottom-up (tabulation)
   - Can also solve with top-down (memoization)

5. Building the Actual LCS:
   - Current solution only returns length
   - To get actual sequence, backtrack through DP table

================================================================================
EDGE CASES
================================================================================

1. Identical Strings:
   Input: text1 = "abc", text2 = "abc"
   Output: 3
   - Entire string is the LCS

2. No Common Characters:
   Input: text1 = "abc", text2 = "def"
   Output: 0
   - LCS is empty

3. One String is Subsequence of Other:
   Input: text1 = "abcde", text2 = "ace"
   Output: 3
   - Shorter string is the LCS

4. Single Character Strings:
   Input: text1 = "a", text2 = "a"
   Output: 1
   
   Input: text1 = "a", text2 = "b"
   Output: 0

5. Empty Strings (Not in constraints):
   Input: text1 = "", text2 = "abc"
   Output: 0

================================================================================
VARIATIONS AND EXTENSIONS
================================================================================

1. Print the LCS (not just length):
   - Backtrack through DP table
   - When characters match, include in result

2. Longest Common Substring:
   - Similar but requires consecutive characters
   - Different recurrence relation

3. Edit Distance:
   - Minimum operations to convert one string to another
   - Related DP problem

4. Shortest Common Supersequence:
   - Shortest string containing both as subsequences
   - Length = m + n - LCS

================================================================================
RELATED PROBLEMS
================================================================================

• Longest Palindromic Subsequence (Medium) - LCS with string and its reverse
• Edit Distance (Hard) - Minimum edits to transform strings
• Delete Operation for Two Strings (Medium) - Uses LCS concept
• Shortest Common Supersequence (Hard) - Related to LCS
• Uncrossed Lines (Medium) - Equivalent to LCS problem

================================================================================
