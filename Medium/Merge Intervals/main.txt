================================================================================
LEETCODE PROBLEM: MERGE INTERVALS
================================================================================
Difficulty: Medium
Topics: Array, Sorting

================================================================================
PROBLEM STATEMENT
================================================================================
Given an array of intervals where intervals[i] = [start_i, end_i], merge all 
overlapping intervals, and return an array of the non-overlapping intervals 
that cover all the intervals in the input.

Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

Constraints:
• 1 <= intervals.length <= 10^4
• intervals[i].length == 2
• 0 <= start_i <= end_i <= 10^4

================================================================================
SOLUTION APPROACH: SORT AND MERGE
================================================================================

Strategy:
---------
1. Sort intervals by start time
2. Iterate through sorted intervals
3. Merge overlapping intervals as we go

Key Insight:
After sorting by start time, we only need to check if the current interval 
overlaps with the last merged interval. If current.start <= last.end, they 
overlap and should be merged.

Algorithm:
----------
1. Sort intervals by start time: intervals.sort(key=lambda x: x[0])
2. Initialize result with first interval: result = [intervals[0]]
3. For each remaining interval:
   a. If it overlaps with last interval in result:
      - Merge by updating end time: result[-1][1] = max(result[-1][1], current[1])
   b. Else:
      - Add as new interval: result.append(current)
4. Return result

Overlap Condition:
------------------
Two intervals [a, b] and [c, d] overlap if:
- c <= b (assuming a <= c after sorting)

Merge Operation:
----------------
When merging [a, b] and [c, d]:
- New interval: [a, max(b, d)]

Time Complexity: O(n log n)
- Sorting takes O(n log n)
- Merging takes O(n)
- Overall: O(n log n)

Space Complexity: O(n)
- Result array storage
- Or O(log n) if we don't count output (for sorting)

Implementation:
```python
class Solution(object):
    def merge(self, intervals):
        if not intervals:
            return []
        
        # Sort intervals by start time
        intervals.sort(key=lambda x: x[0])
        
        # Initialize result with first interval
        result = [intervals[0]]
        
        # Iterate through remaining intervals
        for current in intervals[1:]:
            last = result[-1]
            
            # Check if current overlaps with last merged interval
            if current[0] <= last[1]:
                # Merge: update end time to maximum
                last[1] = max(last[1], current[1])
            else:
                # No overlap: add as new interval
                result.append(current)
        
        return result
```

================================================================================
DETAILED WALKTHROUGH
================================================================================

Example: intervals = [[1,3],[2,6],[8,10],[15,18]]

Step 1: Sort by Start Time
---------------------------
Already sorted: [[1,3],[2,6],[8,10],[15,18]]

Step 2: Initialize Result
--------------------------
result = [[1,3]]

Step 3: Process Each Interval
------------------------------

Iteration 1: current = [2,6]
- last = [1,3]
- Check overlap: 2 <= 3? YES
- Merge: [1, max(3, 6)] = [1,6]
- result = [[1,6]]

Iteration 2: current = [8,10]
- last = [1,6]
- Check overlap: 8 <= 6? NO
- Add new interval
- result = [[1,6], [8,10]]

Iteration 3: current = [15,18]
- last = [8,10]
- Check overlap: 15 <= 10? NO
- Add new interval
- result = [[1,6], [8,10], [15,18]]

Final Result: [[1,6], [8,10], [15,18]]

================================================================================
VISUAL REPRESENTATION
================================================================================

Before Merge:
-------------
[1,3]:    |---|
[2,6]:      |-----|
[8,10]:              |--|
[15,18]:                    |----|

After Merge:
------------
[1,6]:    |-------|
[8,10]:              |--|
[15,18]:                    |----|

Example 2: intervals = [[1,4],[4,5]]
-------------------------------------
[1,4]:    |----|
[4,5]:         |-|

Overlap at point 4, merge to:
[1,5]:    |------|

Example 3: intervals = [[1,4],[2,3]]
-------------------------------------
[1,4]:    |-----|
[2,3]:      |--|

[2,3] is completely inside [1,4], merge to:
[1,4]:    |-----|

================================================================================
EDGE CASES
================================================================================

1. Single Interval:
   Input: [[1,3]]
   Output: [[1,3]]
   - Nothing to merge

2. No Overlaps:
   Input: [[1,2],[3,4],[5,6]]
   Output: [[1,2],[3,4],[5,6]]
   - All intervals remain separate

3. All Overlapping:
   Input: [[1,4],[2,5],[3,6]]
   Output: [[1,6]]
   - All merge into one interval

4. Touching Intervals:
   Input: [[1,4],[4,5]]
   Output: [[1,5]]
   - Intervals touching at boundary are considered overlapping

5. Nested Intervals:
   Input: [[1,10],[2,3],[4,5]]
   Output: [[1,10]]
   - Smaller intervals completely inside larger one

6. Unsorted Input:
   Input: [[2,6],[1,3],[8,10]]
   Output: [[1,6],[8,10]]
   - Must sort first

7. Same Start Times:
   Input: [[1,4],[1,5]]
   Output: [[1,5]]
   - Take maximum end time

================================================================================
ALTERNATIVE APPROACHES
================================================================================

APPROACH 1: Using Stack
------------------------
Similar logic but using stack data structure:
```python
def merge(self, intervals):
    intervals.sort(key=lambda x: x[0])
    stack = [intervals[0]]
    
    for current in intervals[1:]:
        if current[0] <= stack[-1][1]:
            stack[-1][1] = max(stack[-1][1], current[1])
        else:
            stack.append(current)
    
    return stack
```

APPROACH 2: In-Place Modification
----------------------------------
Modify input array directly (if allowed):
```python
def merge(self, intervals):
    intervals.sort(key=lambda x: x[0])
    i = 0
    
    for j in range(1, len(intervals)):
        if intervals[j][0] <= intervals[i][1]:
            intervals[i][1] = max(intervals[i][1], intervals[j][1])
        else:
            i += 1
            intervals[i] = intervals[j]
    
    return intervals[:i+1]
```

APPROACH 3: Without Sorting (Inefficient)
------------------------------------------
Compare all pairs - O(n²) time complexity
Not recommended for large inputs

================================================================================
KEY INSIGHTS
================================================================================

1. Sorting is Critical:
   - Without sorting, we'd need to compare all pairs (O(n²))
   - Sorting enables linear merge pass (O(n))

2. Greedy Approach Works:
   - After sorting, we can make local decisions
   - No need to look ahead or backtrack

3. Overlap Detection:
   - Only need to check: current.start <= last.end
   - Don't need to check current.end

4. Merge Operation:
   - Always take max of end times
   - Start time is always from the earlier interval

5. Boundary Cases:
   - Touching intervals (end == start) are considered overlapping
   - Use <= not < for overlap check

================================================================================
COMMON MISTAKES
================================================================================

1. Forgetting to Sort:
   - Must sort before merging
   - Otherwise miss overlapping intervals

2. Wrong Overlap Condition:
   - Using < instead of <=
   - Missing touching intervals

3. Not Taking Max End Time:
   - When merging, must use max(end1, end2)
   - Current interval might be nested

4. Modifying While Iterating:
   - Be careful with in-place modifications
   - Can lead to index errors

5. Empty Input:
   - Check for empty array
   - Return [] immediately

================================================================================
OPTIMIZATION NOTES
================================================================================

1. Space Optimization:
   - Can modify input array in-place
   - Reduces space from O(n) to O(1)
   - But destroys original input

2. Early Termination:
   - If no overlaps detected for k consecutive intervals
   - Remaining intervals can be added directly
   - Rarely worth the complexity

3. Custom Sorting:
   - For specific data distributions
   - Counting sort if range is small
   - Usually not necessary

4. Parallel Processing:
   - Can partition and merge in parallel
   - Useful for very large datasets
   - Requires merge step at end

================================================================================
RELATED PROBLEMS
================================================================================

• Insert Interval (Medium) - Insert and merge new interval
• Non-overlapping Intervals (Medium) - Minimum removals to make non-overlapping
• Meeting Rooms (Easy) - Check if person can attend all meetings
• Meeting Rooms II (Medium) - Minimum meeting rooms needed
• Interval List Intersections (Medium) - Find intersections of two interval lists
• Employee Free Time (Hard) - Find common free time slots

================================================================================
PRACTICAL APPLICATIONS
================================================================================

1. Calendar Management:
   - Merge overlapping meetings
   - Find free time slots

2. Resource Allocation:
   - Merge time slots for resource usage
   - Identify conflicts

3. Data Processing:
   - Merge overlapping data ranges
   - Consolidate time series data

4. Network Traffic:
   - Merge packet transmission intervals
   - Identify busy periods

5. Database Queries:
   - Optimize range queries
   - Merge overlapping index ranges

================================================================================
