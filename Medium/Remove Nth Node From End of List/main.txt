================================================================================
REMOVE NTH NODE FROM END OF LIST - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given the head of a linked list, remove the nth node from the end of the list 
and return its head.

EXAMPLES:
---------
Example 1:
  Input: head = [1,2,3,4,5], n = 2
  Output: [1,2,3,5]

Example 2:
  Input: head = [1], n = 1
  Output: []

Example 3:
  Input: head = [1,2], n = 1
  Output: [1]

CONSTRAINTS:
------------
- The number of nodes in the list is sz.
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Finding the node from the end (singly linked list only goes forward)
2. Handling removal of the head node
3. Doing it in one pass

ALGORITHM STEPS:
----------------
Approach 1: Two Pass (Count Length)
1. Traverse list to find length `L`.
2. Target node is at index `L - n` (0-indexed).
3. Traverse again to `L - n - 1` (predecessor).
4. `prev.next = prev.next.next`.

Approach 2: One Pass (Two Pointers) ✓ OPTIMAL
1. Use a dummy node pointing to head (handles head removal).
2. Initialize two pointers `fast` and `slow` at dummy.
3. Move `fast` `n + 1` steps forward.
   - This creates a gap of `n` nodes between slow and fast.
4. Move both `fast` and `slow` forward until `fast` reaches None.
   - Now `slow` is exactly at the node BEFORE the target.
5. `slow.next = slow.next.next`.
6. Return `dummy.next`.


DETAILED EXPLANATION:
---------------------

One Pass Logic:
---------------
List: 1 -> 2 -> 3 -> 4 -> 5, n=2
Dummy -> 1 -> 2 -> 3 -> 4 -> 5

1. Fast moves n+1 (3) steps.
   Fast is at 3. Slow is at Dummy.
   Gap is 3 nodes (Dummy, 1, 2).

2. Move both until Fast is None.
   - Fast: 4, Slow: 1
   - Fast: 5, Slow: 2
   - Fast: None, Slow: 3

3. Slow is at 3. Target is 4 (2nd from end).
   Wait, logic check:
   If Fast moves n steps: Gap is n.
   When Fast hits end, Slow is n from end.
   We want predecessor (n+1 from end).
   So Fast should move n+1 steps initially? Or n steps and check fast.next?
   
   Let's trace standard algorithm:
   - Fast moves n steps.
   - If Fast is None, it means we remove Head (n = length).
   - Else, move Fast and Slow until Fast.next is None.
   - Slow is now predecessor.

   Example: 1->2->3->4->5, n=2
   - Fast moves 2 steps -> lands on 2.
   - Move Fast/Slow until Fast.next is None.
     - F:3, S:1
     - F:4, S:2
     - F:5, S:3 (Fast.next is None)
   - Slow is at 3. Target is 4.
   - `slow.next = slow.next.next` (3->5). Correct.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: One Pass (Two Pointers) ✓ RECOMMENDED
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        fast = dummy
        slow = dummy
        
        # Move fast n steps ahead
        for _ in range(n + 1):
            fast = fast.next
            
        # Move both until fast reaches end
        while fast:
            fast = fast.next
            slow = slow.next
            
        # Remove the nth node
        slow.next = slow.next.next
        
        return dummy.next


# Approach 2: Two Pass (Length Calculation)
class SolutionTwoPass:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # Get length
        length = 0
        curr = head
        while curr:
            length += 1
            curr = curr.next
            
        # Handle head removal
        if length == n:
            return head.next
            
        # Find predecessor
        target_idx = length - n
        curr = head
        for _ in range(target_idx - 1):
            curr = curr.next
            
        # Remove
        curr.next = curr.next.next
        return head


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n)
  - One pass or two passes, both linear.

Space Complexity: O(1)
  - Only pointers.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Middle Removal
  Input: [1,2,3,4,5], n=2
  Output: [1,2,3,5]
  ✓ Correct

Test Case 2: Head Removal
  Input: [1,2], n=2
  Output: [2]
  ✓ Dummy node handles this

Test Case 3: Tail Removal
  Input: [1,2], n=1
  Output: [1]
  ✓ Correct

Test Case 4: Single Node
  Input: [1], n=1
  Output: []
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Two Pointers ✓ RECOMMENDED
--------------------------------------
Pros:
  - Single pass.
  - Elegant.

Cons:
  - None.

Approach 2: Length Calculation
------------------------------
Pros:
  - Intuitive.

Cons:
  - Two passes (slower constant factor).


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Removing Head
   ❌ Not handling n == length
   ✓ Use dummy node to make head removal generic.

2. Off-by-one
   ❌ Moving fast n steps vs n+1 steps
   ✓ If moving n steps, stop when fast.next is None.
   ✓ If moving n+1 steps (from dummy), stop when fast is None.

3. Null Pointer
   ✓ Ensure n is valid (guaranteed by constraints).


================================================================================
KEY TAKEAWAYS
================================================================================

1. "Nth from end" -> Two pointers with gap N.
2. Dummy node simplifies edge cases (removing head).
3. Time O(n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Delete Node in a Linked List (Easy) - Given node access only
- Swapping Nodes in a Linked List (Medium)
- Reverse Nodes in k-Group (Hard)


================================================================================
