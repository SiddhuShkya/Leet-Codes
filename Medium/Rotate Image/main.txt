================================================================================
ROTATE IMAGE - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
You are given an n x n 2D matrix representing an image, rotate the image by 
90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 
2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

EXAMPLES:
---------
Example 1:
  Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
  Output: [[7,4,1],[8,5,2],[9,6,3]]

Example 2:
  Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
  Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

CONSTRAINTS:
------------
- n == matrix.length == matrix[i].length
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. In-place rotation (O(1) extra space)
2. Coordinate mapping for 90 degree rotation
3. Handling layers (onion peeling)

ALGORITHM STEPS:
----------------
Approach 1: Layer-by-Layer Rotation (O(N^2)) ✓ OPTIMAL
1. Process matrix in layers (outermost to innermost).
2. For each layer, define `left`, `right`, `top`, `bottom`.
3. Iterate `i` from 0 to `right - left - 1`.
4. Perform 4-way swap for each element `i` in the current layer:
   - Save `topLeft` (matrix[top][left + i]).
   - Move `bottomLeft` to `topLeft`.
   - Move `bottomRight` to `bottomLeft`.
   - Move `topRight` to `bottomRight`.
   - Move `saved topLeft` to `topRight`.
5. Shrink boundaries (`left++`, `right--`, etc.).

Approach 2: Transpose + Reverse (O(N^2))
1. Transpose the matrix (swap `matrix[i][j]` with `matrix[j][i]`).
2. Reverse each row.
   - Transpose turns rows into columns.
   - Reversing rows effectively rotates columns 90 degrees.


DETAILED EXPLANATION:
---------------------

Layer Rotation (3x3):
---------------------
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

Layer 0 (Outer):
i = 0:
- Save 1 (TopLeft).
- Move 7 (BottomLeft) -> TopLeft.
- Move 9 (BottomRight) -> BottomLeft.
- Move 3 (TopRight) -> BottomRight.
- Move 1 (Saved) -> TopRight.
Result:
[7, 2, 1]
[4, 5, 6]
[9, 8, 3]

i = 1:
- Save 2.
- Move 4 -> 2 position.
- Move 8 -> 4 position.
- Move 6 -> 8 position.
- Move 2 -> 6 position.
Result:
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]

Layer 1 (Inner): Single element 5. No rotation needed.


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Layer-by-Layer (Optimal) ✓ RECOMMENDED
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        l, r = 0, len(matrix) - 1
        
        while l < r:
            for i in range(r - l):
                top, bottom = l, r
                
                # Save top left
                top_left = matrix[top][l + i]
                
                # Move bottom left to top left
                matrix[top][l + i] = matrix[bottom - i][l]
                
                # Move bottom right to bottom left
                matrix[bottom - i][l] = matrix[bottom][r - i]
                
                # Move top right to bottom right
                matrix[bottom][r - i] = matrix[top + i][r]
                
                # Move top left to top right
                matrix[top + i][r] = top_left
                
            l += 1
            r -= 1


# Approach 2: Transpose + Reverse (Easier to Code)
class SolutionTranspose:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        
        # Transpose
        for i in range(n):
            for j in range(i, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
                
        # Reverse Rows
        for i in range(n):
            matrix[i].reverse()


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(N^2)
  - Visit every cell once.

Space Complexity: O(1)
  - In-place modification.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: 3x3
  Input: [[1,2,3],[4,5,6],[7,8,9]]
  Output: [[7,4,1],[8,5,2],[9,6,3]]
  ✓ Correct

Test Case 2: 4x4
  Input: [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
  Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Layer-by-Layer ✓ RECOMMENDED
----------------------------------------
Pros:
  - Direct simulation.
  - Good for demonstrating coordinate mastery.

Cons:
  - Indexing is error-prone.

Approach 2: Transpose + Reverse
-------------------------------
Pros:
  - Very easy to remember and implement.
  - Less prone to index errors.

Cons:
  - Two passes over matrix (still O(N^2)).


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Coordinate Confusion
   ❌ `matrix[top][l + i]` vs `matrix[top + i][l]`
   ✓ Draw a diagram to verify indices.
   ✓ Remember: `top` row index is fixed, col index varies `l+i`.
   ✓ `right` col index is fixed, row index varies `top+i`.

2. Loop Bounds
   ✓ `range(r - l)` ensures we don't rotate corners twice.

3. Clockwise vs Counter-Clockwise
   ✓ Transpose + Reverse = Clockwise.
   ✓ Transpose + Reverse Columns (or Reverse + Transpose) = Counter-Clockwise.


================================================================================
KEY TAKEAWAYS
================================================================================

1. In-place matrix manipulation often involves layers or math tricks (transpose).
2. 4-way swap logic: `temp = A; A = B; B = C; C = D; D = temp`.
3. Time O(N^2), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Spiral Matrix (Medium)
- Determine Whether Matrix Can Be Obtained By Rotation (Easy)


================================================================================
