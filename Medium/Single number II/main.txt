================================================================================
SINGLE NUMBER II - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given an integer array nums where every element appears three times except for 
one, which appears exactly once. Find the single element and return it.

You must implement a solution with a linear runtime complexity and use only 
constant extra space.

EXAMPLES:
---------
Example 1:
  Input: nums = [2,2,3,2]
  Output: 3

Example 2:
  Input: nums = [0,1,0,1,0,1,99]
  Output: 99

CONSTRAINTS:
------------
- 1 <= nums.length <= 3 * 10^4
- -2^31 <= nums[i] <= 2^31 - 1
- Each element in nums appears exactly three times except for one element which 
  appears once.


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. O(n) time complexity
2. O(1) space complexity
3. Handling negative numbers (in bitwise approach)

ALGORITHM STEPS:
----------------
Approach 1: Sorting (O(n log n))
1. Sort the array.
2. Iterate with step 3.
3. If `nums[i] != nums[i+1]`, then `nums[i]` is the single one.
4. Handle edge case (last element).

Approach 2: Bitwise Counting (O(n)) ✓ GENERALIZABLE
1. Iterate through all 32 bits.
2. For each bit position `i`, count how many numbers have this bit set.
3. If `sum % 3 != 0`, it means the single number has this bit set.
4. Reconstruct the single number.

Approach 3: Digital Logic Design (O(n)) ✓ OPTIMAL
1. We need a counter that counts modulo 3 for each bit.
2. States: 00 -> 01 -> 10 -> 00.
3. Use two variables `ones` and `twos`.
   - `ones`: Bits that have appeared 1st time.
   - `twos`: Bits that have appeared 2nd time.
4. Logic:
   - `ones = (ones ^ num) & ~twos`
   - `twos = (twos ^ num) & ~ones`
5. Return `ones`.


DETAILED EXPLANATION:
---------------------

Digital Logic Approach:
-----------------------
We want to track bits that appear 1, 2, or 3 times.
If a bit appears 3 times, we reset it to 0.

State Table for a single bit:
Current | Input | Next State
00      | 1     | 01 (1 time)
01      | 1     | 10 (2 times)
10      | 1     | 00 (3 times -> reset)

Implementation:
`ones` stores bits appearing 1 (mod 3) times.
`twos` stores bits appearing 2 (mod 3) times.

Update `ones`:
- XOR with num adds bit to `ones` if not present.
- `& ~twos` ensures we don't keep it if it was already in `twos` (meaning it's now 3rd time).

Update `twos`:
- XOR with num adds bit to `twos` if not present.
- `& ~ones` ensures we don't keep it if it's now in `ones` (meaning it was 0, now 1).

Example: [2, 2, 2, 3] (Binary: 10, 10, 10, 11)
1. Num 2 (10): ones=10, twos=00
2. Num 2 (10): ones=00, twos=10
3. Num 2 (10): ones=00, twos=00 (Reset!)
4. Num 3 (11): ones=11, twos=00
Result: 11 (3).


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Digital Logic (Optimal) ✓ RECOMMENDED
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones = 0
        twos = 0
        
        for num in nums:
            # Update ones: add num bits, but remove if already in twos
            ones = (ones ^ num) & ~twos
            
            # Update twos: add num bits, but remove if now in ones
            twos = (twos ^ num) & ~ones
            
        return ones


# Approach 2: Bit Counting (Conceptual)
class SolutionBitCount:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            count = 0
            for num in nums:
                if (num >> i) & 1:
                    count += 1
            
            if count % 3 != 0:
                # In Python, handling negative numbers with bitwise is tricky
                # because integers have infinite precision.
                # We need to handle 32-bit sign manually.
                if i == 31:
                    ans -= (1 << 31)
                else:
                    ans |= (1 << i)
        return ans


# Approach 3: Sorting (Sub-optimal O(N log N))
class SolutionSort:
    def singleNumber(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(0, len(nums) - 1, 3):
            if nums[i] != nums[i+1]:
                return nums[i]
        return nums[-1]


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Approach 1: Digital Logic
-------------------------
Time Complexity: O(n)
  - Single pass.

Space Complexity: O(1)
  - Two variables.

Approach 3: Sorting
-------------------
Time Complexity: O(n log n)
  - Sorting dominates.

Space Complexity: O(1) or O(log n)


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Standard
  Input: [2,2,3,2]
  Output: 3
  ✓ Correct

Test Case 2: Negative
  Input: [-2,-2,1,1,4,1,4,4,-4,-2] -> Wait, -2 three times, 1 three times, 4 three times, -4 once.
  Output: -4
  ✓ Digital logic handles negatives naturally (2's complement).

Test Case 3: Zero
  Input: [0,1,0,1,0,1,99]
  Output: 99
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Digital Logic ✓ RECOMMENDED
---------------------------------------
Pros:
  - O(n) time, O(1) space.
  - Handles negatives automatically in Python.

Cons:
  - Hard to derive without knowing logic design.

Approach 2: Bit Counting
------------------------
Pros:
  - Intuitive (sum bits % 3).

Cons:
  - Python's infinite integers make sign handling messy.

Approach 3: Hash Map
--------------------
Count frequencies.
Pros: Trivial.
Cons: O(n) space (fails constraint).


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Using XOR Sum
   ❌ XORing all numbers (works for Single Number I, not II)
   ✓ XOR cancels out pairs (2 times), not triples.

2. Sorting
   ❌ Using sorting when O(n) is required
   ✓ Sorting is O(n log n).

3. Python Bitwise Sign
   ✓ Be careful constructing integers bit-by-bit in Python. `ones/twos` logic avoids this.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Generalize Single Number: Count bits modulo K.
2. Digital Logic Design allows creating counters using bitwise ops.
3. `ones = (ones ^ num) & ~twos`.
4. Time O(n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Single Number (Easy) - Appears 2 times
- Single Number III (Medium) - Two numbers appear once
- Majority Element (Easy)


================================================================================
