================================================================================
SPIRAL MATRIX - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
Given an m x n matrix, return all elements of the matrix in spiral order.

EXAMPLES:
---------
Example 1:
  Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
  Output: [1,2,3,6,9,8,7,4,5]

Example 2:
  Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
  Output: [1,2,3,4,8,12,11,10,9,5,6,7]

CONSTRAINTS:
------------
- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 10
- -100 <= matrix[i][j] <= 100


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Managing boundaries (top, bottom, left, right)
2. Handling corner cases (single row, single column)
3. Avoiding duplicate processing of elements

ALGORITHM STEPS:
----------------
Approach 1: Simulation with Boundaries (O(m*n)) ✓ OPTIMAL
1. Define boundaries: `top=0`, `bottom=m-1`, `left=0`, `right=n-1`.
2. Loop while `top <= bottom` and `left <= right`:
   - Traverse Top Row: `left` to `right`. Increment `top`.
   - Traverse Right Column: `top` to `bottom`. Decrement `right`.
   - Check if boundaries crossed (`top > bottom` or `left > right`). Break if so.
   - Traverse Bottom Row: `right` to `left`. Decrement `bottom`.
   - Traverse Left Column: `bottom` to `top`. Increment `left`.
3. Return result list.


DETAILED EXPLANATION:
---------------------

Matrix:
[ 1, 2, 3 ]
[ 4, 5, 6 ]
[ 7, 8, 9 ]

1. Top Row (1, 2, 3). Top becomes 1.
2. Right Col (6, 9). Right becomes 1.
3. Check bounds: top(1) <= bottom(2), left(0) <= right(1). OK.
4. Bottom Row (8, 7). Bottom becomes 1.
5. Left Col (4). Left becomes 1.
6. Check bounds: top(1) <= bottom(1), left(1) <= right(1). OK.
7. Top Row (5). Top becomes 2.
8. Right Col (Empty range 2 to 1). Right becomes 0.
9. Check bounds: top(2) > bottom(1). Break.

Result: [1, 2, 3, 6, 9, 8, 7, 4, 5].


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Boundary Simulation (Optimal) ✓ RECOMMENDED
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        if not matrix:
            return res
            
        top, bottom = 0, len(matrix) - 1
        left, right = 0, len(matrix[0]) - 1
        
        while top <= bottom and left <= right:
            # Traverse Top Row
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            top += 1
            
            # Traverse Right Column
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            right -= 1
            
            # Check if we are done
            if top > bottom or left > right:
                break
            
            # Traverse Bottom Row
            for i in range(right, left - 1, -1):
                res.append(matrix[bottom][i])
            bottom -= 1
            
            # Traverse Left Column
            for i in range(bottom, top - 1, -1):
                res.append(matrix[i][left])
            left += 1
            
        return res


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(m * n)
  - Visit every element exactly once.

Space Complexity: O(1)
  - Excluding output array.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: Square
  Input: [[1,2],[3,4]]
  Output: [1,2,4,3]
  ✓ Correct

Test Case 2: Rectangle (Wide)
  Input: [[1,2,3,4],[5,6,7,8]]
  Output: [1,2,3,4,8,7,6,5]
  ✓ Correct

Test Case 3: Single Row
  Input: [[1,2,3]]
  Output: [1,2,3]
  ✓ Top loop runs, then top > bottom breaks. Correct.

Test Case 4: Single Column
  Input: [[1],[2],[3]]
  Output: [1,2,3]
  ✓ Top/Right loops run for each element. Correct.


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Boundaries ✓ RECOMMENDED
------------------------------------
Pros:
  - Direct simulation.
  - O(1) space.

Cons:
  - Lots of index management.

Approach 2: Direction Array
---------------------------
Use `dirs = [(0,1), (1,0), (0,-1), (-1,0)]` and a `visited` matrix.
Pros: Cleaner loop logic.
Cons: O(m*n) space for visited matrix.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. Duplicate Traversal
   ❌ Not checking `if top > bottom` before traversing bottom row
   ✓ Essential for non-square matrices (e.g., single row). If you don't check, 
     you might traverse the single row again from right to left.

2. Index Bounds
   ✓ `range(left, right + 1)` includes right.
   ✓ `range(right, left - 1, -1)` includes left.


================================================================================
KEY TAKEAWAYS
================================================================================

1. Use 4 variables for boundaries.
2. Always check boundary validity before reverse traversals (bottom/left).
3. Time O(m*n), Space O(1).


================================================================================
RELATED PROBLEMS
================================================================================

- Spiral Matrix II (Medium) - Generate the matrix
- Spiral Matrix III (Medium)
- Spiral Matrix IV (Medium)


================================================================================
