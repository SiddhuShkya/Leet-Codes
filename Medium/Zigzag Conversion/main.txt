================================================================================
ZIGZAG CONVERSION - LEETCODE MEDIUM
================================================================================

PROBLEM STATEMENT:
------------------
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of 
rows like this: (you may want to display this pattern in a fixed font for 
better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number 
of rows.

EXAMPLES:
---------
Example 1:
  Input: s = "PAYPALISHIRING", numRows = 3
  Output: "PAHNAPLSIIGYIR"

Example 2:
  Input: s = "PAYPALISHIRING", numRows = 4
  Output: "PINALSIGYAHRPI"
  Explanation:
  P     I    N
  A   L S  I G
  Y A   H R
  P     I

Example 3:
  Input: s = "A", numRows = 1
  Output: "A"

CONSTRAINTS:
------------
- 1 <= s.length <= 1000
- s consists of English letters (lower-case and upper-case), ',' and '.'.
- 1 <= numRows <= 1000


================================================================================
SOLUTION APPROACH
================================================================================

KEY CHALLENGES:
---------------
1. Simulating the Zigzag traversal
2. Calculating index jumps mathematically
3. Handling edge cases (numRows = 1)

ALGORITHM STEPS:
----------------
Approach 1: Simulation (Row Buffers) (O(n)) ✓ SIMPLE
1. Create `numRows` empty strings (buffers).
2. Iterate through characters of `s`.
3. Keep track of `current_row` and `direction` (down or up).
4. Append char to `buffers[current_row]`.
5. If `current_row` reaches top or bottom, flip direction.
6. Join all buffers.

Approach 2: Mathematical Construction (O(n)) ✓ OPTIMAL
1. Iterate row by row (0 to numRows-1).
2. For each row, jump through the string to find characters belonging to it.
3. The "cycle" length is `2 * numRows - 2`.
4. For first and last row, characters are at `k * cycle + row`.
5. For middle rows, there is an extra character in the "diagonal" part at 
   `(k+1) * cycle - row`.


DETAILED EXPLANATION:
---------------------

Mathematical Pattern (numRows = 4):
-----------------------------------
Cycle = 2*4 - 2 = 6.

Row 0: Indices 0, 6, 12... (Step 6)
Row 1: Indices 1, 5, 7, 11... (Step 6, with intermediate at 6-1=5, 12-1=11)
Row 2: Indices 2, 4, 8, 10... (Step 6, with intermediate at 6-2=4, 12-2=10)
Row 3: Indices 3, 9... (Step 6)

General Formula:
- Main columns: `index % cycle == row`
- Diagonals: `index % cycle == cycle - row`


================================================================================
CODE IMPLEMENTATION
================================================================================

# Approach 1: Simulation (Recommended for Interview)
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1 or numRows >= len(s):
            return s
        
        rows = [''] * numRows
        curr_row = 0
        step = 1
        
        for char in s:
            rows[curr_row] += char
            
            # Change direction at top or bottom
            if curr_row == 0:
                step = 1
            elif curr_row == numRows - 1:
                step = -1
                
            curr_row += step
            
        return ''.join(rows)


# Approach 2: Mathematical Indexing (Faster, less memory overhead)
class SolutionMath:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        
        res = []
        n = len(s)
        cycle_len = 2 * numRows - 2
        
        for r in range(numRows):
            for i in range(r, n, cycle_len):
                # Add character in vertical column
                res.append(s[i])
                
                # Check for diagonal character (middle rows only)
                # Formula: current_index + cycle - 2*row
                diag_idx = i + cycle_len - 2 * r
                if r != 0 and r != numRows - 1 and diag_idx < n:
                    res.append(s[diag_idx])
                    
        return "".join(res)


================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity: O(n)
  - Visit every character once.

Space Complexity: O(n)
  - Store result string.


================================================================================
TEST CASES & VERIFICATION
================================================================================

Test Case 1: 3 Rows
  Input: "PAYPALISHIRING", 3
  Output: "PAHNAPLSIIGYIR"
  ✓ Correct

Test Case 2: 4 Rows
  Input: "PAYPALISHIRING", 4
  Output: "PINALSIGYAHRPI"
  ✓ Correct

Test Case 3: 1 Row
  Input: "A", 1
  Output: "A"
  ✓ Handled by base case

Test Case 4: Short String
  Input: "AB", 1
  Output: "AB"
  ✓ Correct


================================================================================
ALTERNATIVE APPROACHES
================================================================================

Approach 1: Simulation ✓ RECOMMENDED
------------------------------------
Pros:
  - Intuitive logic (up/down movement).
  - Easy to implement.

Cons:
  - O(n) space for buffers (same as result).

Approach 2: Math
----------------
Pros:
  - Direct calculation.

Cons:
  - Index logic is prone to off-by-one errors.


================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. numRows = 1
   ❌ Infinite loop or division by zero in math logic
   ✓ Handle explicitly at start

2. Index Out of Bounds
   ✓ Check `diag_idx < n` before accessing

3. Cycle Length
   ✓ `2 * numRows - 2` (Down n, Up n-2)


================================================================================
KEY TAKEAWAYS
================================================================================

1. Simulation is often easier than math for "pattern" problems.
2. Cycle length is key for mathematical approach.
3. Time O(n), Space O(n).


================================================================================
RELATED PROBLEMS
================================================================================

- Diagonal Traverse (Medium)
- Spiral Matrix (Medium)


================================================================================
